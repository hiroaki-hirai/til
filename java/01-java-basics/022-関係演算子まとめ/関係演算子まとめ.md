# 関係演算子まとめ

以下に、**Java Silver 試験で問われやすい「関係演算子（比較演算子）」のパターン問題集**をまとめました。

==, !=, <, >, <=, >= に加えて、`equals()`との違い・`char/文字列/参照型`の比較でひっかけられやすいものを重点的に収録しています。

---

## ✅ Java 関係演算子 パターン問題集（試験対応）

---

### ❶ 【数値型の比較】

```java
int a = 5;
int b = 10;
System.out.println(a < b);
```

**Q: 出力は？**

✅ **答え：true**

**理由**：`5 < 10` → true

---

### ❷ 【異なる数値型の比較】

```java
int a = 5;
double b = 5.0;
System.out.println(a == b);
```

**Q: 出力は？**

✅ **答え：true**

**理由**：`int` は `double` に昇格 → 数値が等しいため true

---

### ❸ 【char の比較】

```java
char c1 = 'A';
char c2 = 'B';
System.out.println(c1 < c2);
```

**Q: 出力は？**

✅ **答え：true**

**理由**：'A'（65） < 'B'（66）

---

### ❹ 【文字列の == 比較（リテラル）】

```java
String s1 = "hello";
String s2 = "hello";
System.out.println(s1 == s2);
```

**Q: 出力は？**

✅ **答え：true**

**理由**：文字列リテラルは**文字列プールに intern されるため**、同一参照になる

---

### ❺ 【文字列の == 比較（new使用）】

```java
String s1 = new String("hello");
String s2 = new String("hello");
System.out.println(s1 == s2);
```

**Q: 出力は？**

❌ **答え：false**

**理由**：`new` で生成すると**別オブジェクト**になるため、参照が異なる

✅ 比較するなら：

```java
System.out.println(s1.equals(s2));  // → true
```

---

### ❻ 【equals() での比較】

```java
String s1 = "java";
String s2 = "java";
System.out.println(s1.equals(s2));
```

**Q: 出力は？**

✅ **答え：true**

**理由**：equals() は**内容を比較**するため、文字列が一致していれば true

---

### ❼ 【null参照に対する比較】

```java
String s = null;
System.out.println(s == null);
```

**Q: 出力は？**

✅ **答え：true**

**理由**：null比較は参照そのものをチェックするため OK

---

### ❽ 【null参照で equals() を呼ぶ】

```java
String s = null;
System.out.println(s.equals("test"));
```

**Q: 実行結果は？**

❌ **答え：NullPointerException 発生**

**理由**：nullに対してメソッド呼び出しはできない

✅ 安全な書き方：

```java
System.out.println("test".equals(s));
```

---

### ❾ 【boolean の比較】

```java
boolean flag = true;
System.out.println(flag == true);
```

**Q: 出力は？**

✅

**答え：true**

**理由**

：明示的に比較しているため OK。

ただし実務では：

```java
if (flag) { ... }  // ←これが一般的
```

---

### 🔟 【参照型の == 比較（配列）】

```java
int[] arr1 = {1, 2, 3};
int[] arr2 = {1, 2, 3};
System.out.println(arr1 == arr2);
```

**Q: 出力は？**

❌ **答え：false**

**理由**：配列も参照型 → 中身が同じでも参照が異なれば false

---

## ✅ 知識のまとめ：== と equals() の違い

| 比較対象 | `==`（イコール演算子） | `equals()` |
| --- | --- | --- |
| プリミティブ型 | 値を比較 | 使用不可（プリミティブはメソッドを持たない） |
| 参照型（Stringなど） | 参照先（同一オブジェクトか） | 内容の比較（クラスでオーバーライド可能） |
| null | `== null` は OK | `null.equals(...)` は **例外** |

---

## ✅ 関係演算子の一覧（試験用チェックリスト）

| 演算子 | 意味 | 使用対象 |
| --- | --- | --- |
| `==` | 等しい | 値または参照（プリミティブ/参照型） |
| `!=` | 等しくない | 同上 |
| `<` | より小さい | 数値型、char |
| `>` | より大きい | 同上 |
| `<=` | 以下 | 同上 |
| `>=` | 以上 | 同上 |

はい、Hiroakiさんがすでに押さえているパターンはJava Silver～Gold試験で問われる関係演算子の大半をカバーしていますが、**さらに応用・実務レベルで役立つ or 試験で見落とされがちなパターンが数件存在します**。

以下に「応用として知っておくと有利な追加パターン」を整理します。

---

## ✅ 関係演算子の応用・盲点パターン（上級～実務）

---

### ❶ ラッパークラスと `==` の罠（オートボクシング）

**✅ 結果：true**

```java
Integer a = 100;
Integer b = 100;
System.out.println(a == b);  // true or false？
```

- `128～127` までは Java が**Integerキャッシュ**を使うため `==` で true
- **参照が同一**

---

```java
Integer a = 200;
Integer b = 200;
System.out.println(a == b);  // false
```

**✅ 結果：false**

- `Integer` は 128以上の値ではキャッシュしないため、別インスタンス

---

### ❷ `compareTo()` と関係演算子の連携

```java
String s1 = "apple";
String s2 = "banana";
System.out.println(s1.compareTo(s2) < 0);
```

**✅ 結果：true**

- `"apple"` は `"banana"` より辞書順で前 → `compareTo()` の戻り値は負 → true

---

### ❸ `char` 同士の数値比較（intとの互換）

```java
char c = 'A';
System.out.println(c == 65);  // true
```

**✅ 結果：true**

- `'A'` は Unicodeで65 → `char` と `int` の比較OK

---

### ❹ `instanceof` は関係演算子ではないが、比較用途で混同注意

```java
String s = "hello";
System.out.println(s instanceof String);  // true
```

- `instanceof` は**型チェック**であり、**等価演算子ではないが混同しやすい**

---

### ❺ `Arrays.equals()` / `Objects.equals()` を使った比較

```java
int[] a = {1, 2, 3};
int[] b = {1, 2, 3};
System.out.println(Arrays.equals(a, b));  // true
```

- **配列は `==` では比較できない** → `Arrays.equals()` を使う必要がある

---

### ❻ `NaN`との比較（浮動小数点特有）

```java
double d = Double.NaN;
System.out.println(d == d);            // false
System.out.println(Double.isNaN(d));   // true
```

- `NaN` は自分自身と等しくない → `==` が false
- 比較には **`Double.isNaN()` を使う**

---

### ❼ 型が異なる参照型同士の == 比較

```java
Object o = "test";
String s = "test";
System.out.println(o == s);     // true
System.out.println(o.equals(s)); // true
```

- **`==` は参照比較** → 同じオブジェクトなら型が違っても true
- **`equals()` は型と内容両方見る（オーバーライド次第）**
- `"test"` という文字列リテラルは **Javaの文字列プール**に格納される

```java
String s1 = "test";
String s2 = "test";
System.out.println(s1 == s2);  // true
```

→ 文字列リテラルは **再利用（intern）される**ため、s1とs2は**同一のオブジェクト**を参照

---

- `Object o = "test";` でも `"test"` の参照をそのまま格納している

`o` は `Object` 型に見えますが、`"test"` の参照を保持しているだけ

つまり、`o` と `s` は **どちらも同じ `"test"` オブジェクト**を参照している

```java
Object o = "test";   // o → 文字列"test"を参照（型はObjectだが中身は同じ）
String s = "test";   // s → 文字列"test"を参照
```

---

### ✅ 特殊ケースまとめ

| パターン | 結果または注意点 |
| --- | --- |
| `Integer`同士の `==`（小さい数） | true（キャッシュ） |
| `Integer`同士の `==`（大きい数） | false（別オブジェクト） |
| `NaN == NaN` | false（特殊なルール） |
| `"abc".compareTo("def") < 0` | true（辞書順） |
| `char == int` | true（数値として比較される） |
| `null.equals(...)` | ❌ NullPointerException |
| `"abc" == "abc"`（リテラル） | true（文字列プール） |
| `new String("abc") == "abc"` | false（別インスタンス） |