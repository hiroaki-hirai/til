# hypot()

`Math.hypot()` は Java における **直角三角形の斜辺の長さ（√(a² + b²)）を計算するメソッド** です。

これはピタゴラスの定理（a² + b² = c²）に基づいて、**ユーザーが直接2乗して平方根を取る代わりに、安全で精度の高い方法で斜辺を求められる便利な関数**です。

---

## ✅ `Math.hypot()` の基本情報

| 項目 | 内容 |
| --- | --- |
| クラス | `java.lang.Math`（インポート不要） |
| メソッド名 | `hypot()` |
| 用途 | 直角三角形の斜辺（√(x² + y²)）を計算 |
| 戻り値の型 | `double` |

---

## 🔹 シグネチャ（定義）

```java
public static double hypot(double x, double y)
```

- `x`：一辺（直角を挟む辺）
- `y`：もう一辺（直角を挟む辺）
- **戻り値：斜辺の長さ（double 型）**

---

## 🔹 使用例

```java
System.out.println(Math.hypot(3, 4)); // → 5.0（3² + 4² = 9 + 16 = 25 → √25 = 5）
System.out.println(Math.hypot(5, 12)); // → 13.0（5² + 12² = 169 → √169 = 13）
System.out.println(Math.hypot(1.0, 1.0)); // → 約1.414（√2）
```

---

## 🔸 特徴と利点（手計算との違い）

通常の計算：

```java
Math.sqrt(x * x + y * y)
```

これでも同じ結果が得られますが…

| 比較点 | `Math.sqrt(x*x + y*y)` | `Math.hypot(x, y)` |
| --- | --- | --- |
| **オーバーフロー対策** | ❌ 大きな値ではオーバーフローしやすい | ✅ 内部でスケーリング処理をして安全 |
| **精度** | △ 精度誤差が出やすい | ◎ IEEE 754準拠の高精度計算 |
| **NaNの扱い** | △ 式によっては先にNaNが混じる | ◎ `x`か`y`がNaNならNaNを返す |
| **読みやすさ** | △ 少し計算内容が見づらい | ◎ 「斜辺を求める」意図が明確 |

---

## 🔹 特殊な値の挙動

| 入力 | 結果 | 説明 |
| --- | --- | --- |
| `Math.hypot(0, 0)` | `0.0` | ゼロの時は0 |
| `Math.hypot(-3, 4)` | `5.0` | 符号は影響しない（2乗されるため） |
| `Math.hypot(NaN, 1.0)` | `NaN` | どちらかが NaN → 結果も NaN |
| `Math.hypot(+∞, 2.0)` | `Infinity` | 無限大が含まれていれば結果も無限大 |

---

## ✅ よくある誤解と注意点

| 誤解内容 | 実際の挙動 |
| --- | --- |
| `Math.hypot(x, y)` は `x * y` の平方根？ | ❌ それは √(x × y)。`hypot()` は √(x² + y²) |
| `sqrt(x * x + y * y)` と全く同じ？ | ❌ 計算上の意味は同じでも、`hypot()` の方が**精度と安全性に優れる** |
| 負の値を入れるとエラーになる？ | ❌ 負数もOK。2乗するので常に非負値として扱われる |
| `hypot()` は `int` を返す？ | ❌ 常に `double` を返す |

---

## ✅ 実務での利用例

- 二次元空間での **2点間の距離計算**
- ベクトルの **大きさ（ノルム）** の計算
- グラフィックスやゲームでの **座標の距離処理**
- 三角関数・ピタゴラスの定理の自動計算

---

### ✍️ 例：2点間のユークリッド距離

```java
double dx = x2 - x1;
double dy = y2 - y1;
double distance = Math.hypot(dx, dy);
```

---

## 🔺 `Math.hypot()` 引っかけ問題集（全5問）

---

### ❓ 問題1：`Math.hypot(3, 4)` の結果は？

```java
System.out.println(Math.hypot(3, 4));
```

A. `5.0`

B. `7.0`

C. `1.0`

D. コンパイルエラー

**答え**：A. `5.0`

**解説**：

ピタゴラスの定理：

3² + 4² = 9 + 16 = 25 → √25 = 5

✅ 正しく「斜辺の長さ」を計算します。

---

### ❓ 問題2：負の数の扱い

```java
System.out.println(Math.hypot(-5, 12));
```

A. `13.0`

B. `-13.0`

C. `12.0`

D. コンパイルエラー

**答え**：A. `13.0`

**解説**：

負の数もOK！平方するのでマイナスは無視されます。

-5² + 12² = 25 + 144 = 169 → √169 = 13

---

### ❓ 問題3：戻り値の型は？

```java
var result = Math.hypot(6, 8);
System.out.println(((Object)result).getClass().getSimpleName());
```

A. `Integer`

B. `Double`

C. `Float`

D. `Long`

**答え**：B. `Double`

**解説**：

`Math.hypot()` の戻り値は常に `double`。

引数が `int` でも、結果は小数型（浮動小数点）になります。

---

### ❓ 問題4：NaNの扱い

```java
System.out.println(Math.hypot(Double.NaN, 2));
```

A. `NaN`

B. `2.0`

C. `Infinity`

D. コンパイルエラー

**答え**：A. `NaN`

**解説**：

どちらか一方でも NaN があれば、結果は **NaN** になります。

`hypot()` はこの点で他の `Math` メソッドと共通ルールです。

---

### ❓ 問題5：`Math.sqrt(x*x + y*y)` と `Math.hypot(x, y)` の違い

2つのコードは完全に同じ動作をするか？

A. どちらもまったく同じ

B. 精度やオーバーフロー耐性に違いがある

C. 片方は常にNaNを返す

D. コンパイルエラーになる

**答え**：B. 精度やオーバーフロー耐性に違いがある

**解説**：

数式としては似ていますが、

- `sqrt(x*x + y*y)` はオーバーフロー・アンダーフローしやすい
- `hypot(x, y)` は内部でスケーリングして安全な計算をする

✅ 精度や安全性を考えると、**`hypot()` の方が優れている**と覚えておきましょう。

---

## ✅ よくある誤解まとめ

| 誤解内容 | 正しい理解 |
| --- | --- |
| `hypot()` は x と y を掛け算する？ | ❌ 2乗の和の平方根（√(x² + y²)) を求める |
| 負の数を渡すとエラーになる？ | ❌ 負でも問題なし。2乗するため常に非負になる |
| `hypot()` は整数を返す？ | ❌ 常に `double` 型 |
| `sqrt(x*x + y*y)` と完全に同じ？ | ❌ `hypot()` の方がオーバーフロー対策など精密 |