# equals()

はい、`Arrays.equals()` メソッドは、Javaで**配列の内容を比較**するために使用されるユーティリティメソッドです。以下で詳しく解説します。

---

## 🔍 `Arrays.equals()` メソッドの概要

```java
public static boolean equals(int[] a, int[] a2)
public static boolean equals(Object[] a, Object[] a2)
```

### ✅ 機能

- **各要素を順に比較**して、すべての要素が等しい場合に `true` を返します。
- 比較対象の配列が `null` の場合や、長さ・順序・内容が異なる場合は `false`。

---

## 🧪 基本動作例（プリミティブ配列）

```java
int[] a1 = {1, 2, 3};
int[] a2 = {1, 2, 3};
System.out.println(Arrays.equals(a1, a2)); // true
```

```java
int[] a3 = {1, 2, 4};
System.out.println(Arrays.equals(a1, a3)); // false
```

---

## 🧪 参照型配列の場合（Object[]）

```java
String[] s1 = {"A", "B"};
String[] s2 = {"A", "B"};
System.out.println(Arrays.equals(s1, s2)); // true
```

```java
String[] s3 = {"A", new String("B")};
System.out.println(Arrays.equals(s1, s3)); // true（内容は同じ）
```

※ 参照先のオブジェクトが `equals()` をオーバーライドしていれば、**中身の比較**になります。

---

## ⚠ 注意：多次元配列の場合は要注意！

```java
String[][] m1 = {{"A"}, {"B"}};
String[][] m2 = {{"A"}, {"B"}};

System.out.println(Arrays.equals(m1, m2));      // false ← 参照だけを比較
System.out.println(Arrays.deepEquals(m1, m2));  // true ← 中身まで再帰的に比較
```

- `Arrays.equals()` は **1次元までの中身比較**
- `Arrays.deepEquals()` は **多次元配列や参照型配列の再帰的な内容比較**

---

## 📌 nullの扱い

```java
int[] a = null;
int[] b = null;
System.out.println(Arrays.equals(a, b)); // true
```

- **両方がnull** → true
- **片方だけnull** → false

---

## 🎯 試験で狙われるポイント（Java Silver / Gold）

| パターン | ポイント |
| --- | --- |
| `Arrays.equals()` vs `==` | `==` は参照の比較。equals() は内容の比較 |
| 多次元配列で `equals()` | false を返す（参照比較） |
| `deepEquals()` との違い | 再帰的比較の必要性に注意 |
| nullとの比較 | 両方nullならtrue、片方nullならfalse |

---

### 🧠 補足：関連メソッド一覧

| メソッド | 説明 |
| --- | --- |
| `Arrays.equals()` | 1次元の要素ごとの比較 |
| `Arrays.deepEquals()` | 多次元・オブジェクトのネストにも対応 |
| `Arrays.compare()` | Java 9以降、大小比較に対応（並び順） |

以下に、**Java Silver 試験風の Arrays.equals() に関するパターン問題集**を用意しました。出題傾向を意識し、**文法知識・挙動理解・ひっかけポイント**を押さえています。

---

## ✅ Java Silver風：`Arrays.equals()` パターン問題集

---

### 🔹【Q1】基本構文の理解

次のコードを実行した結果として正しいものはどれか。

```java
int[] a = {1, 2, 3};
int[] b = {1, 2, 3};
System.out.println(Arrays.equals(a, b));
```

A. false

B. true

C. コンパイルエラー

D. 実行時例外が発生する

**✅正解：B**

**📘解説：** 配列は参照型だが `Arrays.equals()` は中身を要素単位で比較するため `true` を返す。

---

### 🔹【Q2】参照型配列の比較

以下のコードの出力結果として正しいものはどれか。

```java
String[] s1 = {"A", "B"};
String[] s2 = {"A", new String("B")};
System.out.println(Arrays.equals(s1, s2));
```

A. true

B. false

C. コンパイルエラー

D. 実行時例外

**✅正解：A**

**📘解説：** `String` は `equals()` をオーバーライドしているため、内容が同じであれば等価と判断される。

---

### 🔹【Q3】equalsと==の違い

以下のコードの出力結果として正しいものはどれか。

```java
int[] a1 = {1, 2};
int[] a2 = {1, 2};
System.out.println(a1 == a2);
System.out.println(Arrays.equals(a1, a2));
```

A. true, true

B. false, false

C. false, true

D. true, false

**✅正解：C**

**📘解説：**

- `a1 == a2` は **参照の比較** → false
- `Arrays.equals()` は **要素ごとの比較** → true

---

### 🔹【Q4】nullの扱い

次のコードを実行した結果として正しいものはどれか。

```java
int[] x = null;
int[] y = null;
System.out.println(Arrays.equals(x, y));
```

A. コンパイルエラー

B. 実行時例外

C. true

D. false

**✅正解：C**

**📘解説：** 両方が `null` の場合は `true` を返す。

---

### 🔹【Q5】多次元配列のひっかけ

以下のコードの出力として正しいものはどれか。

```java
String[][] m1 = { {"A"}, {"B"} };
String[][] m2 = { {"A"}, {"B"} };
System.out.println(Arrays.equals(m1, m2));
System.out.println(Arrays.deepEquals(m1, m2));
```

A. false, false

B. false, true

C. true, true

D. true, false

**✅正解：B**

**📘解説：**

- `Arrays.equals()` は参照を比較 → false
- `Arrays.deepEquals()` はネストされた要素も中身を比較 → true

---

### 🔹【Q6】異なる型の比較（ひっかけ）

以下のコードの実行結果として正しいものはどれか。

```java
int[] nums = {1, 2, 3};
Integer[] numsObj = {1, 2, 3};
System.out.println(Arrays.equals(nums, numsObj));
```

A. true

B. false

C. コンパイルエラー

D. 実行時例外

**✅正解：C**

**📘解説：** `int[]` と `Integer[]` は型が異なるため、**オーバーロード対象外** → **コンパイルエラー**。

---

## 🎯 試験に向けた総まとめ：出題されやすいポイント

| 出題パターン | 注意点 |
| --- | --- |
| `==` と `Arrays.equals()` の違い | `==` は参照、equals は中身 |
| 多次元配列 | `equals()` では false、`deepEquals()` を使う |
| `String[]` の比較 | `String` は `equals()` オーバーライドされてるので内容で判定 |
| `null` | 両方nullなら true、片方 null は false |
| 型の不一致 | `int[]` と `Integer[]` は混ぜられない（コンパイルエラー） |

以下に、**Java Silver 試験風の `Arrays.equals()` 応用パターン問題**をお届けします。応用とはいえ、試験で**「うっかりミス」や「思い込み」**を狙うケースを中心に構成しています。

---

## ✅ Java Silver風：`Arrays.equals()` 応用パターン問題集

---

### 🔸【Q1】シャローコピーの影響

以下のコードの出力結果として正しいものを選べ。

```java
String[] original = {"A", "B", "C"};
String[] alias = original;
alias[1] = "X";

System.out.println(Arrays.equals(original, alias));
```

A. true

B. false

C. コンパイルエラー

D. 実行時例外

**✅正解：A**

**📘解説：**

`alias` は `original` と**同じ参照**を持つ配列 → 変更は同時に反映される。

結果として **同じ配列内容** なので `equals` は `true` を返す。

---

### 🔸【Q2】toString()の誤解との対比

次のコードを実行した結果として正しいものを選びなさい。

```java
String[] arr1 = {"A", "B"};
String[] arr2 = {"A", "B"};

System.out.println(arr1.toString().equals(arr2.toString()));
System.out.println(Arrays.equals(arr1, arr2));
```

A. true, true

B. false, true

C. true, false

D. false, false

**✅正解：B**

**📘解説：**

- `toString()` はデフォルトでは `[Ljava.lang.String;@xxxx` 形式 → **参照アドレスの比較** → false
- `Arrays.equals()` は内容比較 → true

---

### 🔸【Q3】多次元配列を浅く比較した場合

以下のコードの出力結果として正しいものを選べ。

```java
String[][] data1 = { {"a", "b"}, {"c"} };
String[][] data2 = { {"a", "b"}, {"c"} };

System.out.println(Arrays.equals(data1, data2));
```

A. true

B. false

C. コンパイルエラー

D. 実行時例外

**✅正解：B**

**📘解説：**

- `Arrays.equals()` は **1次元レベルでの参照比較**
- 中の `"a"` や `"b"` が等しくても、ネストされた配列自体の参照が異なる → `false`
- **deepEquals を使えば true になる**

---

【Q4】プリミティブ型 vs ラッパークラスの混在

以下のコードの動作として正しいものはどれか。

```java
int[] a = {1, 2, 3};
Integer[] b = {1, 2, 3};

System.out.println(Arrays.equals(a, b));
```

A. true

B. false

C. コンパイルエラー

D. 実行時例外

**✅正解：C**

**📘解説：**

- `int[]` と `Integer[]` は**型が全く異なる**
- `equals(int[], int[])` と `equals(Object[], Object[])` は**オーバーロードの別物**
- 型が一致しないため、**コンパイルエラー**

---

### 🔸【Q5】null混在の比較

次のコードの出力結果として正しいものはどれか。

```java
String[] x = {"A", null, "C"};
String[] y = {"A", null, "C"};

System.out.println(Arrays.equals(x, y));
```

A. true

B. false

C. コンパイルエラー

D. 実行時例外

**✅正解：A**

**📘解説：**

- `null` の位置・数も一致し、`equals(null, null)` は `true` と扱われるため、結果は `true`

---

### 🔸【Q6】Arrays.equalsの応用 with Arrays.sort

次のコードの出力結果として正しいものを選べ。

```java
int[] a = {3, 1, 2};
int[] b = {1, 2, 3};

Arrays.sort(a);
Arrays.sort(b);

System.out.println(Arrays.equals(a, b));
```

A. true

B. false

C. コンパイルエラー

D. 実行時例外

**✅正解：A**

**📘解説：**

- 配列の内容と順序が一致すれば `Arrays.equals()` は `true` を返す
- ソート後に `[1, 2, 3]` となり一致する

---

## 🎯 応用パターンまとめ：試験で狙われる落とし穴

| 応用パターン | 注意点 |
| --- | --- |
| 同じ参照 vs 異なる参照 | 同じ参照は `true`、違う参照でも内容が同じなら `equals()` は `true` |
| 多次元配列の比較 | `Arrays.equals()` では中の配列の参照を比較 → `false` になりやすい |
| ラッパー型との混在 | `int[]` と `Integer[]` は別物 → コンパイルエラー |
| null 要素の比較 | `null` 同士は `equals()` 的には `true` |

# Q,

String[] arr1 = {"A", "B"};
String[] arr2 = {"A", "B"};

System.out.println(arr1.toString().equals(arr2.toString()));
System.out.println(Arrays.equals(arr1, arr2));

上記のコードででてくる、arr1.toString()は、Arrays.toString()と異なる認識は合っていますか？

はい、**Hiroakiさんの認識は完全に正しいです。**

---

## ✅ 結論：

> arr1.toString() と Arrays.toString(arr1) はまったく異なる動作をします。
> 

---

## 🔍 違いの詳細

### 🔸 `arr1.toString()`

- **意味：** `arr1` は `String[]`（配列）なので、`Object` クラスから継承された `toString()` を使います。
- **出力：** `[Ljava.lang.String;@xxxxxx` のような**参照情報（型＋ハッシュコード）**
- **理由：** Javaの配列クラスは `Object` の `toString()` をオーバーライドしていないため。

🧪 例：

```java
String[] arr1 = {"A", "B"};
System.out.println(arr1.toString());
// 出力例: [Ljava.lang.String;@1a2b3c4
```

---

### 🔸 `Arrays.toString(arr1)`

- **意味：** `java.util.Arrays` クラスが提供するユーティリティメソッドで、**配列の中身を文字列として整形**する。
- **出力：** `[A, B]` のように**人間にわかりやすい表示**

🧪 例：

```java
System.out.println(Arrays.toString(arr1));
// 出力: [A, B]
```

---

## 🧠 試験対策ポイント

| メソッド | 出力内容 | 使いどころ | 試験でのひっかけ |
| --- | --- | --- | --- |
| `arr.toString()` | 参照情報（[L型名@ハッシュ） | デフォルトの `Object.toString()` | 中身が表示されると**誤解しやすい** |
| `Arrays.toString(arr)` | 要素一覧 `[A, B, ...]` | デバッグ・出力・ログ | **人間向け表示**、実用的 |

---

## 🎯 まとめ

> 配列.toString() → 中身を見せない
> 
> 
> `Arrays.toString(配列)` → 中身を**正しく表示**
> 

この違いは、**Java Silverでもひっかけとして非常によく出題されます**。

特に `Object[]` や `String[]` に対して `toString()` をそのまま使ったときの出力形式の違いは要注意です。