# ビット演算まとめ

以下に Java Silver 試験や実務でも役立つ **ビット演算の基本～応用を押さえた問題パターン集（○×形式＋選択式）** をご用意しました。

対象演算子は `&`（AND）、`|`（OR）、`^`（XOR）、`~`（NOT）、`<<`（左シフト）、`>>`（算術右シフト）、`>>>`（論理右シフト）です。

---

## ✅ Java ビット演算パターン問題集（10問）

---

### ❶ 【AND演算】

```java
int x = 0b1100;
int y = 0b1010;
System.out.println(x & y);
```

Q: 出力結果は `0b1000`（= 8）である。

✅ **正解：○**

---

### ❷ 【OR演算】

```java
int x = 0b0101;
int y = 0b0011;
System.out.println(x | y);
```

Q: 出力結果は `0b0111`（= 7）である。

✅ **正解：○**

---

### ❸ 【XOR演算】

```java
int x = 0b1100;
int y = 0b1010;
System.out.println(x ^ y);
```

Q: 出力結果は `0b0110`（= 6）である。

✅ **正解：○**

---

### ❹ 【NOT演算】

```java
int x = 0b00000000_00000000_00000000_00001111;
System.out.println(~x);
```

Q: 出力結果は `-16` になる。

✅ **正解：○**

📘 `~x` は全ビット反転 → 2の補数で `-x - 1`

---

## ✅ ステップごとの解説

### 🔹 ① `x` の値を確認

```java
x = 0b00000000_00000000_00000000_00001111;
```

- = **2進数で `0000 0000 0000 0000 0000 0000 0000 1111`**
- = **10進数で `15`**

---

### 🔹 ② `~x` は「ビット反転演算」

`~` はビットごとに **0 → 1, 1 → 0** に変える演算です（**1の補数**）

```java
~ 0000 0000 0000 0000 0000 0000 0000 1111
= 1111 1111 1111 1111 1111 1111 1111 0000
```

- これは、**32ビット符号付き整数**として解釈されるため、先頭の `1` は**負の数**を意味します。

---

### 🔹 ③ ビット反転後の値を10進数に変換

```java
1111 1111 1111 1111 1111 1111 1111 0000
```

この2進数を10進数に直すには：

- **2の補数表現**（負数の表現方式）を使います。

### 手順：

1. 反転結果を **再度ビット反転**：

```java
~1111...0000 = 0000...1111 = 15
```

1. **＋1** して元の絶対値を出す：

```java
15 + 1 = 16
```

1. 負号をつけて：

```java
-16
```

---

### ❺ 【左シフト（<<）】

```java
int x = 3;
System.out.println(x << 2);
```

Q: 出力は `12`（3 × 2^2）になる。

✅ **正解：○**

---

### ❻ 【算術右シフト（>>）】

```java
int x = -8;
System.out.println(x >> 1);
```

Q: 出力は `-4` になる。

✅ **正解：○**

📘 負の数でも **符号ビットを維持**して右シフトされる

---

### ❼ 【論理右シフト（>>>）】

```java
int x = -8;
System.out.println(x >>> 1);
```

Q: 出力は `2147483644` になる（32bitでの論理右シフト）

✅ **正解：○**

📘 符号ビットも `0` で埋められる → 符号なし整数として解釈

---

### ❽ 【組み合わせ演算：マスク適用】

```java
int flags = 0b10101100;
int mask  = 0b00001111;
System.out.println(flags & mask);
```

Q: 出力結果は `0b00001100`（= 12）である。

✅ **正解：○**

---

### ❾ 【ビットフラグの追加】

```java
int flags = 0b0010;
flags |= 0b1000;
System.out.println(flags);
```

Q: 出力は `0b1010`（= 10）になる。

✅ **正解：○**

---

### 🔟 【ビットのセット判定】

```java
int flags = 0b1100;
System.out.println((flags & 0b0100) != 0);
```

Q: 第3ビット（値4）はセットされているため、出力は `true`。

✅ **正解：○**

---

## ✅ 補足：覚えておくべきビット演算表

| 演算子 | 意味 | 使用例 | 結果 |
| --- | --- | --- | --- |
| `&` | 論理積（AND） | `0b1100 & 0b1010` → `0b1000` |  |
| ` | ` | 論理和（OR） | `0b0101 |
| `^` | 排他的論理和（XOR） | `0b1100 ^ 0b1010` → `0b0110` |  |
| `~` | ビット反転（NOT） | `~0b00001111` → `0b11110000`（2の補数） |  |
| `<<` | 左シフト（*2^n） | `3 << 2` → 12 |  |
| `>>` | 算術右シフト | `-8 >> 1` → -4 |  |
| `>>>` | 論理右シフト | `-8 >>> 1` → 2147483644 |  |