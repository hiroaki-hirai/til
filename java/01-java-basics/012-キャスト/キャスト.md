# キャスト

# Q,

```java
short s1 = 10;
Integer s2 = 20;
Long s3 =(long) s1+ s2;
String s4 =(String) (s3+s2);
```

上記のs4 ではコンパイルエラーになる認識ですがあっていますか？ClassCastException にならないのはなぜですか？

はい、Hiroakiさんのご認識 **「s4 ではコンパイルエラーになる」**は正しいです。

そして、**ClassCastException にはなりません**。

理由はそれぞれ明確に整理できます。

---

## ✅ 該当コードの整理と型推論

```java
short s1 = 10;
Integer s2 = 20;
Long s3 = (long) s1 + s2;
String s4 = (String) (s3 + s2); // ← ここが問題
```

### 🔍 各行の型の確認

### 1. `short s1 = 10;`

→ `s1` の型は `short`

### 2. `Integer s2 = 20;`

→ `s2` の型は `Integer`（ラッパークラス）

### 3. `Long s3 = (long) s1 + s2;`

- `(long) s1` → プリミティブ long
- `s2` は `Integer` なので、`int` にアンボクシングされて `long` に自動拡張される
- `long + long` → 結果は `long`
- `long` → `Long` にボクシングされて `s3` に代入（OK）

✅ コンパイル OK

---

## ❌ 問題の行：`String s4 = (String) (s3 + s2);`

### 🔍 右辺の型を解析

- `s3` は `Long` → アンボクシングで `long`
- `s2` は `Integer` → アンボクシングで `int`
- `long + int` → `long`（intがlongに拡張）
- 結果：`long`（プリミティブ）

### 🔴 キャスト部分 `(String) (s3 + s2)` は

- `long` を `String` に **キャストしようとしている**
- **継承関係がまったくない**（`long` は `String` にキャストできない）

### ✅ よって：

- これは **文法レベルで不正**
- → **コンパイルエラー**になる

```java
incompatible types: possible lossy conversion from long to String
```

---

## ❓ なぜ ClassCastException にならないのか？

- `ClassCastException` は **実行時例外**であり、**コンパイルが通って初めて発生**し得るものです。
- 今回は「コンパイル時点で型が合わない」ため、**実行すらされません**。

---

## 🔚 結論まとめ

| 内容 | 結果 | 理由 |
| --- | --- | --- |
| `String s4 = (String)(s3 + s2);` | ❌ **コンパイルエラー** | `long` を `String` にキャストするのは文法上 NG |
| `ClassCastException` は発生？ | しない | 実行に至らないため、例外は発生しない |

---

### ✅ 修正版（参考）

もし `s3 + s2` の結果を `String` にしたいなら：

```java
String s4 = String.valueOf(s3 + s2); // OK
```

または：

```java
String s4 = (s3 + s2) + ""; // OK：文字列結合による自動変換
```

必要なら、このコードを Eclipse で試した場合のエラー内容も再現できますので、お申しつけください。