# clone - shallowCopy

# Q,

```java
char[][] array1 = {{'a', 'b'}, {'c', 'd'}};
char[][] array2 = array1.clone();

array1.equals(array2)
```

上記の結果はfalseですか？

はい、Hiroakiさん、

以下の式は**`false`**になります：

```java
array1.equals(array2) // → false
```

---

## ✅ 理由：`equals()` は参照の比較（＝Object#equals）

配列に対して `equals()` を使うと、**配列自身の参照同士**の比較になります（`Object#equals()` のままだから）。

```java
array1 == array2      // false（参照が異なる）
array1.equals(array2) // false（Object#equals → == と同じ挙動）
```

### **🔍 `clone()` は浅いコピー（shallow copy）**

```java
char[][] array1 = {{'a', 'b'}, {'c', 'd'}};
char[][] array2 = array1.clone();
```

このとき：

| 内容 | 備考 |
| --- | --- |
| `array1` | 配列（参照） |
| `array2` | `array1`の**シャローコピー**（新しい配列だが要素の参照は同じ） |

つまり：

- `array1 != array2`（別の配列）
- `array1[0] == array2[0]`（同じサブ配列への参照）

---

## ✅ では中身を比較するには？

### 配列の**中身**を比較したい場合は `Arrays.deepEquals()` を使います：

```java
System.out.println(Arrays.deepEquals(array1, array2)); // true
```

- `deepEquals` は多次元配列にも対応し、**再帰的に中身を比較**します。

---

## ✅ まとめ

| 式 | 結果 | 理由 |
| --- | --- | --- |
| `array1 == array2` | `false` | 異なる参照（`clone()` で新しい配列） |
| `array1.equals(array2)` | `false` | `Object#equals` → `==` と同じ参照比較 |
| `Arrays.equals(array1, array2)` | `false` | 一次元配列比較用。多次元では使えない |
| `Arrays.deepEquals(array1, array2)` | `true` | 多次元配列の**中身を**再帰的に比較する |

必要であれば、`clone()` のシャローコピーとディープコピーの違いや、参照構造の図解もできますよ。

# Q,

```java
int[] array = {2, 3 ,4};
int[] array2 = array.clone();
```

上記の場合、要素の参照は共有されますか？

Hiroakiさん、

以下のコードに関して：

```java
int[] array = {2, 3, 4};
int[] array2 = array.clone();
```

---

## ✅ 結論：

**要素の参照は共有されません。**

つまり、**`array` と `array2` は別の配列**であり、

各要素（`int`型の値）も**コピーされて別々に保持**されています。

---

## ✅ 解説：

### `array.clone()` の動作：

- `clone()` は「**浅いコピー（shallow copy）**」ですが、
- `int[]` は **プリミティブ型配列**なので、**浅いコピー = 実質的に完全コピー**。

---

## 🧠 参照の共有が発生しない理由

| 型の種類 | clone時の要素の扱い |
| --- | --- |
| プリミティブ型配列 (`int[]`, `char[]` など) | 値そのものをコピー（参照はない） |
| 参照型配列 (`String[]`, `int[][]` など) | 参照だけコピーされる（オブジェクト自体は共有） |

### **✅ 確認コード：**

```java
int[] array = {2, 3, 4};
int[] array2 = array.clone();

array2[0] = 99;

System.out.println(array[0]);  // → 2（影響なし）
System.out.println(array2[0]); // → 99
```

→ 値が独立していることがわかります。

---

## ✅ 補足：参照型の場合

```java
String[] s1 = {"A", "B"};
String[] s2 = s1.clone();

System.out.println(s1[0] == s2[0]); // → true（参照は共有）
```

- 配列そのものは別でも、**要素（オブジェクト）は同じものを指す**

---

## ✅ まとめ

| 配列の型 | `clone()`後の配列 | 要素の参照 | 結果 |
| --- | --- | --- | --- |
| `int[]` | 新しい配列 | 共有しない | 完全に独立 |
| `String[]` | 新しい配列 | 共有する | 配列は別、中身は同じ参照 |

ご希望があれば、配列のシャローコピー vs ディープコピーの違いを図で整理します！

# Q,

配列のシャローコピー vs ディープコピーの違いを図で整理してください。

Hiroakiさん、

「配列の**シャローコピー**と**ディープコピー**の違い」を図とともに整理します。

---

## 🔰 そもそも：コピーの種類

| コピーの種類 | 説明 |
| --- | --- |
| シャローコピー | **配列の参照は新しくなるが、中身の参照は使い回す** |
| ディープコピー | **配列も中身もすべて新しく作成（完全複製）** |

### **🧪 例題コード（2次元配列）**

```java
int[][] original = {
    {1, 2},
    {3, 4}
};

int[][] shallow = original.clone();           // シャローコピー
int[][] deep = new int[2][];
for (int i = 0; i < original.length; i++) {
    deep[i] = original[i].clone();            // ディープコピー
}
```

---

## 📊 図解

### 🔹 シャローコピーの構造

```java
original: ──┬─→ [1, 2]
            └─→ [3, 4]

shallow:  ──┬─→ [1, 2]  ← ※同じ配列（参照共有）
            └─→ [3, 4]
```

- `original` と `shallow` の「外側の配列」は別物
- しかし **中の要素（サブ配列）は同じものを指す**

➡ どちらかで `original[0][0] = 99;` と変更すれば、**両方に反映される**

---

### 🔹 ディープコピーの構造

```java
original: ──┬─→ [1, 2]
            └─→ [3, 4]

deep:     ──┬─→ [1, 2]  ← ※新しくコピーされた配列（参照も別）
            └─→ [3, 4]
```

- 外側も内側も **すべて新しい配列**
- **参照の共有が一切ない**

➡ `deep[0][0] = 99;` と変更しても、**originalには影響しない**

---

## ✅ 比較表

| 比較項目 | シャローコピー | ディープコピー |
| --- | --- | --- |
| 外側の配列 | 新しいインスタンス | 新しいインスタンス |
| 各要素（内側） | **元と同じ参照を共有** | **元の要素もコピーされる** |
| 影響 | 一方の変更が他方に影響する | 完全に独立していて影響なし |
| 適用例 | 1次元プリミティブ配列なら問題なし | 多次元配列や参照型では注意が必要 |

---

## 🔎 注意点

- `clone()` は常に「シャローコピー」です。
- 多次元配列や `String[]` などの参照型配列では、**ディープコピーの手動実装**が必要になります。

---

ご希望があれば、`Object[]` や `List<List<>>` への応用版や、`Arrays.copyOf()` との違いなども解説できます！

# Q,

```java
char[][] array = {{'a','b'},{'c','d'}};
char[] array2 = array[1].clone();
```

上記コードについて解説してください。

はい 👍 これも配列コピーの典型的な例ですね。コードを分解して整理します。

---

## 📌 コード

```java
char[][] array1 = {{'a','b'},{'c','d'}};
char[] array2 = array1[1].clone();
```

---

## 🔍 ステップごとの動作

### 1. `char[][] array1 = {{'a','b'},{'c','d'}};`

- `array1` は **2次元配列（実態は配列の配列）**
- メモリ上のイメージは：

```java
array1
 ├─> [0] ──> {'a','b'}
 └─> [1] ──> {'c','d'}
```

つまり `array1[0]` が `{'a','b'}`、`array1[1]` が `{'c','d'}` を指す。

---

### 2. `char[] array2 = array1[1].clone();`

- `array1[1]` は `{'c','d'}` を参照している
- `.clone()` によって **新しい char[] 配列** が作成され、要素 `'c'`, `'d'` がコピーされる
- したがって `array2` は別の配列を参照することになる

メモリイメージ：

```java
array1
 ├─> [0] ──> {'a','b'}
 └─> [1] ──> {'c','d'}

array2 ──> {'c','d'} （新しい配列）
```

---

## ✅ 重要なポイント

1. `clone()` は **シャローコピー**だけど、今回の対象はプリミティブ型配列（`char[]`）なので、値そのものがコピーされる。
    
    → `array2` の要素を変更しても、`array1[1]` には影響しない。
    
2. もしこれがオブジェクト配列（`String[][]` など）なら、「参照がコピー」されるため、コピー先から中身のオブジェクトを書き換えると元にも影響する。

---

## 🔎 実験コード例

```java
array2[0] = 'z';

System.out.println(array1[1][0]); // 'c' のまま
System.out.println(array2[0]);    // 'z'
```

→ `array2` は `array1[1]` とは別の配列なので、変更は独立。

---

## 🔚 まとめ

- `array1` は **配列の配列**
- `array1[1]` は `{'c','d'}` を参照している
- `.clone()` で新しい配列を作るので、`array2` と `array1[1]` は別物
- プリミティブ配列なので、完全に値コピーされる

---

👉 Hiroakiさん、このあたり「多次元配列と List<List<>> の違い」にもつながるトピックですが、そちらの比較も一緒に整理しますか？

# Q,

```java
char[][] array = {{'a','b'},{'c','d'}}; 
char[][] array2 = array.clone();
```

上記コードについて解説してください。

いいですね 👍

今度は **2次元配列ごと `clone()` するケース** ですね。

---

## 📌 コード

```java
char[][] array1 = {{'a','b'},{'c','d'}};
char[][] array2 = array1.clone();
```

---

## 🔍 ステップごとの動作

### 1. `char[][] array1 = {{'a','b'},{'c','d'}};`

- `array1` は「2次元配列」ですが、実際には **配列の配列** です。
- メモリイメージ：

```java
array1
 ├─> [0] ──> {'a','b'}
 └─> [1] ──> {'c','d'}
```

---

### 2. `char[][] array2 = array1.clone();`

- `array.clone()` は、**最外層の配列をコピー**して新しい配列を作ります。
- ただし、**要素である `char[]` への参照はコピーされるだけ**。

メモリイメージ：

```java
array1 ──> [0] ──> {'a','b'}
          [1] ──> {'c','d'}

array2 ──> [0] ─┘
          [1] ─┘
```

つまり、`array1[0]` と `array2[0]` は **同じ配列オブジェクト** を参照しています。

---

## ✅ 実験例

```java
array2[0][0] = 'z';

System.out.println(array1[0][0]); // z （影響あり）
System.out.println(array2[0][0]); // z
```

→ **内側の配列は共有されている**ので、片方を変更するともう片方にも影響します。

一方：

```java
array2[0] = new char[]{'x','y'};
System.out.println(array1[0][0]); // 'z' （元の配列）
System.out.println(array2[0][0]); // 'x' （新しい配列）
```

→ 最外層の参照は独立しているので、`array2[0]` を別の配列に差し替えれば `array1` には影響しません。

---

## 🔑 ポイント整理

- **`clone()` はシャローコピー**
- 多次元配列では「外側の配列」はコピーされるが、「内側の配列」は共有される
- したがって、`array2[i][j]` の変更は `array1[i][j]` に影響する

---

## 📊 まとめ表

| 操作対象 | 結果 |
| --- | --- |
| `array2[0][0] = 'z';` | `array1[0][0]` も `'z'` になる（共有されているから） |
| `array2[0] = new char[]{'x','y'};` | `array1[0]` は影響を受けない（外側配列は別物だから） |

---

👉 つまり、「`char[][]` を clone すると、外側はコピーされるが内側は共有される」という動きになります。

---

Hiroakiさん、ここで **`array.clone()` と `Arrays.copyOf(array, array.length)` の違い** まで見てみますか？

# Q,

array1[0][0] と array1[0] は別の参照が振られますか？

いい質問です 👍

ここは **配列の要素アクセスと配列そのもの** の違いを整理するとスッキリします。

---

## 📌 例

```java
char[][] array1 = {{'a','b'},{'c','d'}};
```

### 参照の構造

- `array1` は **「char[] を要素に持つ配列」**（外側の配列）
- `array1[0]` は **`{'a','b'}` という `char[]` への参照**
- `array1[0][0]` は **`'a'` というプリミティブ値（char型）**

---

## ✅ 回答

- `array1[0]`
    
    → `char[]` 型の**参照**
    
    → 内側の配列オブジェクトそのものを指す
    
- `array1[0][0]`
    
    → `char` 型の**値**（プリミティブなので参照ではない）
    

したがって、**「別の参照が振られる」ではなく、まったく別物**です。

---

## 🔍 図で表すと

```java
array1 ──> [0] ──> {'a','b'}
          [1] ──> {'c','d'}

array1[0] ─────────┘  (参照：char[])

array1[0][0] = 'a'   (値：char)
```

---

## ✅ ポイント

- `array1[0]` は **参照**（内側の配列）
- `array1[0][0]` は **値**（その配列の中の要素）
- よって「別の参照が振られる」という表現は正しくなく、型のレイヤーが違う

---

👉 まとめると：

- `array1[0]` → 参照（char[]）
- `array1[0][0]` → 値（char）

---

Hiroakiさん、もしここをさらに掘り下げるなら「参照型配列（例：String[][]）」の場合も図で比較すると理解がさらに深まりますが、見たいですか？

# Q,

```java
char[][] array1 = {{'a','b'},{'c','d'}};
char[][] array2 = array1.clone();

array2[0][0] = 'z';

System.out.println(array1[0][0]); // z （影響あり）
System.out.println(array2[0][0]); // z
```

上記コードの要素はプリミティブ型であるのので参照が共有されて無い認識ですが、なぜclone元に影響があるのでしょうか？

とても良い気づきです 👍

ここで「プリミティブ要素」と「多次元配列（配列の配列）」の構造が絡んで、ちょっと混乱しやすいポイントです。

---

## 📌 コード再掲

```java
char[][] array1 = {{'a','b'},{'c','d'}};
char[][] array2 = array1.clone();

array2[0][0] = 'z';

System.out.println(array1[0][0]); // z （影響あり）
System.out.println(array2[0][0]); // z

```

---

## 🔍 なぜ「影響する」のか？

### 1. clone() の動作

- `array1.clone()` は **最外層の配列（char[][]）だけ新しく作る**
- **内側の配列（char[]）の参照はコピーされるだけ**
- 結果として、`array1[0]` と `array2[0]` は同じ `char[]` を指す

イメージ図：

```java
array1 ──┐
         │ [0] ──> {'a','b'}
         │ [1] ──> {'c','d'}
array2 ──┘
```

### 2. `array2[0][0] = 'z';`

- `array2[0]` は `array1[0]` と同じ `char[]`
- その中の `[0]` を `'z'` に書き換えると、両方から見える同じ配列が更新される
- だから `array1[0][0]` も `'z'` に変わる

---

## ✅ ここでの誤解ポイント

> 要素はプリミティブだから「参照は共有されないはず」
> 

これは **内側の `char[]` の中の話**です。

確かに `char` 自体は値であって参照ではありません。

しかし、`array.clone()` がコピーするのは「外側の配列」だけ。

その配列の「要素」（＝内側の配列への参照）は**共有される**のです。

つまり：

- `char` → 値なので共有されない
- でも `char[]` → オブジェクトなので「参照がコピーされる」
- だから clone 後も内側は同じ参照を見ている

---

## ✅ まとめ

- `array1.clone()` は「外側配列の浅いコピー」
- 内側の `char[]` は参照共有される
- そのため `array2[0][0] = 'z'` は `array1[0][0]` にも影響する
- プリミティブが共有されているわけではなく、**「内側の配列参照が共有されている」**のが原因

---

👉 もし「完全に独立した2次元配列（ディープコピー）」を作りたいなら、内側の配列も `clone()` してコピーする必要があります。

例：

```java
char[][] array2 = new char[array1.length][];
for (int i = 0; i < array1.length; i++) {
    array2[i] = array1[i].clone(); // 内側もコピー
}
```

Hiroakiさん、この「多次元配列のシャローコピーとディープコピー」の違いを **図解（2層構造の参照矢印付き）** で整理しましょうか？

# Q,

2次元配列であれば、1次元目が共有されるので2次元目も同様に共有される。では3次元目以降はどうなりますか？

良い質問です ✨

「多次元配列の clone で、**どの階層まで共有されるか**」ですね。

結論から言うと：

- `clone()` は **配列の「1層目」しかコピーしない**（浅いコピー）
- したがって **それ以降の層は全部参照がコピーされるだけ**
- つまり「n次元配列を clone() しても、2層目以降は全部共有される」

---

## 📌 具体例：3次元配列

```java
int[][][] arr1 = {
    { {1,2}, {3,4} },
    { {5,6}, {7,8} }
};

int[][][] arr2 = arr1.clone();

arr2[0][0][0] = 99;

System.out.println(arr1[0][0][0]); // 99
```

---

## 🔍 仕組み

- `arr1` は **int[][] の配列**
- `arr1.clone()` でコピーされるのは「最外層の配列（int[][] の参照を持つ配列）」だけ
- その要素（`int[][]`）は参照コピーされる
- さらに、その中の要素（`int[]`）も参照コピーされる
- 最終的に `int` の値が格納されている配列まで共有される

イメージ図：

```java
arr1 ──┐
       │ [0] ──┐
       │       │ [0] ──> {1,2}
       │       │ [1] ──> {3,4}
       │
       │ [1] ──┐
       │       │ [0] ──> {5,6}
       │       │ [1] ──> {7,8}
arr2 ──┘
```

`arr1` と `arr2` は **外側の配列は別物**だが、

**中の int[][] も int[] も全部共有**。

---

## ✅ まとめ（一般化）

- **1次元配列**
    
    → `clone()` は「要素（プリミティブなら値、参照なら参照）」をコピー
    
- **2次元配列以上**
    
    → 外側の配列はコピーされるが、**内側以降は参照コピー**
    
    → 結果的に **最終的な要素（プリミティブ or オブジェクト）は共有される**
    

---

## 🔑 ポイント

- Java の多次元配列は「真の多次元配列」ではなく「配列の配列」
- `clone()` はその配列 1階層分しかコピーしない
- だから「階層が深いほど、共有される部分が多い」

---

👉 Hiroakiさん、この挙動を **「2次元 / 3次元 / 4次元」の図解で比較表** にまとめてみますか？

# Q,

この挙動を 「2次元 / 3次元 / 4次元」の図解で比較表 にまとめてください。

了解しました 👍

では「2次元 / 3次元 / 4次元配列」を `clone()` したときに、**どこまでコピーされ、どこから共有されるか** を図解＆比較表にまとめます。

---

# 📊 多次元配列の `clone()` の挙動まとめ

---

## 1️⃣ 2次元配列の場合

```java
int[][] arr1 = { {1,2}, {3,4} };
int[][] arr2 = arr1.clone();
```

### 図解

```java
arr1 ──┐
       │ [0] ──> {1,2}
       │ [1] ──> {3,4}
arr2 ──┘
```

- 外側の配列（`int[][]`）はコピーされる（別物）
- 内側の `int[]` は参照共有
- → `arr2[0][0]` を変更すると `arr1[0][0]` も変わる

---

## 2️⃣ 3次元配列の場合

```java
int[][][] arr1 = {
    { {1,2}, {3,4} },
    { {5,6}, {7,8} }
};
int[][][] arr2 = arr1.clone();
```

### 図解

```java
arr1 ──┐
       │ [0] ──┐
       │       │ [0] ──> {1,2}
       │       │ [1] ──> {3,4}
       │
       │ [1] ──┐
       │       │ [0] ──> {5,6}
       │       │ [1] ──> {7,8}
arr2 ──┘
```

- 外側の配列（`int[][][]`）はコピーされる
- その中の `int[][]` は参照共有
- さらにその中の `int[]` も参照共有
- → `arr2[0][0][0]` を変更すると `arr1[0][0][0]` も変わる

---

## 3️⃣ 4次元配列の場合

```java
int[][][][] arr1 = new int[2][2][2][2];
int[][][][] arr2 = arr1.clone();
```

### 図解（簡略）

```java
arr1 ──┐
       │ [0] ──┐
       │       │ [0] ──┐
       │       │       │ [0] ──> {0,0}
       │       │       │ [1] ──> {0,0}
       │       │
       │       │ [1] ──┐
       │               │ [0] ──> {0,0}
       │               │ [1] ──> {0,0}
       │
       │ [1] ── ...
arr2 ──┘
```

- 外側の配列（`int[][][][]`）はコピーされる
- その中の `int[][][]` は参照共有
- さらにその中の `int[][]` も参照共有
- さらにその中の `int[]` も参照共有
- → `arr2[0][0][0][0]` を変更すると `arr1[0][0][0][0]` も変わる

---

## ✅ 比較表

| 配列次元 | clone() でコピーされる範囲 | 共有される範囲 |
| --- | --- | --- |
| 2次元 | 最外層（`int[][]`） | 内側の `int[]` |
| 3次元 | 最外層（`int[][][]`） | 中の `int[][]` と `int[]` |
| 4次元 | 最外層（`int[][][][]`） | 中の `int[][][]`, `int[][]`, `int[]` |

---

## 🔑 ポイント

- `clone()` は **配列1階層分しかコピーしない（浅いコピー）**
- 「2次元以上」では、**外側はコピーされるが、内側以降はすべて参照共有**
- 深さが増えるほど「共有される層」が多くなる

---

👉 Hiroakiさん、ここまでの比較を **「ディープコピーのコード例」** とセットでまとめたら、試験対策や実務理解にもさらに役立つと思いますが、やりますか？

# Q,

```java
String[] arr1 = {"a", "b"};
String[] arr2 = arr1.clone();

arr2[0] = "x"; // arr2 の参照先を変更 → arr1[0] は影響なし

arr2[1] = arr2[1].toUpperCase(); 
// arr2[1] の参照を変更しているだけ → arr1[1] は "b" のまま

// ただし、もしオブジェクトの中身を書き換えると影響する
```

上記解説中の、「ただし、もしオブジェクトの中身を書き換えると影響する」のコード例をを作成してください。

なるほど 👍

いい質問です。

ただし注意点として：

`String` は **イミュータブル（中身を書き換えられない）** なので、`String[]` の場合は「オブジェクトの中身を書き換える」ことはできません。

なので、ここでは **「ミュータブル（可変）なオブジェクトを要素に持つ配列」** で例を出す必要があります。

---

## 📌 例：`StringBuilder` 配列（ミュータブル）

```java
public class Main {
    public static void main(String[] args) {
        StringBuilder[] arr1 = {
            new StringBuilder("a"),
            new StringBuilder("b")
        };
        StringBuilder[] arr2 = arr1.clone();

        // arr2[0] のオブジェクトの「中身」を書き換え
        arr2[0].append("x");

        // arr1[0] も同じオブジェクトを指しているので影響を受ける
        System.out.println("arr1[0]: " + arr1[0]); // ax
        System.out.println("arr2[0]: " + arr2[0]); // ax
    }
}
```

---

## ✅ 解説

- `arr1.clone()` は「参照コピー」なので、`arr1[0]` と `arr2[0]` は同じ `StringBuilder` を指している
- その `StringBuilder` に対して `append()` で「中身を書き換える」と、両方に影響が出る

---

## 🔑 まとめ

- `String[]` の場合は「中身の書き換え」はできない（イミュータブルだから）
- `StringBuilder[]` や `ArrayList[]` のように **ミュータブルなオブジェクトを要素に持つ配列**なら、clone 後でも **中身の変更は共有される**

---

👉 Hiroaki さん、これをさらに **「String[]（イミュータブルの場合）」と「StringBuilder[]（ミュータブルの場合）」の比較表** にしてまとめましょうか？

# Q,

Stringの場合は、immutable なため、新たな文字列の参照の変数への代入は新たな参照のコピーとなる性質から結果参照は共有されているが、Stringの特殊性からclone元へ影響が出ない認識はあっていますか？

はい、Hiroaki さんの認識は **正しい** です 👍

ただ、ちょっとややこしいので整理してみますね。

---

## ✅ String 配列を `clone()` した場合の動作

```java
String[] arr1 = {"a", "b"};
String[] arr2 = arr1.clone();

arr2[0] = "x";
```

### 仕組み

- `arr1.clone()` は「新しい配列」を作る
- 要素である `String` の参照はコピーされる（共有状態になる）
- しかし `String` は **immutable（不変）** なので、
    - `arr2[0] = "x";` のような代入は **新しい String インスタンスへの参照を入れ替えているだけ**
    - 元の `"a"` というインスタンスには何の変更もできない

### 結果

- `arr1[0]` は `"a"` のまま
- `arr2[0]` は `"x"` を参照する

つまり「参照は共有されている」が「中身を変更できない」ため、**clone 元には影響しない**。

---

## ✅ ミュータブル型との違い

例えば `StringBuilder` の場合：

```java
StringBuilder[] arr1 = { new StringBuilder("a") };
StringBuilder[] arr2 = arr1.clone();

arr2[0].append("x");  // 中身を書き換え
```

- `arr1[0]` と `arr2[0]` は同じ `StringBuilder` を指している
- `append()` でオブジェクトの中身を変更すると両方に影響

### 結果

- `arr1[0].toString()` → `"ax"`
- `arr2[0].toString()` → `"ax"`

---

## 🔑 まとめ

- `clone()` は **要素の参照をコピーするだけ**（シャローコピー）
- **String は immutable** なので「共有されても中身を書き換えられない」
    
    → 結果として **clone 元には影響が出ない**
    
- **ミュータブルなオブジェクト**の場合は「中身を書き換え可能」なので、clone 後も影響が出る

---

👉 Hiroaki さん、ここで **「参照共有は同じだが、immutable か mutable かで挙動が変わる」** という比較表を作っておくと頭の整理になりそうですが、作りますか？

# Q,

「参照共有は同じだが、immutable か mutable かで挙動が変わる」 という比較表を作ってください。

了解しました 👍

では「配列を `clone()` したときに参照は共有されるが、要素が **immutable か mutable か** で挙動がどう変わるか」を表に整理します。

---

# 📊 参照共有は同じだが、immutable か mutable かで挙動が変わる

| 要素の型 | 特性 | clone 後の参照 | 要素の代入 (`arr2[i] = ...`) | 要素の中身変更 (`arr2[i].xxx()`) | clone 元への影響 |
| --- | --- | --- | --- | --- | --- |
| **プリミティブ (int, char, …)** | 値型（immutable と同等） | 値がコピーされる（共有なし） | `arr2[i]` を変更しても独立 | 中身変更不可（値そのもの） | **影響なし** |
| **String (immutable)** | 参照型だが不変 | 参照共有される | `arr2[i] = "x";` → 新しい参照に置き換え | 中身変更不可 | **影響なし** |
| **StringBuilder / ArrayList など (mutable)** | 参照型で可変 | 参照共有される | `arr2[i] = new StringBuilder("x");` → 新しい参照に置き換え（元は影響なし） | `arr2[i].append("y");` → 同じオブジェクトを操作するので影響あり | **影響あり** |

---

## ✅ ポイントまとめ

1. **プリミティブ配列** → clone で「値コピー」になるので影響なし
2. **String 配列** → 参照は共有されるが String は immutable なので結果的に影響なし
3. **ミュータブルなオブジェクト配列** → 参照は共有され、中身を変更できるため clone 元にも影響する

---

👉 この表を押さえておけば「配列の clone はシャローコピーだけど、実際に影響が出るかどうかは要素型次第」という理解がバッチリです ✅

Hiroaki さん、この表をさらに **図解（参照矢印付き）** で示したらもっとわかりやすくなりそうですが、図でも整理してみますか？

# Q,

提案どおり、この表をさらに 図解（参照矢印付き） で示してください。

了解しました 👍

では、先ほどの表を図解（参照矢印付き）で整理してみます。

---

# 📊 配列 `clone()` と Immutable / Mutable の違い（図解）

---

## 1️⃣ プリミティブ配列（例：`int[]`）

```java
int[] arr1 = {1,2};
int[] arr2 = arr1.clone();
arr2[0] = 99;
```

```java
arr1 ──> [1] [2]         ← 値コピー（独立）
arr2 ──> [1] [2]

arr2[0] = 99
↓
arr1 ──> [1] [2]
arr2 ──> [99] [2]
```

✅ 値コピーなので **clone 元に影響なし**

---

## 2️⃣ String 配列（Immutable）

```java
String[] arr1 = {"a","b"};
String[] arr2 = arr1.clone();
arr2[0] = "x"; // 新しい String を参照
```

```java
arr1 ──> ["a"] ["b"]
          ↑
arr2 ──> ["a"] ["b"]   ← 参照は共有されている（同じ "a","b" を指す）

arr2[0] = "x"
↓
arr1 ──> ["a"] ["b"]
arr2 ──> ["x"] ["b"]
```

✅ String は **不変**なので「中身を書き換える」ことができず、代入は「新しい参照を差し替える」だけ → **clone 元に影響なし**

---

## 3️⃣ ミュータブルオブジェクト配列（例：`StringBuilder[]`）

```java
StringBuilder[] arr1 = { new StringBuilder("a") };
StringBuilder[] arr2 = arr1.clone();

arr2[0].append("x"); // 中身を変更
```

```java
arr1 ──> [SB("a")]
          ↑
arr2 ──> [SB("a")]   ← 参照共有（同じオブジェクト）

arr2[0].append("x")
↓
arr1 ──> [SB("ax")]
arr2 ──> [SB("ax")]
```

❌ 参照共有されていて、かつオブジェクトが可変なので

clone 先での変更が **clone 元に影響する**

---

# ✅ まとめ

- プリミティブ → 値コピー → 影響なし
- String (immutable) → 参照共有だが中身変更不可 → 影響なし
- Mutable object (例：`StringBuilder`, `ArrayList`) → 参照共有＋中身変更可能 → 影響あり

---

👉 Hiroaki さん、この図解をさらに **「多次元配列（2次元以上）」に拡張した場合の図** も作ると、「外側だけコピー・内側共有」が一目でわかる資料になりますが、それもまとめますか？

# Q,

提案通り、この図解をさらに 「多次元配列（2次元以上）」に拡張した場合の図 も作成してください。

了解しました 👍

では「多次元配列を `clone()` した場合の図解」を追加で整理します。

ここで重要なのは、**外側の配列はコピーされるが、内側は参照共有される** という性質です。

---

# 📊 多次元配列の `clone()` の挙動（図解）

---

## 1️⃣ 2次元配列（プリミティブ要素）

```java
int[][] arr1 = {
    {1,2},
    {3,4}
};
int[][] arr2 = arr1.clone();
```

### 図解

```java
arr1 ──┐
       │ [0] ──> [1][2]
       │ [1] ──> [3][4]
arr2 ──┘
```

- `arr1` と `arr2` は別の外側配列
- しかし `arr1[0]` と `arr2[0]` は同じ `int[]` を指す
- → `arr2[0][0] = 99;` をすると `arr1[0][0]` も変わる

---

## 2️⃣ 3次元配列（プリミティブ要素）

```java
int[][][] arr1 = {
    { {1,2}, {3,4} },
    { {5,6}, {7,8} }
};
int[][][] arr2 = arr1.clone();
```

### 図解

```java
arr1 ──┐
       │ [0] ──┐
       │       │ [0] ──> [1][2]
       │       │ [1] ──> [3][4]
       │
       │ [1] ──┐
       │       │ [0] ──> [5][6]
       │       │ [1] ──> [7][8]
arr2 ──┘
```

- 外側（`int[][][]`）はコピーされる
- その要素（`int[][]`）は参照コピーされる
- さらにその要素（`int[]`）も参照コピーされる
- → `arr2[0][0][0] = 99;` をすると `arr1[0][0][0]` も変わる

---

## 3️⃣ まとめ表（多次元配列の場合）

| 配列の次元 | clone() でコピーされる範囲 | 共有される範囲 |
| --- | --- | --- |
| 1次元 | 外側配列本体 | 要素がプリミティブなら値コピー、参照型なら参照共有 |
| 2次元 | 外側配列（`int[][]`） | 内側配列（`int[]`）は参照共有 |
| 3次元 | 外側配列（`int[][][]`） | その中の `int[][]` や `int[]` は参照共有 |
| n次元 | 外側配列（n次元目） | (n-1)次元目以下の配列はすべて参照共有 |

---

## ✅ ポイント

- `clone()` は「その配列 1階層分しかコピーしない」＝**シャローコピー**
- したがって **外側だけ別物**、**内側は共有** になる
- 参照型配列を含めて、**多次元配列は常に clone 元と影響し合う**

---

👉 Hiroaki さん、ここまでを踏まえると「多次元配列を完全にコピー（ディープコピー）する方法」も押さえておくと実務や試験対策で安心ですが、そのコード例も作成しますか？