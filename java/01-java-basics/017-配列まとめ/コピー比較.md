# コピー比較

# Q,

提案通り、これを 「浅いコピー / ディープコピーの比較表（コード付き）」 に整理してください。

了解です！「浅いコピー vs ディープコピー」をケース別に一枚で掴めるよう、比較表＋最小コードでまとめました。

# 浅いコピー / ディープコピーの比較表（コード付き）

| ケース | 浅いコピー（手段） | 変更の影響 | ディープコピー（手段） | サンプルコード |
| --- | --- | --- | --- | --- |
| **1次元 × プリミティブ** `int[]` | `clone()` / `Arrays.copyOf` | **影響なし**（値コピー） | ※浅いコピーで十分（= 実質ディープ） | `int[] a = {1,2};
int[] b = a.clone();
b[0]=9; 
// aは不変` |
| **1次元 × 参照型** `String[]`（immutable） | `clone()` / `Arrays.copyOf` | **影響なし**（参照共有だが中身不変） | ※浅いコピーで十分（= 実質ディープ） | `String[] a = {"a","b"};
String[] b = a.clone();
b[0]="x";
// a[0]は"a"のまま` |
| **1次元 × 参照型** `StringBuilder[]`（mutable） | `clone()` / `Arrays.copyOf` | **影響あり**（同一オブジェクトの中身変更が伝播） | **要素ごとに新規生成 or 要素clone** | `StringBuilder[] a = {new StringBuilder("a")};
StringBuilder[] b = a.clone();
b[0].append("x"); // a[0]も"ax"
// ディープ
StringBuilder[] d = new StringBuilder[a.length];
for(int i=0;i<a.length;i++) 
d[i] = new StringBuilder(a[i].toString());` |
| **2次元 × プリミティブ** `int[][]` | `a.clone()`（外側のみ新規） | **影響あり**（内側配列参照を共有） | **外側＋内側をコピー** | `java\nint[][] a={{1,2},{3,4}};\nint[][] s=a.clone();\ns[0][0]=9; // a[0][0]も9\n\n// ディープ\nint[][] d=new int[a.length][];\nfor(int i=0;i<a.length;i++) d[i]=a[i].clone();\n` |
| **2次元 × 参照型** `List<?>[][]` 等 | `a.clone()` | **影響あり**（内側参照共有） | **階層ごとに新規/clone** | `java\nList<String>[][] a=...;\nList<String>[][] d=new List[a.length][];\nfor(int i=0;i<a.length;i++){\n  d[i]=new List[a[i].length];\n  for(int j=0;j<a[i].length;j++)\n    d[i][j]=new ArrayList<>(a[i][j]);\n}\n` |
| **3次元以上** `int[][][]` など | `a.clone()`（最外層のみ） | **影響あり**（2層目以降すべて共有） | **すべての層をコピー** | `java\nint[][][] a={ {{1,2},{3,4}}, {{5,6},{7,8}} };\nint[][][] d=new int[a.length][][];\nfor(int i=0;i<a.length;i++){\n  d[i]=new int[a[i].length][];\n  for(int j=0;j<a[i].length;j++)\n    d[i][j]=a[i][j].clone();\n}\n` |

## 補足Tips

- `clone()` は **配列1階層分だけ**コピー（シャロー）。多次元は内側参照を共有します。
- 参照型要素の**ディープコピー**は「要素自身の clone（深さ保証が必要）」か「新規生成＋状態コピー」で行います。
- Java 8 以降なら 2次元の簡潔版も可：

```java
int[][] d = Arrays.stream(a).map(int[]::clone).toArray(int[][]::new);
```

必要なら、あなたの実データ型に合わせた“安全なディープコピー関数”も作ります。どの型で使いますか？

# Q,

2次元以上の配列の場合は、最上位配列以降は参照が共有されますが、要素がString型のようなimmutable であればclone元に影響は無い認識はあっていますか？

はい、その認識は正しいです 👍

---

## ✅ 整理して説明します

### 例：2次元配列（要素が `String` 型）

```java
String[][] arr1 = {
    {"a", "b"},
    {"c", "d"}
};

String[][] arr2 = arr1.clone();

arr2[0][0] = "x";
```

### clone の仕組み

- `arr1.clone()` → **外側の配列**だけ新しく作られる
- 内側の配列（`String[]`）は参照コピー → 共有される

つまり：

```java
arr1 ──┐
       │ [0] ──> ["a","b"]
       │ [1] ──> ["c","d"]
arr2 ──┘
```

### 代入の結果

- `arr2[0][0] = "x";`
    
    → `"a"` という `String` を変更しているのではなく、**参照を `"x"` に付け替えただけ**
    
- `arr1[0][0]` は `"a"` のまま
- ✅ **clone 元に影響なし**

---

## 🔑 ポイント

- **参照は共有される**（多次元配列では必ず外側以降は共有）
- しかし **要素が String（immutable）** の場合、
    - 「中身を書き換える」ことができない
    - できるのは「別の参照を代入する」だけ
- そのため **clone 元には影響が及ばない**

---

## ❌ 影響が出るケース（mutable 要素）

```java
StringBuilder[][] arr1 = {
    { new StringBuilder("a"), new StringBuilder("b") }
};
StringBuilder[][] arr2 = arr1.clone();

arr2[0][0].append("x");

System.out.println(arr1[0][0]); // ax （影響あり）
System.out.println(arr2[0][0]); // ax
```

- `StringBuilder` は可変なので、**共有された参照を通じて中身を変更できる**
- → clone 元にも影響が出る

---

## ✅ 結論

> 2次元以上の配列でも、内側が String のような immutable 型なら、clone 元に影響は出ない
> 

---

👉 Hiroaki さん、ここまで理解を踏まえて

**「配列次元 × 要素のmutable/immutable」で影響の有無を整理した早見表** を作りましょうか？

# Q,

提案通り、「配列次元 × 要素のmutable/immutable」で影響の有無を整理した早見表 を作成してください

了解しました 👍

「配列の次元」と「要素が immutable か mutable か」で、**clone 後の変更が clone 元に影響するかどうか**をまとめた早見表を作成します。

---

# 📊 配列次元 × 要素の mutable / immutable 早見表

| 配列の次元 | 要素の型 | clone の仕組み | clone 後の変更 | clone 元への影響 |
| --- | --- | --- | --- | --- |
| **1次元** | **プリミティブ** (int, char, …) | 値コピー（参照共有なし） | 値を変更 | ❌ 影響なし |
| **1次元** | **Immutable** (String, LocalDate, …) | 参照コピー（共有） | 代入は参照の付け替えのみ → 元は不変 | ❌ 影響なし |
| **1次元** | **Mutable** (StringBuilder, ArrayList, …) | 参照コピー（共有） | 中身を変更 | ✅ 影響あり |
| **2次元以上** | **プリミティブ配列** (int[][], …) | 外側だけコピー、内側配列は参照共有 | 値を変更 | ✅ 影響あり |
| **2次元以上** | **Immutable** 要素 (String[][], …) | 外側だけコピー、内側配列は参照共有 | 代入は参照の付け替えのみ → 元は不変 | ❌ 影響なし |
| **2次元以上** | **Mutable** 要素 (StringBuilder[][], …) | 外側だけコピー、内側配列は参照共有 | 中身を変更 | ✅ 影響あり |

---

## ✅ ポイントまとめ

- `clone()` は **常にシャローコピー**（その配列 1階層分だけコピー）。
- **プリミティブ要素**は「値コピー」なので影響なし。
- **Immutable 要素**は「参照は共有されるが中身変更不可」なので影響なし。
- **Mutable 要素**は「参照共有 ＋ 中身変更可能」なので影響あり。
- 多次元配列では、**外側だけコピー／内側以降は参照共有**になるので、mutable 要素だと必ず影響が出る。

---

👉 この表に **図解（参照矢印付き）** をプラスすれば、さらに一目で理解しやすくなると思いますが、Hiroaki さんご希望ですか？