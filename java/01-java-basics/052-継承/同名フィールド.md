# 同名フィールド

# Q,

```java
public class A {
    String val = "A";

    void print() {
        System.out.println(val);
    }
}

public class B extends A {
    String val = "B";
}

public class Main {

    public static void main(String[] args) {
        
        A a = new A();
        A b = new B();
        System.out.print(a.val);
        System.out.print(b.val);
        a.print();
        b.print();
    }
}
```

上記コードをeqlipseにて実行すると出力結果は、AAAAとなりました。

Hiroakiさん、再度の確認ありがとうございます。

そして、**Eclipseでの出力結果が `AAAA` だった**とのこと、それは**Javaのフィールドアクセスの仕組みを正しく反映した挙動です**。

あなたの観察と報告は**完全に正しいです**。

---

## ✅ 改めて整理します：なぜ `AAAA` になるのか？

### 📌 あなたのコード（再掲）：

```java
public class A {
    String val = "A";

    void print() {
        System.out.println(val);
    }
}

public class B extends A {
    String val = "B";
}

public class Main {
    public static void main(String[] args) {
        A a = new A();
        A b = new B();

        System.out.print(a.val); // ?
        System.out.print(b.val); // ?
        a.print();               // ?
        b.print();               // ?
    }
}
```

---

## ✅ 出力内容（Eclipseで確認した結果）：`AAAA`

```java
System.out.print(a.val); // "A"
System.out.print(b.val); // "A" ← 型がAなのでAのvalを参照（フィールドはオーバーライドされない）
a.print();               // "A" ← this.val は A.val
b.print();               // "A" ← A.print() が継承されていて、this.val は **A.val**
```

---

## 🔍 なぜ b.print() でも `"B"` にならなかったのか？

ここが**重要な学びポイント**です。

### 🔸 クラスBには `print()` メソッドをオーバーライドしていません：

```java
// B.print() が定義されていない → A.print() をそのまま使っている
void print() {
    System.out.println(val); // ← this.val → Aのval
}
```

ここでの `val` は **`this.val`** であり、Javaは **「メソッドの中で使うフィールドも宣言クラスにバインドされる」**という仕様を持っています。

> Javaでは、フィールドは動的バインディングされず、 参照型（A）やメソッド定義のクラスに静的に結びつけられます。
> 

---

## ✅ 比較：`メソッド`と`フィールド`のディスパッチの違い

| 項目 | メソッド | フィールド |
| --- | --- | --- |
| バインディング方式 | **動的（実行時）** | **静的（コンパイル時）** |
| オーバーライド可能？ | ✅ はい | ❌ できない（**シャドウイング**扱い） |
| `this.val` の参照元 | 定義されたクラスに基づく | 定義されたクラスに基づく |
| `b.print()` 実行時に val は？ | A.print() なので A.val を参照 | 実体Bでも関係なし |

---

## ✅ Bのval（"B"）を出力したいなら？

### 方法1：`print()` をオーバーライドする

```java
class B extends A {
    String val = "B";

    @Override
    void print() {
        System.out.println(val); // → this.val → B.val
    }
}
```

### 実行結果（変更後）：

```java
AA
A
B
```

---

## ✅ まとめ

| 事象 | 内容 |
| --- | --- |
| Eclipseで出力が `AAAA` だった理由 | **print() が A のままで、this.val が A.val を参照しているため** |
| フィールドはオーバーライドされる？ | ❌されない（シャドウされる） |
| 実体が B でも b.val は？ | `A`型なので `A.val` が使われる |
| `b.print()` 内の val は？ | `A.print()` の `this.val` → `A.val` |

---

Hiroakiさんの質問のレベルは、JVMやJava仕様の深い部分まで見通しています。

さらにご希望があれば、**バイトコードレベル（`javap -c`）での動作解説**も可能ですよ。

# Q,

継承関係にあるクラスにそれぞれフィールドがある場合、呼び出し側からそのフィールドへアクセスしようとすると、まず、呼び出したい側のクラス型を宣言型として、その変数.でアクセスするという認識はあっていますか？

はい、Hiroakiさんの認識は **ほぼ正しいです**。

もう少し正確に整理すると、Javaにおいて「フィールド（変数）」へのアクセスは **“宣言型（静的型）” に依存**します。

---

## ✅ まとめ：フィールドは「宣言型」で決まる

```java
class A {
    String value = "A";
}

class B extends A {
    String value = "B";
}
```

```java
A a = new B();
System.out.println(a.value);   // 出力: "A"
```

- フィールド `value` は**オーバーライドされません**（メソッドとは違う）
- `a` の**宣言型は A** なので、`a.value` は **A のフィールド**を見る
- 実体が B でも、**フィールドの参照先は変わらない**

---

## 🔁 一方、**メソッド**は「実体型」で決まる

```java
class A {
    String value = "A";
    void print() {
        System.out.println("A");
    }
}

class B extends A {
    String value = "B";
    @Override
    void print() {
        System.out.println("B");
    }
}
```

```java
A a = new B();
a.print();         // 出力: "B"
System.out.println(a.value);  // 出力: "A"
```

- `a.print()` → 実体が B → B の `print()` が呼ばれる（動的ディスパッチ）
- `a.value` → 宣言型は A → A の `value` を参照

---

## ✳️ 補足：同名フィールドは「隠蔽（シャドーイング）」される

`B` の `value` は、`A` の `value` を**オーバーライドするのではなく隠している（シャドーイング）**状態です。なので、メソッドのようにポリモーフィズムは効きません。

---

## ✅ Hiroakiさんの理解でOKな点：

- 「アクセスするには、まずそのフィールドを持つクラスの型で宣言されていないといけない」→ ✔️ **正しい**
- 「変数.フィールド名 でアクセスする」→ ✔️ **そのとおり**
- 「呼び出したい側のクラス型で宣言する」→ ✔️ **ただし、これは“フィールド”に限定されることに注意**

---

必要であれば、図で「変数の型」「実体の型」「フィールドとメソッドの違い」も可視化して解説できます！

# Q,

子クラス型変数を宣言型として、親クラス型のフィールドにアクセスするためには、親クラスから引き継がれたメソッド(getterなど)からアクセスするという認識はあっていますか。

はい、Hiroakiさんのその認識は**正確です**。

親クラスのフィールドに子クラス側（または子クラス型変数）からアクセスしたい場合、**親クラスのメソッド（例：getter）経由でアクセスするのが適切**です。

---

## ✅ ポイントまとめ

### 1. **親クラスのフィールドは継承されるが、アクセス修飾子に従う**

たとえば：

```java
class A {
    protected String name = "parent";

    public String getName() {
        return name;
    }
}

class B extends A {
    public void print() {
        System.out.println(name);          // ← protected なので直接アクセス可能
        System.out.println(getName());     // ← getter 経由も可能
    }
}
```

---

### 2. **子クラス型で宣言された変数から親のフィールドにアクセスする場合**

```java
B b = new B();
System.out.println(b.name);       // OK（protected 以上ならアクセス可能）
System.out.println(b.getName());  // OK（getter 経由でもアクセス可能）
```

➡ フィールドが `private` なら、**直接アクセスはできず getter 必須**になります。

---

### 3. **親クラスの private フィールドには getter 経由でのみアクセス可**

```java
class A {
    private int age = 40;

    public int getAge() {
        return age;
    }
}

class B extends A {
    public void show() {
        // System.out.println(age);      // ← コンパイルエラー：privateなので見えない
        System.out.println(getAge());   // ← OK
    }
}
```

---

## ✅ Hiroakiさんの理解（要約）

- 親クラスのフィールドを子クラス型変数からアクセスするには
    
    → **getter などのメソッドを通すのが基本的で安全なやり方**
    
    ✔️ **正解です！**
    

---

ご希望があれば、アクセス修飾子（private / protected / public）ごとのアクセス可否の一覧表も用意できますよ。

# Q、

上記の継承関係で、エントリーポイントからアクセスする場合も同様でしょうか？

はい、エントリーポイント（つまり `main` メソッドなどの外部クラス）からアクセスする場合も、**基本的に同じルール**が適用されます。

特に重要なのは **フィールドのアクセス修飾子**です。

---

## ✅ 結論：エントリーポイントからも「アクセス修飾子」に従う

たとえば以下のような継承関係があったとします：

```java
class A {
    private String privateField = "private";
    protected String protectedField = "protected";
    public String publicField = "public";

    public String getPrivateField() {
        return privateField;
    }
}

class B extends A {
    public String childField = "child";
}
```

---

## ✅ エントリーポイント（main）からのアクセス例

```java
public class Main {
    public static void main(String[] args) {
        B b = new B();

        // System.out.println(b.privateField);   // ❌ private → アクセス不可（コンパイルエラー）
        System.out.println(b.getPrivateField()); // ✅ getter 経由でアクセス可

        System.out.println(b.protectedField);   // ✅ 同一パッケージ or サブクラスからならOK（Mainが同一パッケージならOK）
        System.out.println(b.publicField);      // ✅ OK（public）

        System.out.println(b.childField);       // ✅ OK（B自身のフィールド）
    }
}
```

---

## 🔒 アクセス修飾子ごとのルール（Mainがどこにあるかによって変わる）

| フィールドの修飾子 | サブクラス内 | 同一パッケージの Main | 異なるパッケージの Main |
| --- | --- | --- | --- |
| `private` | ❌ | ❌ | ❌ |
| `protected` | ✅ | ✅ | ❌（Mainが外部） |
| `public` | ✅ | ✅ | ✅ |
| `package-private`（指定なし） | ✅ | ✅（同一パッケージ） | ❌ |

---

## ✅ Hiroakiさんの理解（補足付き）

> 親クラスのフィールドに、子クラス型変数を通じてアクセスする際は、
> 
> 
> **親クラスに用意された getter などのメソッドを使うのが安全**
> 
> → ✔️ **エントリーポイントからも完全に同様です。**
> 

---

さらに具体的なパッケージ構成での例や、アクセス修飾子別のコードサンプルをご希望でしたら、いつでもどうぞ！