# 親クラス - フィールド設定

# Q,

親クラスにてフィールドを設定してしまうと、当該フィールド名の変更等の場合、小クラス側にも影響がでるので避けたほうが良いように思うのですが、この認識はあっていますか？

Hiroakiさんの認識は**部分的に正しく、本質的には「設計の意図」に依存する**と言えます。以下に詳細を整理します。

---

## ✅ 結論：

**「親クラスにフィールドを定義すべきかどうか」は、そのフィールドが「すべての子クラスに共通の属性かどうか」によって判断すべき**です。

---

## 🔹 あなたの懸念のポイント

> フィールド名を親クラスに定義すると、変更時に子クラスに影響が出る（名前依存が強まる）
> 
> 
> → これは **事実です**。
> 
> 特に、子クラスで親のフィールドに直接アクセスしている場合（`super.fieldName`など）、**親の設計変更が子に波及**します。これを**カプセル化の破れ**とも言います。
> 

---

## 🔸 ただし、それが悪とは限らない理由

### 1. **親子関係の基本設計において「共通属性」は親に定義すべき**

```java
class Animal {
    protected String name;
}

class Dog extends Animal {
    void bark() {
        System.out.println(name + " is barking");
    }
}
```

このように `name` が **すべての動物に共通する属性**であれば、親に定義すべきであり、変更の波及も「合理的な設計変更」となります。

---

### 2. **影響を最小限にする設計：アクセサを介す**

```java
class Animal {
    private String name;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}
```

→ フィールド名の変更が発生しても、アクセサの名前さえ維持すれば、子クラスや外部には影響を出さずに済みます。

→ これは「情報隠蔽（encapsulation）」の鉄則で、設計変更に強くする基本手法です。

---

### 3. **影響を最小にしたいなら「委譲」に切り替える**

親に共通フィールドを持たせる代わりに、親子関係を避けて共通の構成要素（クラス）を**委譲**させる手もあります：

```java
class Profile {
    private String name;
}

class Dog {
    private Profile profile; // → フィールドはProfileに任せる
}
```

→ こうすることで、親クラスの構造変更が**他の構造に波及しづらくなります**。

---

## 🔸 認識の整理

| 視点 | あなたの認識 | コメント |
| --- | --- | --- |
| フィールド名変更の波及 | ✅ 正しい | 名前に依存する設計だと波及する |
| それを避けるべきか | △ 一概に正しくない | 設計次第。共通なら親でOK。 |
| 避けるための方法 | ◯ カプセル化／委譲 | 影響を減らす設計手法として有効 |

---

## 🧩 結論の補足（設計判断）

- フィールドが**継承されるべき共通要素** → 親クラスに持たせる（＋アクセサで隠蔽）
- フィールドが**子クラスごとに異なる意味や振る舞いを持つ** → 子クラスに持たせる、もしくは共通クラスに委譲

---

必要であれば、`親 → 子`における「依存方向の設計原則（DIPやLSP）」の観点からも掘り下げられます。ご希望あればお知らせください。