# 親クラスのインスタンス化

# Q,

継承関係にある子クラスをインスタンス化すると、その親クラスもインスタンス化されるという認識はあっていますか？

はい、**その認識は正確です。**

---

## ✅ 結論

> 子クラスをインスタンス化すると、親クラスも一緒にインスタンス化されます。
> 
> 
> これは Java の **コンストラクタ呼び出しのルール（継承チェーンの初期化）** に基づく仕様です。
> 

---

## 🔹 なぜか？（理由）

- Java では、クラスをインスタンス化する際に、**継承チェーンの上から順にコンストラクタが呼び出されます**。
- 子クラスのコンストラクタの先頭で `super()` が暗黙的に呼び出され、親クラスのコンストラクタが実行されます。
- その結果、**親クラスのインスタンス部分も生成され、初期化が完了してから子クラスの初期化に進む**という流れになります。

---

## 🔍 確認コード例

```java
class A {
    A() {
        System.out.println("A initialized");
    }
}

class B extends A {
    B() {
        System.out.println("B initialized");
    }
}

class C extends B {
    C() {
        System.out.println("C initialized");
    }
}

public class Main {
    public static void main(String[] args) {
        C c = new C();  // ← C のインスタンス化
    }
}
```

### ✅ 実行結果

```java
A initialized
B initialized
C initialized
```

---

## ✅ 補足事項（よくある誤解）

| 誤解 | 実際はこうなる |
| --- | --- |
| 「親クラスはインスタンス化されない（抽象化される）」 | ❌ Javaではインスタンスの**一部として確実に生成される** |
| 「super() を書かなければ親は初期化されない」 | ❌ `super()` は書かなくても**暗黙的に呼び出される**（ただし、引数付きコンストラクタがある場合は要注意） |

---

## ✅ JVM視点での理解（インスタンスの構造）

クラス `C` をインスタンス化した場合、JVMは以下のような**連続したインスタンス領域**をメモリ上に確保します：

```java
[Cインスタンス] → [Bインスタンス] → [Aインスタンス]
```

つまり、**インスタンス自体が「親 → 子」の積み重ね構造**になっており、

`super` キーワードで親クラスのメソッドやフィールドにアクセスできるのはこのためです。

---

## ✅ まとめ

| 内容 | 結果 |
| --- | --- |
| 子クラスのインスタンス化時に親クラスもインスタンス化されるか？ | ✅ Yes |
| 親クラスのコンストラクタは実行されるか？ | ✅ Yes（super() が呼ばれる） |
| 抽象クラスでも同じか？ | ✅ Yes（インスタンス化はされないが、**構造として**初期化される） |

---

## 🔚 結論（再掲）

> 子クラスのインスタンスを作成する際、親クラスのインスタンス部分（≒状態）も同時に初期化されます。
> 
> 
> これは Java の継承・インスタンス生成モデルの基本仕様であり、**常に親クラスから順に初期化が行われます。**
> 

追加で「static 初期化との違い」「抽象クラス／インターフェースとの比較」など必要であればいつでもどうぞ。

# Q,

継承関係のように利用先でnewしていなくても利用元をインスタンス化すると利用先がインスタンス化されるものは継承関係の他には無い認識はあっていますか？

はい、**その認識は非常に本質的で、原則として正しいです。**

---

## ✅ 結論（要点）

> 利用元で new など明示的なインスタンス化をしていないにもかかわらず、
> 
> 
> **利用元をインスタンス化しただけで“連動してインスタンス化される”ような構造は、原則として Java では「継承関係」だけです。**
> 

---

## 🔍 なぜか？

### ✅ 継承関係は「インスタンス構造の一部」になる

- 継承関係では、子クラスのインスタンスには **親クラスの状態やメソッドが“埋め込まれる”**
- JVMレベルでも、子クラスのインスタンスには親の領域が必ず組み込まれるため、
- **`new 子クラス()` のタイミングで `親クラスのコンストラクタ` が必ず実行される（インスタンス化される）**

---

## ✅ 一方、その他の関係はどうか？

| 関係 | 利用元で `new` していなければ？ | 利用先のインスタンス化 | 解説 |
| --- | --- | --- | --- |
| 継承関係（`extends`） | 🔄 暗黙にされる | ✅ 自動でされる | JVMが継承チェーンを初期化 |
| フィールドに型を持つ | 🔄 されない | ❌ 明示的に new が必要 | `Engine engine;` のような定義だけではインスタンス化されない |
| コンストラクタ引数 | 🔄 呼び出し元次第 | ❌ 呼び出し元で new が必要 | DIでも外部から注入されるだけ |
| メソッド引数・戻り値 | 🔄 実行時依存 | ❌ 呼び出されない限り生成されない |  |
| static フィールド | 🔄 クラスロード時 | ✅ クラス単位で初期化される | ただし `インスタンス化` ではなく `クラス初期化` である点に注意 |
| 内部クラス（非static） | 🔄 外側クラスから生成される | ✅ 外側のインスタンスが必要 | `new Outer().new Inner()` の形式 |
| interfaceの実装元 | 🔄 明示的に呼ばない限り | ❌ new が必要 | 実装はされているが、インスタンス化はされない |

---

## ✅ 特に区別すべきもの：**「所有」と「継承」の違い**

| 所有の例（has-a） | 継承の例（is-a） |
| --- | --- |
| `Car` has-an `Engine`（フィールド） | `Dog` is-an `Animal`（継承） |
| 明示的に `new Engine()` が必要 | `new Dog()` → `Animal` も構成される |

---

## ✅ 特例（紛らわしいがインスタンス化ではない）

- **static初期化子やstaticフィールドの`new`処理**
    - これは **クラスのロード時に一度だけ行われる**が、インスタンス化とは別物
    - クラスの **「クラス初期化（<clinit>）」** で発生する

```java
class A {
    static B b = new B(); // ← これはクラスロード時に実行される（インスタンス初期化ではない）
}

class B {
    B() {
        System.out.println("B created");
    }
}
```

---

## ✅ まとめ表

| 構造・関係 | 利用元インスタンス化時に連動して利用先がインスタンス化されるか？ | 補足 |
| --- | --- | --- |
| 継承関係 (`extends`) | ✅ される | JVM仕様で必ず親→子の順に初期化 |
| フィールド（参照のみ） | ❌ されない | `new` しなければ null |
| コンストラクタ引数 | ❌ 呼び出し元が責任を持つ |  |
| static フィールド初期化 | ✅ されるがインスタンスとは別扱い | クラス初期化の一部（static初期化） |
| 内部クラス（非static） | ❌ 外側のインスタンスが必要 | `Outer.Inner` の関係 |
| インターフェース実装 | ❌ されない | 実装していても `new` が必要 |

---

## ✅ 結論（再掲）

> 継承関係以外では、Java では「自動的に連動してインスタンス化される」ような仕組みはありません。
> 
> 
> 他の関係（フィールド、引数、内部クラスなど）では、**明示的に `new` する責任が常に必要**です。
> 

この観点は、**コンポジション vs 継承の設計判断**にも直結します。より深く掘り下げる場合は、いつでもお声がけください。