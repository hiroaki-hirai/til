# 匿名クラス

# Q,

匿名クラスでの内部処理はどのような処理をしていますか？
直接インスタンス化できないものに、実体を付与してインスタンス化する。
invokeDynamicのような、合成処理をJvmが内部処理しているのでしょうか？

とても鋭い質問です、Hiroakiさん。

> 匿名クラスでの内部処理はどうなっているのか？
> 
> 
> → これは **`invokeDynamic` のような動的バイトコード処理なのか？ それともコンパイル時に何か起きているのか？**
> 

---

## ✅ 結論から言うと：

> 匿名クラスは invokeDynamic ではなく、Javaコンパイラが通常の「具象クラス」を合成（生成）しており、JVMは通常通りそのクラスをロード・インスタンス化しています。
> 

つまり、**Javaコンパイラが裏で「名前のないクラス」を作っている**だけで、**特別な動的呼び出し命令（invokeDynamic）などは使われていません。**

---

## 🔍 匿名クラスの内部処理の流れ

### 1. **Javaコンパイル時：**

```java
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello");
    }
};
```

⬇️ Javaコンパイラは以下のような**内部クラス（synthetic class）**を自動で生成します（名前はコンパイラ依存ですが、概ね次のような形）：

```java
class Main$1 implements Runnable {
    @Override
    public void run() {
        System.out.println("Hello");
    }
}
```

- `Main$1.class` というクラスファイルが生成される。
- クラスファイルとしては通常の内部クラスと同じ扱い。
- `new Runnable() { ... }` は実際にはこの合成クラスの `new` 呼び出しに置き換えられる。

---

### 2. **JVM実行時：**

- JVMは通常のクラスロードと同じように `Main$1` クラスをロードし、インスタンス化する。
- **invokeDynamicは使われていません。**

---

## 🔸 `invokeDynamic` が関係するのはいつ？

> invokeDynamic は主に ラムダ式（Java 8以降） のときに使われます。
> 

```java
Runnable r = () -> System.out.println("Hello");
```

このラムダ式は、Javaコンパイラが **`invokedynamic` 命令を使ってバイトコードに変換**します。JVMが **`LambdaMetafactory`** を通じて動的にインスタンスを生成します。

これは **匿名クラスと大きく異なる点**で、

- 匿名クラス → コンパイル時に「具象クラス」が生成される（`.class`ファイルもできる）
- ラムダ式 → 実行時に `invokedynamic` でインスタンス生成される（`.class`ファイルなし）

---

## ✅ まとめ表

| 特性 | 匿名クラス | ラムダ式 |
| --- | --- | --- |
| バックエンド処理 | コンパイラが内部クラスを生成 | JVMが `invokeDynamic` を使用 |
| `.class` ファイル | 生成される（例：Outer$1.class） | 生成されない |
| 実行効率 | やや低い（クラス生成あり） | 高速（動的生成・最適化） |
| 使用例 | 複雑な振る舞い、複数メソッド | 単純な関数型インターフェース |

---

## ✅ Hiroakiさんの疑問への回答まとめ

| 疑問 | 回答 |
| --- | --- |
| 匿名クラスは実体をどう得ているか？ | コンパイル時に無名の具象クラス（`.class`）が作られている |
| invokeDynamic が使われているか？ | ❌ **匿名クラスでは使われない**（ラムダ式では使用） |
| 実体付与の仕組み | Javaコンパイラが synthetic class を合成・JVMが通常通りロード |

---

もしご希望であれば、**匿名クラスとラムダ式のバイトコード（`javap -c`）比較**などもできます！

# Q,

匿名クラスは、インターフェースや親クラスにない独自のメソッドを定義できるようですが、これは、他のクラスでも同じことが言えますか？

とても良い観点です。

結論から申し上げると、**匿名クラスに限らず、通常のクラス（名前付きのクラス）や内部クラス、ローカルクラスでも「独自のメソッドを定義する」ことは可能**です。

ただし、重要なのは：

---

### ✅ **「独自メソッドを**定義**すること」と「それを**呼び出せる**か」は別問題」**という点です。

---

## 🔷 例：匿名クラスでの独自メソッド定義

```java
interface Greetable {
    void greet();
}

public class Main {
    public static void main(String[] args) {
        Greetable g = new Greetable() {
            @Override
            public void greet() {
                System.out.println("Hello");
            }

            // 独自メソッド
            public void extra() {
                System.out.println("Extra method");
            }
        };

        g.greet();       // ✅ OK
        // g.extra();    // ❌ NG：型が Greetable のため extra() は見えない
    }
}
```

- `extra()` は匿名クラス内で定義できるが、
- 呼び出す側の変数 `g` の型が `Greetable` なので、`extra()` は見えない。

---

## 🔷 つまり、他のクラスでも同じ現象が起きる

### ✅ 通常のクラスでも：

```java
class MyClass {
    public void greet() {
        System.out.println("Hello");
    }

    public void extra() {
        System.out.println("Extra");
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.greet();   // ✅ OK
        obj.extra();   // ✅ OK
    }
}
```

→ `MyClass` を型として使えば、`extra()` も見える。

---

### ❌ 型をインターフェースにすると？

```java
interface Greetable {
    void greet();
}

class MyClass implements Greetable {
    public void greet() {
        System.out.println("Hello");
    }

    public void extra() {
        System.out.println("Extra");
    }
}

public class Main {
    public static void main(String[] args) {
        Greetable obj = new MyClass();
        obj.greet();   // ✅ OK
        // obj.extra(); // ❌ NG：型が Greetable のため extra() は見えない
    }
}
```

---

## ✅ まとめ：匿名クラスの独自メソッド定義は「特別ではない」

| 観点 | 匿名クラス | 通常クラス / 内部クラス / ローカルクラス |
| --- | --- | --- |
| 独自メソッド定義可能？ | ✅ 可能 | ✅ 可能 |
| 呼び出せるかは？ | ❌ 呼び出せない（型による） | 同様に❌ 型によって制限 |

結論：**「定義はできるが、アクセスできるとは限らない」**のは匿名クラスだけの制限ではなく、Javaの「変数の宣言型に従う」仕様によるものです。

# Q,

var型の変数にインスタンスを代入して、その変数からアクセスする場合は独自メソッドも呼び出せますか？

はい、**呼び出せます**。

`var` を使って変数を宣言した場合、**代入されたインスタンスの具体的な型がそのまま型として推論される**ため、**匿名クラスで定義した独自メソッドにもアクセス可能**です。

---

## ✅ 例：`var` を使った匿名クラスと独自メソッド

```java
interface Greetable {
    void greet();
}

public class Main {
    public static void main(String[] args) {
        var greeter = new Greetable() {
            @Override
            public void greet() {
                System.out.println("Hello");
            }

            public void extra() {
                System.out.println("Extra method");
            }
        };

        greeter.greet();  // ✅ OK
        greeter.extra();  // ✅ OK（varだから見える！）
    }
}
```

### 🔍 なぜ `extra()` が呼び出せるのか？

- `var` に代入された右辺は匿名クラスの**具象型**（`Greetable` を継承した無名サブクラス）であり、
- その型には `greet()` も `extra()` も含まれているので、推論された型にも両方が見えている。

---

## ⚠️ 注意点

ただし、このコードは**Java 11 以降**で `var` が使える前提です。

また、匿名クラスの「**具象型名は存在しない（名前がない）**」ため、**別のメソッドから受け取ったり戻したりするのは難しい**です。

```java
public class Main {
    public static void doSomething(Object obj) {
        // obj.extra(); // ❌ コンパイルエラー（型不明なので見えない）
    }
}
```

---

## ✅ 結論まとめ

| 宣言方法 | 独自メソッドアクセス | 備考 |
| --- | --- | --- |
| `Greetable g = new ...` | ❌ 不可 | 型がインターフェースなので見えない |
| `var g = new ...` | ✅ 可 | 実装された匿名クラスの型が推論されるため可 |

`var` にすると**その場限定ではあるが強力なダックタイピング的挙動**になります。ただし、可読性や設計の観点から多用には注意が必要です。