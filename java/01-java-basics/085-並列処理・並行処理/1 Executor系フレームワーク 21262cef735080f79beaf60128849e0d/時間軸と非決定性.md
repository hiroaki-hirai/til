# 時間軸と非決定性

# Q、

教育的な流れで、並行・並列処理以前はループ処理以外は基本、実行の瞬間にコンソールに出力なりがなされていましたが、並行・並列処理の場合は、そこに時系列が加わったように思いますが、この認識はあっていますか？

はい、Hiroakiさんの認識は非常に本質を突いています。

以下のように整理すると、より明確になります。

---

## ✅ 並行・並列処理の前提：**「逐次実行（シーケンシャル）」**

### 🔸従来の処理（ループや通常のメソッド呼び出しなど）

- 実行される順序が **プログラムに書かれた順**（top to bottom）
- 各命令は **前の処理が終わってから** 次の処理に進む
- 結果（出力や副作用）は **予測可能な時系列** で発生

```java
for (int i = 0; i < 3; i++) {
    System.out.println(i);
}
// 出力: 0, 1, 2 （順番が保証される）
```

---

## ✅ 並行・並列処理の登場：**「時系列の非決定性」が加わる**

### 🔸並行（Concurrent）

- スレッド単位で **処理の論理的な同時実行**
- JVMやOSが **時間的に切り替えて（コンテキストスイッチ）** 実行
- **順序が保証されない** 出力になる可能性

```java
Runnable task = () -> System.out.println("Hello from thread");
new Thread(task).start();
System.out.println("Hello from main");
// 出力順は不定（mainが先か、threadが先か）
```

### 🔸並列（Parallel）

- **複数コア**にまたがって物理的に同時に実行される
- 並行よりさらに「**真の同時性**」がある
- タイミング制御しなければ、**出力は乱雑な時系列**になることも

---

## ✅ 教育的観点でのまとめ

| 観点 | 従来処理（逐次） | 並行・並列処理 |
| --- | --- | --- |
| 実行の流れ | 書かれた順 | 実行タイミングは **非同期的** |
| 出力の順序 | 保証される | **保証されない**（制御が必要） |
| 学習段階 | 「因果的な時系列」重視 | 「**非同期性と状態の変化**」が焦点 |
| 追加される視点 | ― | **時間・同期・リソース**の概念 |

---

## ✅ Hiroakiさんの表現を言い換えると…

> 「並行・並列処理の登場によって、**“実行＝即出力”という直線的な世界に、“時間軸と非決定性”が持ち込まれた」
> 
> 
> → 完全にその通りです。
> 

---

ご希望であれば、Javaの`Thread`や`ExecutorService`を使った「出力順の変化例」もご紹介できます。

# Q,

「並行・並列処理の登場によって、**“実行＝即出力”という直線的な世界に、“時間軸と非決定性”が持ち込まれた」

上記の ”時間軸と非決定性” によって、プログラミングのタイミングは、どうなりますか？
"実行＝即出力” の時点では、プログラマが最初にプログラムを組んで実行し、出力を確認。
”時間軸と非決定性” の場合は、プログラムが動作している途中でプログラマが現在動作中のプログラムへ干渉できる。という認識はあっていますか？

Hiroakiさんのご質問は、「**非決定性と時間軸が導入されたことで、プログラマが“タイミング的にどう関与できるか”が変化したか？」という高度な視点ですね。
結論からお答えすると、**「干渉できる可能性が増えたが、それには設計が必要」**です。以下に詳しく整理します。

---

## ✅「実行＝即出力」の世界（逐次処理）

- プログラムの**制御権は完全にプログラマにある**（あらかじめ書かれた手順通りにしか動かない）
- 実行後、**出力が予測通りかを確認するだけ**
- プログラマは「**事前の制御**」のみが可能で、**実行中に介入できない**

---

## ✅「時間軸と非決定性」の導入（並行・並列処理）

ここでの**非決定性**とは：

- 「どのスレッドがいつ動くか」
- 「どの順で出力されるか」
- 「どのリソースにいつアクセスするか」
    
    が**JVMやOSに委ねられる**ため、**プログラマが直接制御できない部分が増える**ということです。
    

---

## ✅ それによって変わる「プログラマの介入タイミング」

| 介入のタイミング | 逐次処理 | 並行・並列処理 |
| --- | --- | --- |
| 事前 | ◯ 設計・実装 | ◯ スレッド設計・同期制御 |
| 実行中（動的） | ✕ 不可能 | ◎ 可能（ただし**設計が必要**） |
| 実行後 | ◯ 出力確認 | ◯ 状態確認・ログ出力・スレッド終了監視など |

---

## ✅ 並行・並列処理で可能になる「実行中の干渉」の例

### 1. **監視スレッドやUIイベントによる介入**

```java
Thread worker = new Thread(() -> {
    while (!Thread.currentThread().isInterrupted()) {
        // 処理を継続
    }
});
worker.start();

// プログラマのタイミングで中断（ユーザー操作でもOK）
worker.interrupt();
```

### 2. **Executor + Future のキャンセル**

```java
Future<?> future = executor.submit(() -> {
    while (true) {
        // 処理を継続
    }
});
Thread.sleep(1000);
future.cancel(true); // 実行中にキャンセル可能
```

### 3. **JavaFXやSwingのイベントドリブン処理**

- GUI操作が **バックグラウンドの処理に命令を出す**：完全に動的な干渉

---

## ✅ 補足：干渉を可能にするには「仕掛け」が必要

並行・並列処理が**実行中の干渉を可能にする土台**にはなりますが、

それを **可能にするには、以下のような仕掛けが必要**です：

- `volatile` / `AtomicXXX` などでの **共有状態の監視**
- `Future` などの **ハンドルの保持**
- `BlockingQueue` などの **メッセージキュー**
- イベントループやPub/Subなどの **非同期通知構造**

---

## ✅ 結論：Hiroakiさんの認識の整理

> 「並行・並列処理の世界では、実行中にプログラムに干渉できるようになった」
> 
> 
> → **基本的には正しい認識**です。
> 

ただし、それは自然にできるわけではなく、

- **並行・並列という世界が「動的干渉の可能性」を開いた**
- ただし、それを実現するには**設計段階からの備え**が必要
    
    という点が重要です。
    

---

ご希望があれば、「非同期処理とUIイベント」「監視設計とフラグ制御」など、実装スタイルごとに干渉例をご紹介できます！

# Q,

> ## ✅ 補足：干渉を可能にするには「仕掛け」が必要

並行・並列処理が**実行中の干渉を可能にする土台**にはなりますが、
それを **可能にするには、以下のような仕掛けが必要**です：

-volatile/AtomicXXXなどでの **共有状態の監視**
-Futureなどの **ハンドルの保持**
-BlockingQueueなどの **メッセージキュー**
- イベントループやPub/Subなどの **非同期通知構造**
> 

上記の仕掛けの具体的なイメージが湧きません。
このトピックに関心が湧いたきっかけが、FutureTaskクラスの動作中の干渉の可能性でした(cancelメソッドなど)。
この仕掛けの一例として、事前にFuture実装でFutureTaskクラスを利用できるように事前にプログラムに組み込む必要がある、というようなイメージでしょうか？

はい、Hiroakiさんの理解は非常に正確です。

まさに「**干渉できるようにするには、事前に干渉を受け入れる“仕掛け”を設計に組み込んでおく必要がある**」ということです。

以下に、それぞれの仕掛けについて **目的・具体的イメージ・コード例** をセットで解説します。

---

## ✅ 1. `Future` / `FutureTask`（処理ハンドルを保持）

### 🔹目的

- 処理の**状態監視**（isDone, isCancelled）
- **キャンセル可能性**を仕込む（cancel）

### 🔹具体イメージ

- `submit()`で返された`Future`は「実行中の処理へのリモコン」
- これを保持しておけば、後から `cancel()` で処理中止などが可能

### 🔹例

```java
BlockingQueue<String> queue = new LinkedBlockingQueue<>();

// 消費者スレッド
new Thread(() -> {
    try {
        while (true) {
            String command = queue.take(); // 待機状態
            if ("stop".equals(command)) break;
            System.out.println("処理: " + command);
        }
    } catch (InterruptedException e) {}
}).start();

// 干渉
queue.put("job1");
queue.put("stop");  // ← これが「終了命令」
```

---

## ✅ 4. イベントループ / Pub-Sub（非同期通知）

### 🔹目的

- **任意タイミングで命令を発行し、実行中に伝達**
- GUI、ゲーム、非同期処理で多用

### 🔹具体イメージ

- スレッドは常にイベントキューを監視
- そこに「こう動け」というメッセージを投入して**動作を変化させる**

### 🔹簡易イメージ

```java
Queue<Runnable> eventLoop = new LinkedList<>();

// スレッド
new Thread(() -> {
    while (true) {
        Runnable task = eventLoop.poll();
        if (task != null) task.run();
    }
}).start();

// 外部から干渉
eventLoop.add(() -> System.out.println("イベント処理！"));
```

---

## ✅ Hiroakiさんの問いの答えに戻ると…

> この仕掛けの一例として、事前に Future 実装で FutureTask クラスを利用できるように事前にプログラムに組み込む必要がある、というようなイメージでしょうか？
> 

→ **完全にその通りです。**

- `FutureTask`は「干渉可能なタスク」として、**あらかじめ用意しておくことが前提**です。
- 後から`Thread.sleep()`中のThreadに突然アクセスしようとしても何もできません。
- 干渉できるように**構造・契約・道具立て**を整えておく必要があるのです。

---

## ✅ 補足：仕掛け ≒ APIだけではなく「設計思想」

これらは単なる機能やクラス名ではなく、**「設計思想」そのもの**です。

「外から止められる設計」

「状態を共有する設計」

「非同期に命令できる設計」

こういった思想がなければ、**干渉可能性は成立しません**。

---

さらに個別の仕掛けの中から「今のHiroakiさんの興味や使用ケースに合ったもの」を掘り下げて学ぶと、非常に実務的な力になります。気になるものがあれば深掘りできます！