# 原子性・可視性・順序性

# Q,

「可視性・原子性・順序性」の3点をコードと図解で比較するまとめをお願いします。

承知しました。Hiroakiさんのご要望にお応えして、**「可視性」「原子性」「順序性」というJavaメモリモデル（JMM）の3大要素**を以下のように構造的に解説・比較し、コード例と図解（テキストベース）で整理します。

---

# 🧠 Javaのメモリモデルにおける3大基本性質

| 性質 | 説明 | 問題の典型例 | 解決方法 |
| --- | --- | --- | --- |
| 🔍 可視性（Visibility） | 他のスレッドが最新の値を「見える」か | 値を変更したのに他スレッドで反映されない | `volatile`, `synchronized` |
| 🧱 原子性（Atomicity） | 操作が分割されず一括で実行されるか | `count++` で途中介入されて不正な値になる | `AtomicInteger`, `synchronized` |
| 🔁 順序性（Ordering） | 命令が「見た通りの順」で実行されるか | コンパイラやCPUの最適化で順序が変わる | `synchronized`, `volatile` |

---

## 📌 比較：コード＋図解での解説

---

### ① 可視性（Visibility）

### ✅ 問題コード（`volatile` 無し）

```java
class Shared {
    boolean running = true;

    void run() {
        while (running) {
            // runningがfalseでもループが抜けない可能性
        }
    }

    void stop() {
        running = false;
    }
}
```

### ❌ 問題の図解（キャッシュのせいで他スレッドに伝わらない）：

```java
Thread-A (loop)         Thread-B (stop)
------------------      -----------------
レジスタ: running=true   ↓
        ⬅ main memory  running=false
```

### ✅ 解決法

```java
volatile boolean running = true;
```

→ メインメモリとの同期が保証され、他スレッドにも変更が見える。

---

### ② 原子性（Atomicity）

### ❌ 問題コード（非原子的な加算）

```java
class Counter {
    int count = 0;

    void increment() {
        count++;  // 3ステップに分解されて非原子的
    }
}
```

### ❌ 問題の図解（2スレッドが同時に count++）

```java
Thread-A               Thread-B
---------              ---------
read count=0           read count=0
count+1=1              count+1=1
write count=1          write count=1
→ 最終値は 1（1回しか加算されていない）
```

### ✅ 解決法①：AtomicInteger

```java
AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet();  // 原子的に処理される
```

### ✅ 解決法②：synchronizedブロック

```java
synchronized void increment() {
    count++;
}
```

---

### ③ 順序性（Ordering）

### ❌ 問題コード（最適化による順序逆転）

```java
int a = 0;
boolean flag = false;

void writer() {
    a = 1;
    flag = true;
}

void reader() {
    if (flag) {
        System.out.println(a); // a が 0 のまま出力される可能性あり！
    }
}
```

### ❌ 問題の図解（CPU/コンパイラ最適化により順序逆転）

```java
本来の意図      実行順（最適化）
-------------   -------------------
a = 1           flag = true
flag = true     a = 1
```

### ✅ 解決法①：volatileの使用

```java
volatile boolean flag = false;
```

→ `flag` の読み書きに**順序性と可視性の両方**が保証される

### ✅ 解決法②：synchronized（ロックにより順序保証）

```java
synchronized(lock) {
    a = 1;
    flag = true;
}
```

---

## 🟦 まとめ：3要素の違い早見表

| 性質 | 主なリスク | 例 | 対処法 |
| --- | --- | --- | --- |
| 可視性 | 変更が他スレッドに見えない | `flag = true` が伝わらない | `volatile`, `synchronized` |
| 原子性 | 処理の途中で他が割り込む | `count++` | `AtomicInteger`, `synchronized` |
| 順序性 | 実行順が逆転し整合性が壊れる | `flag=true` → `a=1` のつもりが逆になる | `volatile`, `synchronized` |

---

## 💡 備考：volatile vs synchronized の違い

| 機能 | `volatile` | `synchronized` |
| --- | --- | --- |
| 可視性 | ✅ | ✅ |
| 原子性 | ❌ | ✅ |
| 順序性 | ✅（簡易） | ✅（完全） |
| オーバーヘッド | 小さい | 大きめ（ロックが必要） |
| 用途 | 単一の読み書き状態フラグなど | 複数手順の保護、複雑な状態遷移 |

---

ご希望であれば、これらの3性質を反映した**実践的マルチスレッド設計のテンプレート**もお渡しできます！