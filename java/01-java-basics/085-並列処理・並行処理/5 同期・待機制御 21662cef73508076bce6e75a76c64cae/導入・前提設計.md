# 導入・前提設計

# Q,

同期・待機制御（補助機構）APIは、実行中の処理やスレッドの状態などをどうやって取り込んでいるのでしょうか？
それぞれの状態を把握しなくてはそれらを制御できない認識です。
FutureTaskのように処理やスレッドのインスタンスを保持するようなイメージでしょうか？

ご指摘のとおり、**同期・待機制御API（CountDownLatch、CyclicBarrier、Semaphore、Phaserなど）は、`FutureTask`のように処理やスレッドのインスタンスを保持しているわけではありません**が、**「スレッドの動作（待機・進行・終了）」に介入する仕組み**を持っています。

そのしくみは以下のように整理できます：

---

## ✅ 結論：同期・待機APIは「スレッドの状態」そのものを把握するのではなく、「自発的な参加と待機」によって制御する

| 視点 | 内容 |
| --- | --- |
| ❌ 保持するのは | スレッドそのものの参照では**ない**（Thread型などを直接保持しない） |
| ✅ 把握方法 | 各スレッドが **明示的に同期APIにアクセス（await / acquire / arriveなど）** することで、自らの状態を同期機構に登録する |
| ✅ 制御方法 | 内部的に`java.util.concurrent.locks`系の**低レベル同期機構（LockSupport, AbstractQueuedSynchronizerなど）**を使い、スレッドを一時的に **ブロック or 再開** する |

---

## 🔧 代表的な同期APIの「仕組みと介入のタイミング」

### ◾ `CountDownLatch`

- 内部にカウンタを持つ
- `await()` を呼んだスレッドは **内部キューに入れてブロック（LockSupport）**
- `countDown()` を別スレッドが呼ぶことでカウントが0に → 待機中のスレッドを一括でアンブロック

```java
CountDownLatch latch = new CountDownLatch(2);

// スレッドA
executor.submit(() -> {
    task();
    latch.countDown(); // ✅ 自発的に「1つ終わった」と伝える
});

// スレッドB
executor.submit(() -> {
    task();
    latch.countDown(); // ✅ 同様
});

// スレッドC
latch.await(); // ✅ カウントが0になるまでブロック（内部キューに並ぶ）
```

---

### ◾ `CyclicBarrier`

- 指定したスレッド数が `await()` を呼ぶことでブロック → すべて揃うと同時に解除
- **各スレッドが自発的に参加**してブロック待機し、**内部の到着数カウンタ**を管理

---

### ◾ `Semaphore`

- 許容量カウントを持つ
- `acquire()` を呼ぶと、残容量があれば取得、なければブロック
- `release()` で容量を返却
- スレッドの状態は**カウントの残りと内部待機キュー**で間接的に管理

---

### ◾ `Phaser`

- スレッドの段階的な進行（フェーズ）を制御
- `arrive()` / `awaitAdvance()` などを通じて **各スレッドがフェーズ進行に参加**
- 進行状況はスレッド自体ではなく**登録されたカウント**で管理

---

## ✅ まとめ：同期・待機制御APIの「状態把握」の正体

| 要素 | 内容 |
| --- | --- |
| ❌ スレッド自体を管理？ | しない（`Thread`型の直接参照などは保持しない） |
| ✅ 状態の把握方法 | スレッド自身がAPIを呼び出すことで「今ここで待っている」と宣言する |
| ✅ 制御方法 | `LockSupport.park()` や `AbstractQueuedSynchronizer`（AQS）を使ってスレッドを一時停止・再開させる |
| ✅ 状態の種類 | 「ブロック中」「到達済み」「取得済み」「フェーズ完了」など、**論理的な状態を内部でキュー／カウンタ管理** |

---

## 🔍 FutureTask との違い

| 観点 | FutureTask | 同期API群（Latch/Barrier/etc.） |
| --- | --- | --- |
| 保持するもの | 処理（Runnable/Callable）・結果・状態・例外 | スレッドの数的な状態やブロック待機のキュー |
| スレッドとの関係 | `run()` や `get()` を通じて間接的に制御 | `await()` や `acquire()` を通じて**自発的に参加するスレッドを制御** |
| 主目的 | 処理の実行・状態／結果管理 | 複数スレッドの**同期と待機** |

---

## ご参考：低レベル実装に用いられている主な基盤

- `LockSupport.park()` / `unpark()`：スレッドをブロック＆復帰
- `AbstractQueuedSynchronizer`（AQS）：排他ロックや待機キューの共通実装
- `Condition` オブジェクト：`await()` / `signal()` の仕組みを支える

---

必要であれば、たとえば：

- CountDownLatch 内部の AQS 実装解説
- CyclicBarrier のスレッド登録・開放のタイミング図
- 同期APIの選定フローチャート（何を使うべきか）

などもご提供できます。お気軽にお知らせください。

# Q,

CyclicBarrierを利用する前提として、RunnableなりCallable実装の具象クラスへ、CyclicBarrierクラスのインスタンスを具象クラスのフィールドへ注入しておき、処理が終わった場合にその具象クラスからawait()を実施するように、前もって設定しておくという認識はあっていますか？

はい、Hiroakiさんの認識は **正確です**。

CyclicBarrier を利用する際は、次のような設計構造を前提とします：

---

## ✅ 1. CyclicBarrierを使う前提の「注入＋同期設計」

### 🧩 設計ポイントの整理：

| 項目 | 内容 |
| --- | --- |
| **1. CyclicBarrierの生成** | 事前にスレッド数を指定して生成しておく（例：`new CyclicBarrier(3)`） |
| **2. タスクの共有フィールド** | `Runnable`や`Callable`の具象クラスに `CyclicBarrier` の参照を保持 |
| **3. タスク内で`await()`呼び出し** | 各スレッドの処理が終了 or 途中ポイントで `await()` を実行 |
| **4. すべてのスレッドが`await()` に到達したら** | 全スレッドが同時に「バリア通過」して次の処理へ進む |

---

## ✅ 2. 実装パターン例（Runnableに注入するケース）

```java
import java.util.concurrent.*;

public class BarrierTask implements Runnable {
    private final CyclicBarrier barrier;

    public BarrierTask(CyclicBarrier barrier) {
        this.barrier = barrier; // フィールドへ注入
    }

    @Override
    public void run() {
        try {
            System.out.println(Thread.currentThread().getName() + " is working");
            Thread.sleep(1000); // 何らかの処理
            System.out.println(Thread.currentThread().getName() + " is waiting at barrier");
            barrier.await(); // 全スレッドが揃うまでここで待機
            System.out.println(Thread.currentThread().getName() + " passed the barrier");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        final int parties = 3;
        CyclicBarrier barrier = new CyclicBarrier(parties);
        ExecutorService executor = Executors.newFixedThreadPool(parties);

        for (int i = 0; i < parties; i++) {
            executor.submit(new BarrierTask(barrier)); // barrierを注入して起動
        }

        executor.shutdown();
    }
}
```

---

## ✅ 3. 注入方法のバリエーション

| 方法 | 説明 |
| --- | --- |
| **コンストラクタ注入** | 最も一般的。上記のように `new BarrierTask(barrier)` とする |
| **セッターメソッド** | 後から `setBarrier(CyclicBarrier barrier)` で設定することも可 |
| **ラムダ式内でクロージャとして参照** | 無名クラスやラムダを使う場合、外部変数としてキャプチャして利用することも可能 |

---

## ✅ 4. 補足：await() をどこで呼ぶかの戦略

- **処理の最後に呼べば「全スレッドが終わるまで待つ」同期に**
- **中間に呼べば「フェーズ間の足並み揃え（フェーズ間バリア）」として利用**

---

## 🔚 まとめ

> ✔️ Runnable / Callable の実装クラスに CyclicBarrier を事前に注入しておき、
> 
> 
> ✔️ **任意の処理タイミングで `await()` を呼び出すことで、バリア同期の制御を組み込む。**
> 

この設計が基本パターンです。