# 並列処理・並行処理

[並列処理 と 並行処理](%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86%E3%83%BB%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86%2020e62cef735080ce9650c2d41f988425/%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86%20%E3%81%A8%20%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86%2020e62cef735080c6a590f319b11f77c8.md)

[start() と run()](%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86%E3%83%BB%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86%2020e62cef735080ce9650c2d41f988425/start()%20%E3%81%A8%20run()%2021062cef7350806a94d4cc92181ec002.md)

[Thread継承 vs Runnable実装](%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86%E3%83%BB%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86%2020e62cef735080ce9650c2d41f988425/Thread%E7%B6%99%E6%89%BF%20vs%20Runnable%E5%AE%9F%E8%A3%85%2021262cef735080708ce9da7a73e65656.md)

[非同期処理](%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86%E3%83%BB%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86%2020e62cef735080ce9650c2d41f988425/%E9%9D%9E%E5%90%8C%E6%9C%9F%E5%87%A6%E7%90%86%2021262cef7350806ca56ff6c4dec8df3c.md)

[API郡まとめ](%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86%E3%83%BB%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86%2020e62cef735080ce9650c2d41f988425/API%E9%83%A1%E3%81%BE%E3%81%A8%E3%82%81%2021562cef73508066bc33d4b2f9885db8.md)

[1. Executor系フレームワーク](%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86%E3%83%BB%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86%2020e62cef735080ce9650c2d41f988425/1%20Executor%E7%B3%BB%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%2021262cef735080f79beaf60128849e0d.md)

[2. Future系フレームワーク](%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86%E3%83%BB%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86%2020e62cef735080ce9650c2d41f988425/2%20Future%E7%B3%BB%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%2021662cef7350801aa9c2faa1cfadeb5b.md)

[3. 実行対象API](%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86%E3%83%BB%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86%2020e62cef735080ce9650c2d41f988425/3%20%E5%AE%9F%E8%A1%8C%E5%AF%BE%E8%B1%A1API%2021662cef735080dfaefcfb62b88da069.md)

[4. Thread制御](%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86%E3%83%BB%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86%2020e62cef735080ce9650c2d41f988425/4%20Thread%E5%88%B6%E5%BE%A1%2021662cef73508049a475fcc892db088d.md)

[5. 同期・待機制御](%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86%E3%83%BB%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86%2020e62cef735080ce9650c2d41f988425/5%20%E5%90%8C%E6%9C%9F%E3%83%BB%E5%BE%85%E6%A9%9F%E5%88%B6%E5%BE%A1%2021662cef73508076bce6e75a76c64cae.md)

[ExecutionException](%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86%E3%83%BB%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86%2020e62cef735080ce9650c2d41f988425/ExecutionException%2021662cef735080e0bf01e58f712d9683.md)

# Q,

「並列・並行処理 全体マップ」（概念から実装までの図）をお願いします

承知しました。

以下に、Javaにおける **「並列・並行処理の全体マップ（概念 → モデル → API/実装）」** を整理した図と表をお示しします。

---

# ✅ Java 並列・並行処理の全体構成マップ

```java
【概念レイヤー】─── 抽象的な考え方
│
├─ 🧠 並行処理（Concurrency）
│     └─ 論理的に同時進行（1コアでも切り替えで可能）
│
├─ 🧠 並列処理（Parallelism）
│     └─ 物理的に同時実行（複数コアで実現）
│
↓
【モデルレイヤー】─── プログラム構造としての設計モデル
│
├─ 🔹 スレッドモデル
│     └─ Thread / Runnable / Callable
│
├─ 🔹 タスク実行モデル
│     └─ Executor / ExecutorService / ForkJoinPool
│
├─ 🔹 イベントドリブンモデル
│     └─ 非同期コールバック（CompletableFuture, RxJava, Reactor）
│
↓
【API / 実装レイヤー】─── Javaでの具体的な実装手段
│
├─ 🧩 Thread（java.lang.Thread）
│     └─ 低レベルなスレッド直接操作（学習・限定用途）
│
├─ 🧩 ExecutorService（Executors.newXxxx）
│     └─ スレッドプール管理、高水準実行（実務で主流）
│
├─ 🧩 ForkJoinPool / ParallelStream
│     └─ 自動分割・合成（Divide & Conquer並列処理）
│
├─ 🧩 ScheduledExecutorService
│     └─ タイマー・定期実行処理
│
├─ 🧩 CompletableFuture
│     └─ 非同期結果を保持・連結する未来的オブジェクト
│
├─ 🧩 Reactive Streams（RxJava, Project Reactor）
│     └─ イベントストリームを非同期に処理（Backpressure対応）
│
└─ 🧩 Virtual Threads（Java 21〜）
      └─ 超軽量スレッド（従来のスレッド制限を克服）

```

---

## ✅ 各レイヤーの詳細説明

### 🔷 1. 概念レイヤー（Why?）

| 用語 | 説明 |
| --- | --- |
| **並行処理** | 実行タイミングをずらして複数のタスクを“同時っぽく”進める（論理的） |
| **並列処理** | 複数のCPUコアで物理的に同時実行する（物理的） |

---

### 🔷 2. モデルレイヤー（How?）

| モデル種別 | 説明 |
| --- | --- |
| スレッドモデル | Thread, Runnable, Callable |
| タスクモデル | Executor, ThreadPool, ForkJoin |
| イベント・非同期モデル | CompletableFuture, Callback, Reactor等 |

---

### 🔷 3. 実装/APIレイヤー（What?）

| API / 技術 | 説明 |
| --- | --- |
| `Thread`, `Runnable` | 直接スレッドを立ち上げて処理 |
| `ExecutorService` | スレッドプールによる非同期処理（submit, shutdown等） |
| `ScheduledExecutorService` | タイマー、定期実行処理 |
| `ForkJoinPool` | タスクの自動分割と並列化（Divide and Conquer） |
| `ParallelStream` | Stream API による並列処理（ForkJoinPoolと連携） |
| `CompletableFuture` | 非同期タスク連結、エラーハンドリング |
| `Reactive Streams` | 非同期 + イベント駆動 + backpressure 対応型ストリーム処理 |
| `Virtual Threads` | JDK 21以降の軽量スレッド（スレッド数制限の壁を超える） |

---

## ✅ 実務での選択指針（簡易チャート）

| 目的 | 推奨技術 |
| --- | --- |
| 単純な非同期処理 | `ExecutorService` + `Runnable` |
| タスクをスケジュール実行したい | `ScheduledExecutorService` |
| タスクの並列分割・合成 | `ForkJoinPool` / `ParallelStream` |
| 結果を受け取りつなぎたい | `CompletableFuture` |
| イベント駆動、ストリーム反応型 | `RxJava` / `Project Reactor` |
| 大量スレッド処理が必要 | `Virtual Threads (JDK 21〜)` |

---

## ✅ まとめ

- `Executors` はこの全体構成の **「実装レイヤー」かつ「タスク実行モデル」** に属します。
- 並列・並行処理の全体像を理解するには、**概念→モデル→API** という流れで整理するのが最も有効です。
- 実装の選択は目的とタスク特性（重い/軽い、継続的/単発、戻り値あり/なしなど）に応じて行います。

---

ご希望があれば、これを **図として描画（画像出力）** することも可能です。図版が欲しい場合はお知らせください！

ここでは **Javaにおける並列処理（並行処理／並列処理）**の基本を、初学者〜中級者向けに段階的に整理して解説します。

---

## 🔷 並列処理とは？

### ✅ 並列処理（Parallel processing）とは：

> 複数の処理を同時に実行して、全体の処理時間を短縮する技術
> 

---

## 🔸 並列処理 vs 並行処理（重要）

| 用語 | 意味 | 例 |
| --- | --- | --- |
| **並列処理 (Parallel)** | **複数の処理を物理的に同時実行（CPUコアを分ける）** | 4コアで4つのタスクを同時処理 |
| **並行処理 (Concurrent)** | **複数の処理を論理的に同時実行（1コアで順次切替）** | タスクAとBを交互に実行しているように見せる |

Javaでは一般的に「マルチスレッド」によって**並行処理**が行われ、

`ForkJoinPool` や `parallelStream()` によって**並列処理**が可能になります。

---

## 🔸 Javaにおける並列処理の代表的な手段

| 技術 | 概要 | 主な用途 |
| --- | --- | --- |
| **Threadクラス / Runnableインターフェイス** | スレッドの手動管理 | 基本・学習用途 |
| **Executor / ExecutorService** | スレッドのプール管理 | 実務でよく使う |
| **parallelStream()** | コレクション処理を並列化 | ストリーム処理の高速化 |
| **ForkJoinPool** | 分割統治型の並列処理 | 複雑な再帰的処理 |
| **CompletableFuture** | 非同期処理＋並列実行 | 非同期タスク・API呼び出し等 |

---

## 🔸 基本例：Thread を使った並列処理

```java
public class Main {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            System.out.println("Task A");
        });

        Thread t2 = new Thread(() -> {
            System.out.println("Task B");
        });

        t1.start();
        t2.start();
    }
}
```

- `start()` によって新しいスレッドで処理が開始され、同時実行される可能性があります。
- 順序は保証されません。

---

## 🔸 実用的な並列処理：ExecutorService

```java
import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        Runnable task = () -> System.out.println("Running in thread: " + Thread.currentThread().getName());

        executor.submit(task);
        executor.submit(task);

        executor.shutdown();
    }
}
```

- **スレッドの生成・破棄を自動管理**
- 実務では `newFixedThreadPool()` や `newCachedThreadPool()` を使うことが多いです

---

## 🔸 Stream API との連携：`parallelStream()`

```java
List<String> names = List.of("A", "B", "C", "D");

names.parallelStream().forEach(name -> {
    System.out.println(name + " " + Thread.currentThread().getName());
});
```

- デフォルトで `ForkJoinPool.commonPool()` を使用
- 並列に `forEach` 処理を行う（順序は保証されない）

---

## ✅ 並列処理の注意点

| 注意点 | 説明 |
| --- | --- |
| **同期（synchronization）** | 複数スレッドが同じ変数やリソースにアクセスすると競合が発生するため、制御が必要 |
| **スレッドセーフ** | 並列処理中でも安全に動作する設計（例：`ConcurrentHashMap`など） |
| **例外管理** | 非同期処理中の例外は呼び出し元では捕捉できない場合がある |
| **処理順序** | 並列化すると順序が保証されないケースがある（`forEachOrdered()`で制御可能） |

---

## 🧠 学習ポイントまとめ

| 概念 | 内容 |
| --- | --- |
| 並列 vs 並行 | 論理的 vs 物理的な違いを理解 |
| `Thread` | 手動でスレッドを制御（入門） |
| `ExecutorService` | スレッドプールによる効率的な並列処理 |
| `parallelStream()` | データ処理を並列化して高速化 |
| `ForkJoinPool` | 分割統治アルゴリズム向けの高機能並列処理 |
| `CompletableFuture` | 非同期処理＋並列実行（REST API並列呼び出しなど） |

---

## 🚀 次のステップ提案

- `ExecutorService` の問題（シャットダウン、例外処理など）
- `parallelStream()` の順序性や使い所に関する設問
- 並列処理のパターン問題（Silver/Gold風）
- スレッドセーフ・同期の仕組み（`synchronized` / `ReentrantLock`）

[実務へBridge](%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86%E3%83%BB%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86%2020e62cef735080ce9650c2d41f988425/%E5%AE%9F%E5%8B%99%E3%81%B8Bridge%2021462cef73508025967bde2e6b0d605d.md)