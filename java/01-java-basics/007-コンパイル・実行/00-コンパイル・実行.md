# コンパイル・実行

# Q、

コンパイラが事前に型チェック等を行いクラスファイルに変換、その後必要なクラスファイルをロードしてメモリ管理していく。必要でないクラスファイルは読み込まれない。
という認識はあっていますか？

はい、Hiroakiさんのその認識は**全体として正しい**です。

以下、少しだけ正確さを補足しつつ整理します。

---

### ✅ Hiroakiさんの認識（要点）：

> コンパイル時に型チェックなどが行われ、クラスファイルに変換されるその後、必要なクラスファイルだけがロードされる未使用のクラスファイルは読み込まれない
> 

👉 この3点は**Javaの仕組みに合致しており正しい理解**です。

---

### 🔍 詳細な補足

### ① コンパイル時（Java → バイトコード `.class`）

- `javac` はソースコードの**文法・型チェック**を行い、
    
    問題なければ `.class` ファイル（JVMが実行できるバイトコード）を出力します。
    
- このとき、**依存クラスの存在確認**も行われます（ただし全部をコンパイルはしない）。

### ② 実行時（クラスのロードと実行）

- 実行時には、**必要になったタイミングでクラスがロード**されます。
    - これを **「遅延クラスロード（lazy loading）」** といいます。
- Javaのクラスローダ（ClassLoader）が、必要なクラスを見つけて**メモリに読み込み（ロード）**、**リンク（検証・解決）**し、**初期化**します。

### ③ 使用されないクラスはロードされない

- まさにその通りで、**使われないクラス（importされていても、実際に参照されないものなど）はロードされません**。
- JVMは必要になるまでクラスをロードしない設計です。

---

### 💡 まとめ

| フェーズ | 内容 |
| --- | --- |
| コンパイル時 | 型チェック、バイトコード生成、依存の存在確認 |
| 実行時 | 必要なクラスだけロード（遅延ロード） |
| 未使用クラス | ロードも実行もされない（= メモリに乗らない） |

---

### ❗ 注意点（おまけ）

- 静的初期化子（`static {}`）やクラス変数参照などがあると、**そのタイミングでクラスがロード・初期化**されます。
- `Class.forName("SomeClass")` などの**リフレクションによる明示的なロード**もあります。

---

必要であれば、`ClassLoader`のカスタマイズやJVMのクラスロード戦略（Bootstrap → Extension → Application）なども解説できます！

