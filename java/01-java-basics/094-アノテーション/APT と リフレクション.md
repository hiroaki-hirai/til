# APT と リフレクション

# Q,

APTでも、リフレクションでも、アノテーションの定義で@interfaceでクラスを作成するところまでは違いはない認識ですが、どこから違いができてきますか？
タグ付けの書式は同一ですか？
タグをつけることができるものに違いはありますか？

はい、とてもよい質問です。

Hiroakiさんの認識通り、**APTとリフレクションの違いは「アノテーションの定義」ではなく、「どう使うか（処理タイミング・処理者）」にあります。**

以下に順を追って整理します。

---

## ✅ 結論：APTとリフレクションの違いは「使い方（処理系とタイミング）」

| 観点 | APT（コンパイル時） | リフレクション（実行時） |
| --- | --- | --- |
| アノテーションの定義 | `@interface` を使う。完全に同じ。 |  |
| タグ付けの書式 | 完全に同じ（例：`@MyAnno(value = "x")`） |  |
| タグを付けられる対象 | 基本的には同じ（※） |  |
| 処理のタイミング | コンパイル時（`javac` 実行中） | 実行時（JVM内） |
| 読み取り手段 | `AbstractProcessor` 経由で `Element` を読む | `Class` や `Method` などのリフレクションAPI |
| 処理の目的 | ソースコード生成／構造検査など | 実行制御／DI／動的呼び出しなど |

---

## ✅ 1. アノテーションの定義：**完全に同じ**

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME) // or SOURCE
public @interface MyTag {
    String value();
}
```

- `@interface` で定義
- 属性も同じく抽象メソッド風に記述
- `@Target` や `@Retention` によって対象と有効期間を制御

📌 **ここまでの段階ではAPTもリフレクションも全く違いはありません。**

---

## ✅ 2. タグ付けの書式：**完全に同じ**

```java
@MyTag("hello")
public class Foo { }
```

- クラス、メソッド、フィールド、パッケージなど、**書き方は同じ**
- APTとリフレクションの両方に同じタグが使えます（※ただし Retention に注意）

---

## ✅ 3. タグをつけられる対象：**ほぼ同じ**（だが意図の違いあり）

### 🎯 タグを付けられる構造（共通）

- `@Target` によって指定された以下の構造に付加可能
    
    例：`ElementType.TYPE`, `METHOD`, `FIELD`, `PARAMETER`, `PACKAGE`, `ANNOTATION_TYPE`...
    

✅ **APTでもリフレクションでも、理論上は同じ対象にタグを付けられます。**

---

## ⚠ ただし注意点：`@Retention` による実際の利用可能性に違いが出る

| Retention | APTで使えるか | リフレクションで使えるか | 説明 |
| --- | --- | --- | --- |
| `SOURCE` | ✅ 使える | ❌ 消える（バイトコードに残らない） |  |
| `CLASS` | ❌ 通常読まない | ❌ JVMでも読まれない（bytecodeにあるが無視） |  |
| `RUNTIME` | ❌ 読まない | ✅ `getAnnotation()` などで読める |  |

🔸 **APTでは `SOURCE` が基本**（コンパイル時処理）

🔸 **リフレクションでは `RUNTIME` が必須**（実行時処理）

---

## ✅ 4. 違いの本質：どこから分かれるか？

> 🔸 アノテーション定義までは完全に同じ。違いは、
> 
> - 「いつ処理するか」（コンパイル時 or 実行時）
> - 「誰が処理するか」（Annotation Processor or JVM + リフレクション）

### ◉ その分岐点は：

- **`@Retention(SOURCE)` → APTだけが使える**
- **`@Retention(RUNTIME)` → リフレクションだけが使える**
- **処理系：APTでは `AbstractProcessor`、リフレクションでは `Class#getAnnotation()` など**

---

## ✅ 補足図：アノテーション利用のフロー比較

```java
               [@MyAnno]
                    ↓
    ┌─────────────┬─────────────┐
    │ APT (Processor) │ Reflection (JVM) │
    ├─────────────┼─────────────┤
    │ @Retention(SOURCE) │ @Retention(RUNTIME) │
    │ Javac during compile│ JVM at runtime     │
    └─────────────┴─────────────┘
```

---

## ✅ まとめ

| 比較点 | APT | リフレクション |
| --- | --- | --- |
| アノテーション定義方法 | 同じ（`@interface`） |  |
| タグの書式 | 同じ |  |
| タグの対象 | 同じ（ただし使い方の意図が異なる） |  |
| 違いの本質 | **Retentionと処理タイミング・処理者の違い** |  |

---

ご希望があれば、「APTで定義したアノテーションをリフレクションでも活用できるようにする設計」や、「同じアノテーションを両方の世界で使い回す」高度な設計例も解説できます！