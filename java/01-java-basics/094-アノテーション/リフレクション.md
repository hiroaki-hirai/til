# リフレクション

# Q,

APTやリフレクションで実際に値を読み取って分岐処理するミニサンプルをお願いします

了解しました！

以下に、**APT（アノテーションプロセッサ）とリフレクション**のそれぞれで「アノテーションの値を読み取り、処理を分岐する」ミニサンプルを用意しました。

---

## ✅ 1. リフレクションでアノテーションの値を読み取る（実行時）

### ◉ カスタムアノテーション定義

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Role {
    String value();  // "ADMIN" など
}
```

---

### ◉ アノテーション付きクラス

```java
public class UserService {

    @Role("ADMIN")
    public void deleteUser() {
        System.out.println("Deleting user...");
    }

    @Role("USER")
    public void viewUser() {
        System.out.println("Viewing user...");
    }
}
```

---

### ◉ リフレクションで値を読み取り処理分岐

```java
import java.lang.reflect.Method;

public class AnnotationProcessor {

    public static void main(String[] args) throws Exception {
        UserService service = new UserService();

        for (Method method : UserService.class.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Role.class)) {
                Role role = method.getAnnotation(Role.class);
                String roleValue = role.value();

                if ("ADMIN".equals(roleValue)) {
                    System.out.println("ADMIN権限が必要な処理: " + method.getName());
                } else if ("USER".equals(roleValue)) {
                    System.out.println("USER用処理: " + method.getName());
                }
            }
        }
    }
}
```

---

## ✅ 2. APT（Annotation Processing Tool）でアノテーションの値を読み取る（コンパイル時）

### ◉ カスタムアノテーション定義

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.TYPE)
public @interface GenerateClass {
    String className();
}
```

---

### ◉ アノテーション付きクラス

```java
@GenerateClass(className = "HelloGenerated")
public class MyOriginalClass {
}
```

---

### ◉ APTプロセッサ実装（`javax.annotation.processing.AbstractProcessor`）

```java
import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import java.io.IOException;
import java.io.Writer;
import java.util.Set;

@SupportedAnnotationTypes("GenerateClass")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
public class GenerateClassProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (Element element : roundEnv.getElementsAnnotatedWith(GenerateClass.class)) {
            GenerateClass annotation = element.getAnnotation(GenerateClass.class);
            String className = annotation.className();

            try (Writer writer = processingEnv.getFiler().createSourceFile(className).openWriter()) {
                writer.write("public class " + className + " {\n");
                writer.write("    public static void sayHello() {\n");
                writer.write("        System.out.println(\"Hello from generated class!\");\n");
                writer.write("    }\n");
                writer.write("}\n");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return true;
    }
}
```

📌 このプロセッサを `META-INF/services/javax.annotation.processing.Processor` に登録することで有効になります。

---

## 🔚 補足と結論

| 技術 | タイミング | 処理対象 | 用途例 |
| --- | --- | --- | --- |
| リフレクション | 実行時 | メソッド/フィールド/クラス | DI、バリデーション、ログ処理など |
| APT | コンパイル時 | ソースコード | 自動生成、バリデーション、コードチェック |

---

リフレクションの方が試しやすいですが、APTは静的解析・コード自動生成の分野で強力です。

必要であれば「Lombok風の自動コード生成」や「独自DIの注入処理」などの高度な例もご用意できます。

# Q,

上記解説中、1. リフレクションでアノテーションの値を読み取る（実行時）は、事前にアノテーションと注釈パラメータを渡すための抽象メソッド設定→それぞれのメソッドにタグ付け→そのタグごとに処理を分岐をしている認識です。
このタグ付けは、アノテーションで無くても可能だが、アノテーションであればそのタグを使い回せるといった認識はあっていますか？

はい、非常に本質を突いた捉え方です。

あなたの認識は**概ね正確で、あと少し補足するとより明確になります。**

---

## ✅ あなたの理解の要点と補足

### 🎯 ご認識：

> アノテーションはタグ付けの1つの方法であり、事前に定義したタグ（属性付き）を各メソッドに付けて、後でそれに基づいて処理を分岐する仕組み。
> 
> 
> → このタグ付けは、アノテーションでなくても「できなくはない」。
> 

この認識は**その通りです**。

しかし、アノテーションを使うことには**以下のような大きな利点**があります。

---

## 🔍 アノテーションで「タグ付け」することのメリット

| 観点 | 通常のタグ付け（コメント/命名など） | アノテーションの利用 |
| --- | --- | --- |
| 🔹 **構文的保証** | なし（自由記述） | コンパイルエラーでチェックできる |
| 🔹 **再利用性** | 命名規約の徹底が必要 | 定義1つで全体に使い回せる |
| 🔹 **ツール連携** | IDEやコンパイラでは解釈不可 | IDE補完・静的解析・処理系に対応 |
| 🔹 **メタ情報の構造化** | 難しい（文字列ベース） | 属性付きで構造的に渡せる |
| 🔹 **リフレクション/APTでの処理** | 不可（文字列処理が必要） | `.getAnnotation()` などで直接取得可 |

---

## 🔧 代替手段とアノテーションの優位性

### ◉ 代替手段：命名規約やコメント

```java
// [ADMIN_ONLY]
public void deleteUser() { ... }

if (method.getName().contains("Admin")) {
    // 管理者処理
}
```

→ **できなくはないが、壊れやすく・曖昧**

---

### ◉ アノテーションを使った堅牢な方式

```java
@Role("ADMIN")
public void deleteUser() { ... }

if (method.isAnnotationPresent(Role.class)) {
    String value = method.getAnnotation(Role.class).value();
    // 分岐処理
}
```

→ **明示的・再利用性高・ツール対応・構文的安全**

---

## ✅ 結論：あなたの認識＋補足

> ✅ **「アノテーションは使い回し可能な構造化タグであり、堅牢な再利用・自動処理が可能になる」**というのがポイントです。
> 

つまりこう言えます：

> 🔸「アノテーションは、意味を持つタグを、安全に・再利用可能に・処理可能な形でクラスやメソッドに付けるための第一級の構文的手段である」
> 

---

さらに発展的に理解したい場合は以下も検討できます：

- アノテーションに **enum型やクラス型の属性**を持たせる（構造化されたタグ）
- アノテーションに **デフォルト値**や **複数指定（@Repeatable）** を使う応用
- DIやフレームワークが **アノテーションを読み取ってどのように処理しているか** をトレースする

必要に応じて深掘りもできますので、いつでもどうぞ。