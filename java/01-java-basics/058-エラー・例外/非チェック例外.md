# 非チェック例外

# Q,

RuntimeException とそのサブクラスは非チェック例外ということですがどのような例外があげられますか？

はい、Hiroakiさん。

`RuntimeException` とそのサブクラスは **非チェック例外（unchecked exceptions）** に分類され、**コンパイル時に`try-catch`が強制されない例外**です。

これは「プログラマのミス（ロジック・構文・状態の誤り）」に起因するケースが多く、**事前に防ぐべきもの**として扱われます。

---

# ✅ RuntimeException の主なサブクラス一覧と概要

以下に、実際に現場でよく遭遇する `RuntimeException` のサブクラスを分類してご紹介します。

---

## ① 🔢 **構造・データアクセス系**

| 例外クラス | 内容 |
| --- | --- |
| `NullPointerException` | `null` 参照にアクセスした場合（最も有名） |
| `ArrayIndexOutOfBoundsException` | 配列の範囲外にアクセス |
| `IndexOutOfBoundsException` | Listなどのインデックスアクセスが不正 |
| `StringIndexOutOfBoundsException` | 文字列のインデックス範囲外アクセス |
| `ClassCastException` | 不適切な型変換（キャスト） |
| `NegativeArraySizeException` | 負のサイズで配列を作成しようとした場合 |

---

## ② ⚠️ **不正状態・不正引数系**

| 例外クラス | 内容 |
| --- | --- |
| `IllegalArgumentException` | メソッドに渡された引数が不正 |
| `IllegalStateException` | メソッドを呼ぶべきでない状態で呼び出された |
| `UnsupportedOperationException` | サポートされていない操作を呼び出した場合（例：不変コレクションに add） |
| `SecurityException` | セキュリティマネージャにより操作が拒否された場合 |

---

## ③ 🧮 **演算・計算系**

| 例外クラス | 内容 |
| --- | --- |
| `ArithmeticException` | 算術演算の失敗（例：0による除算） |
| `NumberFormatException` | 文字列から数値への変換が失敗した場合 |

---

## ✅ RuntimeException vs Exception の違いまとめ

| 項目 | `RuntimeException`（非チェック） | `Exception`（チェック） |
| --- | --- | --- |
| 例外の原因 | **開発者のミス・ロジックバグ** | 外部要因・処理の失敗（IO, SQLなど） |
| try-catch の強制 | ❌ なし | ✅ 必須 |
| コンパイルエラー発生 | しない（記述がなくてもコンパイル可） | try-catch または throws が必要 |
| 主な対処法 | **コードの修正・事前条件チェック** | try-catch や エラーハンドリング |

---

## 🔍 開発者としてのスタンス

| 対象 | 推奨対応 |
| --- | --- |
| `RuntimeException` 系 | 原則、**事前チェックやテストで予防** |
| `Exception`（チェック例外） | **catch や throws で明示的に対処** |

---

## ✅ まとめ

- `RuntimeException` は **非チェック例外（unchecked）**
- 多くは **プログラムの不備（ロジックバグや不正状態）**
- よく使う例：`NullPointerException`, `IllegalArgumentException`, `IndexOutOfBoundsException` など
- 原則：**catch で処理するのではなく、コード設計や入力バリデーションで防ぐ**

---

必要であれば、「RuntimeException を安全に防ぐためのチェック項目リスト」や、「業務アプリでのチェック vs 非チェック例外の使い分け基準」もご紹介できます。気になるテーマがあれば教えてください！

# Q,

非チェック例外についての上記解説にで、原則：catch で処理するのではなく、コード設計や入力バリデーションで防ぐ。とありますが、それぞれの非チェック例外をどのようなコード設計やバリデーションで防ぐのでしょうか？

とても良いご質問です、Hiroakiさん。

非チェック例外（`RuntimeException` のサブクラス）は **実行時の「プログラマのミス」によって起こることが多い**ため、catch ではなく「**コード設計や入力バリデーションで未然に防ぐ**」ことが基本戦略です。

---

# ✅ 非チェック例外ごとの防止策：コード設計・バリデーション例

---

## ① `NullPointerException`（NPE）

### ❓ 発生条件

- `null` に対してメソッド呼び出し、フィールドアクセスなどをしたとき

### ✅ 防止方法

| 方法 | 具体例 |
| --- | --- |
| **事前nullチェック** | `if (obj != null) { obj.doSomething(); }` |
| **`Optional`の活用** | `Optional.ofNullable(obj).ifPresent(...)` |
| **コンストラクタやsetterで非nullを強制** | `Objects.requireNonNull(arg, "arg must not be null")` |
| **@NotNullアノテーション（設計時）** | IDEや静的解析で警告が出せるように |

---

## ② `ArrayIndexOutOfBoundsException` / `IndexOutOfBoundsException`

### ❓ 発生条件

- 配列・Listの範囲外にアクセス

### ✅ 防止方法

| 方法 | 具体例 |
| --- | --- |
| **範囲チェック** | `if (index >= 0 && index < array.length)` |
| **List APIのサイズ確認** | `if (index < list.size())` |
| **拡張for文やStreamを活用** | `for (String s : list)` などでインデックスを明示的に使わない |

---

## ③ `ClassCastException`

### ❓ 発生条件

- 不正なダウンキャスト（例：`Object obj = "abc"; Integer i = (Integer)obj;`）

### ✅ 防止方法

| 方法 | 具体例 |
| --- | --- |
| **`instanceof`チェック** | `if (obj instanceof Integer) { Integer i = (Integer) obj; }` |
| **ジェネリクスで型安全設計** | `List<String>` などで明示的に型を制限する |
| **型を明示したAPI設計** | 引数や戻り値に具体的な型を使う（Objectより型引数や具象型を使う） |

---

## ④ `IllegalArgumentException`

### ❓ 発生条件

- メソッド引数が不正（null, 範囲外, 未対応値など）

### ✅ 防止方法

| 方法 | 具体例 |
| --- | --- |
| **引数チェック** | `if (age < 0) throw new IllegalArgumentException("年齢は0以上");` |
| **`Objects.requireNonNull()`** | 非null制約を明示的に |
| **ドメイン制約に応じた独自型** | 例：`Age`クラスを使って不正な数値を防ぐ |

---

## ⑤ `IllegalStateException`

### ❓ 発生条件

- オブジェクトの内部状態が無効なときに操作を行った

### ✅ 防止方法

| 方法 | 具体例 |
| --- | --- |
| **状態遷移の明確化** | `if (!isReady()) throw new IllegalStateException(...)` |
| **状態を管理するEnumなどで制御** | `State.READY` のときだけ処理可能などのガード |
| **状態の変更メソッドを制限** | インスタンス生成後の状態変化を減らす（イミュータブル化など） |

---

## ⑥ `UnsupportedOperationException`

### ❓ 発生条件

- 対応していない操作を呼び出した（例：固定リストに add）

### ✅ 防止方法

| 方法 | 具体例 |
| --- | --- |
| **不変のコレクションと明示的なドキュメント** | `Collections.unmodifiableList()` を返すが、ドキュメントで明記 |
| **インタフェースで実装制限を設計段階で表現** | サポートされる操作だけを公開するAPI設計 |

---

## ⑦ `ArithmeticException`

### ❓ 発生条件

- 0による除算など、数学的に無効な操作

### ✅ 防止方法

| 方法 | 具体例 |
| --- | --- |
| **除数チェック** | `if (denominator != 0) { int result = num / denominator; }` |
| **事前にバリデーション** | 入力値のチェック、例：フォームやUIで入力制限をかける |

---

## ⑧ `NumberFormatException`

### ❓ 発生条件

- 文字列から数値への変換失敗（例：`"abc"` を `Integer.parseInt()`）

### ✅ 防止方法

| 方法 | 具体例 |
| --- | --- |
| **正規表現や `matches()` で数字形式を検証** | `"123".matches("\\d+")` |
| **入力のフィルタリング（UIやAPI側で）** | 数値以外は受け付けないよう制限 |
| **例外をcatchして代替処理も可** | `try { parseInt(...) } catch (NumberFormatException e) { ... }`（代替値設定など） |

---

## 🔁 共通設計戦略として有効なアプローチ

| 戦略 | 内容 |
| --- | --- |
| **防御的プログラミング** | 入力チェック・状態チェックで早めにエラーを検知 |
| **イミュータブル設計** | 状態の変更を抑え、`IllegalStateException` を防止 |
| **引数オブジェクト化** | 単純な値渡しよりも、バリデーション済みのオブジェクトを使う |
| **API制約の明文化** | JavaDocやアノテーションで使用条件を明示 |

---

## ✅ まとめ

| 非チェック例外 | 主な防止策 |
| --- | --- |
| `NullPointerException` | nullチェック、Optional、requireNonNull |
| `IndexOutOfBounds`系 | 範囲チェック、サイズ確認、拡張for文使用 |
| `IllegalArgument` | バリデーション、前提条件チェック |
| `IllegalState` | 状態確認メソッド、状態設計の明確化 |
| `ClassCastException` | instanceof、ジェネリクス、型安全設計 |
| `ArithmeticException` | 0除算チェック |
| `NumberFormatException` | 入力検証、正規表現チェック |

---

このように、**非チェック例外は「catch で対応するものではなく、そもそも起きないようにする設計」が最も重要**です。

ご希望であれば、実践的な「チェックリスト形式のレビュー用資料」や「現場で使われるガードコード集」などもご提供できます。興味ありますか？

# Q,

「現場で使われるガードコード集」をお願いします

承知しました、Hiroakiさん。

ここでは、**Javaの現場で実際によく使われる「ガードコード（前提条件チェック）」の典型パターン**を、**目的別に整理した「ガードコード集」**としてご紹介します。

---

# ✅ 現場で使われるガードコード集（前提条件チェック）

---

## 🟦 1. Nullチェック（NullPointerException防止）

```java
// Java標準
Objects.requireNonNull(arg, "arg must not be null");

// Optional利用で null 回避
Optional.ofNullable(arg).orElseThrow(() -> new IllegalArgumentException("nullは禁止"));
```

### 🔍 よく使う場面：

- コンストラクタやsetterでのチェック
- 外部から受け取る入力（API・フォーム）

---

## 🟨 2. 空文字・空コレクションのチェック

```java
if (str == null || str.isEmpty()) {
    throw new IllegalArgumentException("文字列は空ではいけません");
}

if (list == null || list.isEmpty()) {
    throw new IllegalArgumentException("リストは空ではいけません");
}
```

### 🔍 よく使う場面：

- IDや検索キー、ユーザー入力の検証
- コレクションが処理対象である前提の場合

---

## 🟥 3. インデックス・範囲チェック（IndexOutOfBounds対策）

```java
if (index < 0 || index >= list.size()) {
    throw new IndexOutOfBoundsException("インデックスが無効です: " + index);
}
```

### 🔍 よく使う場面：

- 配列・リストのアクセス前
- スライスやページング処理の範囲確認

---

## 🟩 4. 数値の制約チェック（負数・ゼロ除算・範囲制約）

```java
if (price < 0) {
    throw new IllegalArgumentException("価格は0以上でなければなりません");
}

if (denominator == 0) {
    throw new ArithmeticException("0で除算できません");
}

if (score < 0 || score > 100) {
    throw new IllegalArgumentException("スコアは0〜100の範囲で指定してください");
}
```

### 🔍 よく使う場面：

- 年齢、スコア、金額、割り算、割合などの業務ルール制約

---

## 🟪 5. 状態チェック（IllegalStateException対策）

```java
if (!isReady) {
    throw new IllegalStateException("処理可能な状態ではありません");
}
```

```java
if (resource.isClosed()) {
    throw new IllegalStateException("クローズ済みのリソースを再利用しようとしています");
}
```

### 🔍 よく使う場面：

- ライフサイクル制御、状態遷移管理
- 再初期化や未初期化エラーの回避

---

## 🟫 6. 型チェック（ClassCastException対策）

```java
if (!(obj instanceof String)) {
    throw new ClassCastException("String型にキャストできません");
}
String value = (String) obj;
```

```java
// ジェネリクスによる型安全な設計を推奨
List<String> names = new ArrayList<>(); // 安全
```

### 🔍 よく使う場面：

- 汎用API、コレクション、Object型からの復元

---

## ⚙️ 7. サポートされない操作チェック（UnsupportedOperationException対策）

```java
if (!supportedTypes.contains(inputType)) {
    throw new UnsupportedOperationException("この型はサポートされていません: " + inputType);
}
```

### 🔍 よく使う場面：

- 複数の条件分岐（戦略パターンなど）での型制限
- 固定された操作だけを許すAPI設計

---

## 💡 8. 独自ユーティリティとしてのまとめ例

```java
public class Guard {
    public static <T> T notNull(T value, String message) {
        return Objects.requireNonNull(value, message);
    }

    public static void notEmpty(String value, String message) {
        if (value == null || value.trim().isEmpty()) {
            throw new IllegalArgumentException(message);
        }
    }

    public static void checkRange(int value, int min, int max, String message) {
        if (value < min || value > max) {
            throw new IllegalArgumentException(message);
        }
    }
}
```

### ✅ 使用例：

```java
Guard.notNull(name, "name must not be null");
Guard.notEmpty(email, "email is required");
Guard.checkRange(age, 0, 120, "invalid age");
```

---

## ✅ まとめ：ガードコードの導入効果

| 効果 | 内容 |
| --- | --- |
| 🔐 不正データの侵入防止 | 上流で不正値をブロック |
| 🧠 バグの早期発見 | 「前提条件を明示」することでテストも簡潔に |
| 📄 ドキュメント代わりになる | ガード条件が API の契約を表している |
| 🧼 コードの意図が明確になる | 「どこで失敗するのか」が読みやすくなる |

---

必要であれば「ドメイン別ガードコード（例：年齢・金額・ステータス）集」や、「独自例外との組み合わせ」もご紹介できます。

どのような領域で使いたいか教えていただければ、より現場に即した内容にも対応可能です！