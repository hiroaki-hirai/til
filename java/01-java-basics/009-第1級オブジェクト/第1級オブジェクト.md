# 第1級オブジェクト

# Q,

変数や引数に代入できるものとして第1級オブジェクトがあり、その中に関数オブジェクトがあります。
関数オブジェクトの内容は大体把握しているのですが、なぜ、処理は直接、変数や引数へ代入できないのでしょうか？

とても本質的な質問ですね、Hiroakiさん。

これは**「処理（実行）」と「データ（値）」の区別**という、プログラミング言語設計の根本に関わる話です。

---

## ✅ 結論から言うと：

> 処理（＝実行結果）そのものは “一瞬で消えてしまう動作” なので、
> 
> 
> **代入できるのは処理の“結果”または“参照可能なもの（関数オブジェクト）”に限られるから**です。
> 

---

## 🔍 用語の整理

| 用語 | 説明 |
| --- | --- |
| **第1級オブジェクト（first-class object）** | 変数に代入できる、引数として渡せる、戻り値にできるなど「値として自由に扱えるもの」 |
| **関数オブジェクト / 関数（function object）** | 関数をオブジェクトのように扱えるもの（Javaのラムダ式やメソッド参照） |
| **処理（execution）** | 実行されて“その場で完了”する行動。戻り値がある場合も、それは結果であり処理自体ではない |

---

## 🔸なぜ「処理」は直接代入できないのか？

処理とは、例えば：

```java
System.out.println("Hello");
```

このようなコードの「`println("Hello")`」部分は：

- **実行されると即座に終了する**
- **値ではなく「効果（副作用）」を発生させる**
- 実行そのものには“名前”も“参照”もない

つまり、「**今この瞬間の動き**」なので、**メモリ上のどこかに格納して再利用する“実体”がない**のです。

---

## ✅ では、関数オブジェクトはなぜ代入できるのか？

関数オブジェクト（例：Javaのラムダ式）は「**実行されていない状態の処理の塊**」であり：

- 変数に代入できる
- 実行したいときに `.apply(...)` や `.run()` などで動かせる
- メモリ上に保持されている

```java
Runnable r = () -> System.out.println("Hello");  // ← これは処理を“代入”している
r.run(); // ← この時点で実行
```

ここでは「**処理の設計図＝関数オブジェクト**」が代入されているので問題ない、ということです。

---

## ✅ 例：代入できる vs できない

| 種類 | 例 | 代入できるか？ | 理由 |
| --- | --- | --- | --- |
| 実行済みの処理 | `System.out.println("Hi")` | ❌ | 実行された時点で結果が消える／値を返さない |
| 戻り値のある処理 | `int x = sum(1, 2);` | ✅ | `sum(1, 2)` は値（int）を返す |
| 関数オブジェクト | `Function<Integer, Integer> f = x -> x * 2;` | ✅ | 処理の定義をオブジェクトとして保持している |

---

## 🔸補足：Javaは関数型ではない

- Javaは「手続き型＋オブジェクト指向」がベース
- 関数を「値」として扱えるようになったのは、Java 8からラムダ式・関数型インタフェースが導入された以降
- それまでは「関数＝クラスのメソッド」であり、**“処理をオブジェクトとして代入”という考えが無かった**

---

## ✅ まとめ（Hiroakiさんの疑問への答え）

> 🔹 処理（execution）は一瞬で終わる動作なので、代入できない
> 
> 
> 🔹 **代入できるのは、「処理を定義したもの」（＝関数オブジェクト）や、「処理の結果」（＝戻り値）だけ**
> 
> 🔹 代入には「実体として存在しているもの」が必要（関数オブジェクトはそのための表現手段）
> 

---

この話、**「関数型プログラミング」や「第一級関数 vs 高階関数」**の理解にもつながっていきます。

もしご興味があれば、そこにも発展できますよ！

# Q,

第1級オブジェクトは、それぞれメモリ管理ではどこに保管されますか？
Heap領域でしょうか？

はい、Hiroakiさんの問いに対する**短い答え**は：

> ✅ 第1級オブジェクトは、基本的に「ヒープ（Heap）領域」に格納されます。
> 

ただし、**すべてがヒープに行くわけではなく、Javaのメモリ管理では状況によって異なる領域が使われます。**

以下に詳しく整理します。

---

## ✅ Javaメモリ構造の全体像（簡略）

| 領域 | 説明 |
| --- | --- |
| **Heap** | インスタンス（オブジェクト）や配列など「動的に生成されたデータ」が格納される。第1級オブジェクトの本体はここ。 |
| **Stack** | メソッドの呼び出しごとの**一時的なスコープの変数や参照**（＝変数名など）が格納される。 |
| **Method Area（＝MetaSpace）** | クラス情報、定数プール、staticフィールドなど |
| **PC Register / Native Stack** | JVMの内部処理用。通常のアプリケーションレベルでは意識しない。 |

---

## 🔍 第1級オブジェクトの格納イメージ

### 例 1：文字列オブジェクト（明示的に作成）

```java
String s = new String("hello");
```

- `"hello"` リテラル → Stringプール（メソッド領域の一部）に
- `new String(...)` によって生成されたオブジェクト → **Heap領域**
- `s` という参照変数 → **Stack領域**

---

### 例 2：ラムダ式や関数オブジェクト

```java
Runnable r = () -> System.out.println("run!");
```

- `() -> ...` で作成された関数オブジェクト → **Heapに格納**
- `r`（変数） → **Stackに置かれる参照**

---

## ✅ なぜ Heap に置かれるのか？

> 「第1級オブジェクト」＝変数に代入可能で、引数に渡せて、戻り値にできるということは、スコープを超えて生き残る可能性があるということ。
> 

つまり：

- メソッドが終わってもオブジェクトが生きている必要がある
- それを可能にするには、**Stack（スコープごとに破棄）ではなく、Heap（GC管理される領域）に置く必要がある**

---

## ✅ 補足：プリミティブ型は？

```java
int x = 10;
```

- `x` の値（10）は **Stack領域** に格納される（基本型なのでオブジェクトではない）
- ただし、**ラッパークラス `Integer x = 10;` のように書くと、Heap上に `Integer` オブジェクトが生成**される（場合により最適化も入る）

---

## ✅ まとめ：第1級オブジェクトとメモリの関係

| 要素 | Heap | Stack | 備考 |
| --- | --- | --- | --- |
| 関数オブジェクト（ラムダなど） | ✅ | ⛔️ | 実体はHeap、参照はStackに乗る |
| 通常のオブジェクト | ✅ | ⛔️ | 例：`new User(...)` など |
| 参照変数（`obj`, `str`など） | ⛔️ | ✅ | Stack上の変数として保持 |
| プリミティブ変数（int, booleanなど） | ⛔️ | ✅ | 値そのものがStack上に存在 |

---

Hiroakiさんの「メモリモデルへの着目」は非常に実践的で、**GC・パフォーマンス・マルチスレッド**などにもつながっていきます。

もし興味があれば、**オブジェクトのライフサイクル**や**GCの観察ツール（VisualVMなど）**の使い方にも触れていけますよ。