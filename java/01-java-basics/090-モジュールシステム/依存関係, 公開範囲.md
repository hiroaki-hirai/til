# 依存関係, 公開範囲

# Q,

依存関係と公開範囲の明示は、モジュール単位で行うものでしょうか？

はい、その通りです。

**依存関係と公開範囲の明示は、モジュール単位で行います。**

---

## 🔷 詳しく解説すると：

### ✅ モジュール単位で依存関係を定義する（`requires`）

- 各モジュールは、自分が**使いたい他モジュール**を `requires` で明示します。
- これは**パッケージ単位やクラス単位ではありません**。

```java
module com.example.myapp {
    requires java.sql; // ← モジュール単位の依存
}
```

👉 `com.example.myapp` モジュールは `java.sql` モジュール全体に依存します。

---

### ✅ モジュール単位で公開範囲を定義する（`exports`）

- 自分のモジュール内の**どのパッケージを外部に公開するか**を指定します。
- **パッケージ単位で公開・非公開を制御**します（クラス単位ではない）。

```java
module com.example.myapp {
    exports com.example.myapp.service;
}
```

👉 `com.example.myapp.service` パッケージだけが他のモジュールから利用可能になります。

それ以外のパッケージ（例：`com.example.myapp.internal` など）はデフォルトで非公開です。

---

## 🔸 まとめ：モジュール単位での制御

| 項目 | 制御単位 | 意味 |
| --- | --- | --- |
| `requires` | **モジュール単位** | 他モジュールに依存することを宣言 |
| `exports` | **パッケージ単位** | 外部に公開する API パッケージを選択 |
| `opens` | **パッケージ単位** | リフレクションアクセス（主にフレームワーク向け） |

---

## ❗ 注意点

- **クラス単位での公開/非公開制御はできません。**
    - 例：`exports com.example.myapp.service.MyClass;` のような指定はできません。
- `exports` されていないパッケージのクラスは、他モジュールから**参照できません（コンパイルエラー）**。
- `requires` を書かないと、依存先のモジュールのクラスを**インポートしても使えません**。

---

## ✅ 結論

> 依存関係（requires）と公開範囲（exports）は、モジュール単位で宣言・制御します。
> 
> 
> 公開の細かい単位は「**パッケージ単位**」まで。**クラス単位では制御しません。**
> 

---

さらに「どのように段階的に設計すればよいか」や「ベストプラクティス」も必要であれば解説できます！

# Q,

依存関係（requires）と公開範囲（exports）を使用するとどのような制御ができますか？
具体的なコード例で示してください。

はい、`requires`（依存関係）と `exports`（公開範囲）を使うことで、**モジュール同士の依存やアクセス可能範囲を明示的に制御**できます。

以下に **具体的なコード例** を交えて詳しく解説します。

---

## 🔷 構成例：2つのモジュール

```java
app/
├── module-a/
│   ├── module-info.java
│   └── com.example.a/
│       └── HelloService.java
├── module-b/
│   ├── module-info.java
│   └── com.example.b/
│       └── AppMain.java
```

---

## ✅ モジュールA（サービス提供側）

### 📄 module-a/module-info.java

```java
module module.a {
    exports com.example.a; // 公開するパッケージを明示
}
```

### 📄 com/example/a/HelloService.java

```java
package com.example.a;

public class HelloService {
    public void sayHello() {
        System.out.println("Hello from Module A!");
    }
}
```

---

## ✅ モジュールB（利用側）

### 📄 module-b/module-info.java

```java
module module.b {
    requires module.a; // モジュールAに依存
}
```

### 📄 com/example/b/AppMain.java

```java
package com.example.b;

import com.example.a.HelloService;

public class AppMain {
    public static void main(String[] args) {
        HelloService service = new HelloService();
        service.sayHello();
    }
}
```

---

## 🔍 どんな制御がされているか？

| 機能 | どこで定義 | 効果 |
| --- | --- | --- |
| `requires` | `module.b` が `module.a` を明示的に要求 | `module.b` は `module.a` の公開APIにアクセスできるようになる |
| `exports` | `module.a` が `com.example.a` を公開 | `module.b` など他モジュールが `HelloService` にアクセス可能に |

---

## ❌ もし制御をしなかったら？

### 1. `module.a` が `exports` を省略すると…

```java
module module.a {
    // exports なし
}
```

🔴 結果：`HelloService` を他モジュールから使おうとすると**コンパイルエラー**になります。

---

### 2. `module.b` が `requires` を省略すると…

```java
module module.b {
    // requires module.a; を書き忘れる
}
```

🔴 結果：`com.example.a.HelloService` を `import` しても**コンパイルエラー**になります。

---

## ✅ まとめ：できる制御

| 機能 | 具体的にできること |
| --- | --- |
| `requires` | 他モジュールへの依存を宣言し、アクセスを許可 |
| `exports` | 公開したいパッケージだけ外部モジュールからアクセス可能にする |
| `exports` を省略 | 内部APIを完全にカプセル化（外部からアクセスできない） |
| `opens`（参考） | リフレクションによるアクセスを特定モジュールに許可 |

---

必要であれば、`opens` や `provides` / `uses` を使ったサービスローダーパターンの例も紹介できます。

モジュールベースで設計したい場合や、セキュリティを重視する場合に特に有効です。ご希望があれば続けます！

# Q,

別のモジュールからアクセスしようとした場合、exports と requires の両方が必要になる認識ですが、exports のみの場合にアクセスできる範囲と、＋requiresの場合にアクセスできる範囲は違うということでしょうか？

非常に鋭いご質問です。

はい、Hiroakiさんの理解は本質的に正しいです。

ただし、少し整理しておくと、次のように言えます：

---

## ✅ 端的に言うと：

- *`exports` は「自分のモジュールが外に公開する範囲」**の指定です。
- *`requires` は「他のモジュールにアクセスするための許可」**を自分で出す宣言です。

---

## 🔍 両者の関係：**「出す側」と「受け取る側」の合意**

| 役割 | 機能 | 意味 |
| --- | --- | --- |
| **exports** | 「出す側の合意」 | モジュールAが「このパッケージは他のモジュールに見せていい」と決める |
| **requires** | 「受け取る側の意思」 | モジュールBが「モジュールAのAPIを使いたい」と宣言する |

### → **両方が成立して、初めて他モジュールからアクセス可能**になります。

---

## ✅ ケース比較：アクセスできるか？

| `module-a` の `exports` | `module-b` の `requires module.a` | アクセスできる？ | 理由 |
| --- | --- | --- | --- |
| ❌ なし | ✅ あり | ❌ | 見せていないのでアクセス不可 |
| ✅ あり | ❌ なし | ❌ | 見せていても、見に行こうとしないのでアクセス不可 |
| ✅ あり | ✅ あり | ✅ | 双方の合意があるのでアクセス可能 |

---

## 🔸 `exports` のみでは何ができるのか？

他モジュールが **`requires` を使わない限り、`exports` の効果は発揮されません。**

つまり、**「見る側が来ないなら、出しても意味がない」**という状態です。

逆に、**自分のモジュール内で使うだけなら `exports` は不要**です（内部利用のため）。

---

## 🔍 例で確認

### モジュールA（公開する側）

```java
module module.a {
    exports com.example.a;
}
```

### モジュールB（使う側）

```java
module module.b {
    // requires module.a; ← 書かないと HelloService は使えない
}
```

🔴 `module.b` が `requires module.a;` を書かない限り、

```java
import com.example.a.HelloService; // ← コンパイルエラー
```

---

## ✅ まとめ

| 視点 | `exports` のみ | `exports` + `requires` |
| --- | --- | --- |
| アクセス可能範囲 | 他モジュールからはアクセス不可 | 他モジュールからパッケージ内のクラスにアクセス可能 |
| モジュールの目的 | 出す準備をしているだけ | 出して、他のモジュールに実際に使ってもらえる |
| 使い道 | 自分の設計内で整理したい場合 | 外部ライブラリ化・モジュール間連携が必要なとき |

---

ご希望があれば、次のようなトピックも補足できます：

- Spring や Maven プロジェクトでこの制御がどう使われているか
- `opens` の制御との違い（リフレクション許可との関係）

お気軽にどうぞ！