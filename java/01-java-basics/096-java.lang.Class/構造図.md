# 構造図

# Q,

この Class オブジェクトとJVM内部メタデータの構造図 を描いて、

どこに何があり、いつ生成され、どこで解放されるか（クラスローダの破棄時）
まで説明してください。

では、`java.lang.Class<T>` オブジェクトと JVM 内部のメタデータの関係を図解して、

**どこに何があるか / いつ生成されるか / どこで解放されるか** を整理します。

---

## 1. 構造図

```java
[Javaヒープ]                           [JVM内部ネイティブ領域: メタスペース(Metaspace)]
──────────────────────────────────────────────────────────────────
 java.lang.Class<T> オブジェクト      ←───┐
 (ヒープ上の普通のJavaオブジェクト)       │   ┌───> 定数プール (Constant Pool)
 ├─ クラス名 (String)                     │   │
 ├─ 修飾子情報 (int flags)                │   ├───> フィールドテーブル
 ├─ スーパークラスへの参照 (Class<?>)      │   │
 ├─ インタフェースへの参照 (Class<?>[])    │   ├───> メソッドテーブル
 ├─ ClassLoaderへの参照                    │   │
 └─ 「nativeデータ構造」へのポインタ ──────┘   ├───> アノテーション情報
                                              └───> 依存型情報 など
```

- **Javaヒープ側**
    - `Class<T>` オブジェクトはあくまで **Javaコードから操作するための窓口**
    - メタデータ全部を中に持っているわけではなく、**ネイティブ領域の構造体へのポインタ**を持つ
- **メタスペース（Metaspace）側**
    - JVM がネイティブメモリ上に確保するクラス情報領域（Java 8以降はPermGen廃止→Metaspaceへ）
    - 定数プール、フィールド・メソッド定義、型チェック用情報、バイトコードなどが入っている
    - ClassLoader単位で管理される

---

## 2. いつ生成されるか

1. **クラスロード要求発生**
    - 初回アクセス時（`new` / `static`アクセス / `Class.forName` / `<型>.class` など）
    - JVM がそのクラスをまだロードしていなければ ClassLoader にロード要求を出す
2. **ロード & リンク & 初期化**
    - ロード：バイトコードを読み込む
    - リンク：検証（Verify）、準備（静的フィールドメモリ確保）、解決（シンボル解決）
    - 初期化：`static { ... }` 初期化子実行
3. **生成されるもの**
    - **Metaspace** にクラスメタデータ構造を作成
    - **Javaヒープ**に対応する `Class<T>` オブジェクトを1つだけ生成
        
        （これが `<型>.class` や `obj.getClass()` が返す同一参照）
        

---

## 3. どこで解放されるか

- **条件**：そのクラスをロードした **クラスローダーがガベージコレクトされるとき**
    - クラスローダと、そこからロードされたクラスの `Class` オブジェクト、およびMetaspace内メタデータがまとめて解放される
    - アプリケーション終了時は通常全て解放
    - クラスローダを使い捨てると動的なアンロードも可能（OSGi・Webアプリ再デプロイなど）
- **解放されないケース（リーク原因）**
    - クラスローダの参照がどこかに残っている
    - 静的フィールドに大きなオブジェクトを保持し続けている
    - ネイティブコードやスレッドローカルがクラスローダを保持している

---

## 4. タイムラインまとめ

```java
[ロード要求発生] → [Metaspaceにメタデータ作成] → [JavaヒープにClassオブジェクト作成]
    ↓
  利用（リフレクション・インスタンス生成など）
    ↓
[クラスローダ参照が消える] → [GCでClassオブジェクト消去 & Metaspace解放]
```

---

## 5. ポイントまとめ

- **`Class<T>`オブジェクトはヒープにあり、JVM内部メタデータ（Metaspace）を参照している**
- **生成はクラスロード時に1回だけ**
- **解放はクラスローダごと**
- 同じクラスは常に同一の`Class<T>`参照（`==`がtrue）

---

もし希望あれば、この流れを**クラスローダのアンロード可否チェック付きの動作確認コード**として作れます。

実際にClassオブジェクトがGCされる様子をVisualVMで観察できるサンプルも用意できます。