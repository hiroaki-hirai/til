# 下限上限境界ワイルドカード

# Q,

```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper)
```

Fanction<入力の型(引数), 出力の型(戻り値)> であることは把握していますが、<? super T, ? extends R>といった表記になっていることについて解説してください。

素晴らしい視点です！

`map(Function<? super T, ? extends R> mapper)` のように、**ジェネリクスにおけるワイルドカード（`? super T`, `? extends R`）が指定されている理由**は、Java の**型安全性と柔軟性の両立**のためです。

---

## ✅ まず前提：`Function<T, R>` の役割

- `Function<T, R>` は、
    - 引数：`T` 型の値
    - 戻り値：`R` 型の値
- つまり、`T → R` へのマッピング関数

---

## ✅ では、なぜ `Function<? super T, ? extends R>` なのか？

### ▶ `? super T`（下限ワイルドカード）

- **引数の型に対して**：
    
    `Function` の `apply(T t)` メソッドに `T` を渡すため、
    

```java
T t = ...;
f.apply(t); // T を引数に渡せる必要あり
```

- ここで `Function<? super T, ?>` にしておくと：
    - `T` のスーパークラス（例えば `Object` や `Number`）を引数として受け取る `Function` も使用可能に！
    - → より柔軟に使える（下限ワイルドカード）

---

### ▶ `? extends R`（上限ワイルドカード）

- **戻り値の型に対して**：
    
    `map()` の戻り値は `Stream<R>` 型になるので、
    

```java
R result = f.apply(t);
```

- ここで `Function<?, ? extends R>` にしておくと：
    - `R` を返す関数だけでなく、`R` のサブクラス（例えば `String`）を返す関数も OK
    - → より広い型の関数を許容（上限ワイルドカード）

---

## ✅ まとめ：なぜこう書くのか？

| 記述 | 意味 | 目的 |
| --- | --- | --- |
| `? super T` | T の親クラスでもよい | 引数に使える型の幅を広げる |
| `? extends R` | R のサブクラスでもよい | 戻り値の型の柔軟性を持たせる |
| `Function<? super T, ? extends R>` | T を受け取り R を返す関数なら、それに近い範囲も許容 | 柔軟で型安全な設計 |

---

## ✅ 実例で比較

```java
List<Integer> list = List.of(1, 2, 3);

// Function<Number, String> も許容される
Function<Number, String> func = n -> "値は " + n;

Stream<String> result = list.stream().map(func); // OK!
```

- `list.stream()` は `Stream<Integer>`
- `Function<Number, String>` は `Function<? super Integer, ? extends String>` に合致
    - `Number` は `Integer` の親クラス → `? super T` に合う
    - `String` は `String` のサブクラス → `? extends R` に合う

---

## ✅ 補足：ワイルドカードの使い分け

| ワイルドカード | 意味 | 主な使いどころ |
| --- | --- | --- |
| `? extends T` | T のサブクラスすべて | **読み出し専用**（get）で安全 |
| `? super T` | T のスーパークラスすべて | **書き込み専用**（put）で安全 |

> 暗記フレーズ：PECS
> 
> 
> **Producer Extends, Consumer Super**
> 
> → 生産する（返す）なら `extends`、消費する（受け取る）なら `super`
> 

---

ご希望であれば、実際に `? extends` / `? super` の使い分けが必要になるケース（例：コレクションに add できない例など）も紹介できます！

# Q,

実際に ? extends / ? super の使い分けが必要になるケースをお願いします。

はい、`? extends` と `? super` の違いが**明確に現れる代表的なケース**は、Javaの**コレクションに対して「読み出し専用」か「書き込み専用」か**という場面です。

この違いを見せるのに最適な例が、**リストへの要素の `add()` と `get()`** です。

---

## ✅ まず結論：PECS 原則

> PECS = "Producer Extends, Consumer Super"
> 

| ワイルドカード | 主な用途 | 追加（add） | 取得（get） |
| --- | --- | --- | --- |
| `? extends T` | 生産者（producer） | ❌ 禁止 | ✅ 安全に使える |
| `? super T` | 消費者（consumer） | ✅ 安全に使える | ⛔ 型が限定できず扱いにくい |

---

## 🔍 例1：`? extends T`（読み出し専用のリスト）

```java
List<? extends Number> numbers = List.of(1, 2.0, 3L);

Number n = numbers.get(0); // ✅ 読み出しは可能
// numbers.add(4);         // ❌ コンパイルエラー（理由は後述）
```

### ❌ `add()` できない理由：

- `? extends Number` は、`Integer`, `Double`, `Long`, ... のどれかかもしれない。
- どの型のリストかコンパイラは特定できない。
- よって、**何を追加しても型安全性が保証できない → 禁止**。

---

## 🔍 例2：`? super T`（書き込み専用のリスト）

```java
List<? super Integer> list = new ArrayList<Number>();

list.add(123);          // ✅ 安全に追加できる
list.add(456);          // ✅ OK
// Integer x = list.get(0); // ❌ コンパイルエラー
Object x = list.get(0);    // ✅ get() は Object 型になる
```

### ❌ `get()` できない理由：

- `? super Integer` には、`Integer`, `Number`, `Object` などが来る可能性がある。
- コンパイラは**戻り値の型を特定できない**ので、`Object` としか扱えない。

---

## 🧠 イメージ図

```java
Number型を中心にした階層
Object
  └─ Number
        ├─ Integer
        ├─ Double
        └─ Long
```

- `? extends Number`：`Integer`, `Double`, `Long` など「Numberのサブクラス」→ 読み出しOK、追加NG
- `? super Integer`：`Integer`, `Number`, `Object` など「Integerのスーパークラス」→ 書き込みOK、取得NG

---

## ✅ まとめ：使い分け早見表

| 利用目的 | 推奨ワイルドカード | 解説 |
| --- | --- | --- |
| 要素を取り出したい（get） | `? extends T` | サブタイプとして安全に読み出せる |
| 要素を追加したい（add） | `? super T` | スーパークラスとして安全に追加できる |

---

## ✅ 実務的な例：コレクションのコピー

```java
public static <T> void copy(List<? super T> dst, List<? extends T> src) {
    for (T t : src) {
        dst.add(t);
    }
}
```

- `src` は **生産者** → `? extends T`
- `dst` は **消費者** → `? super T`

まさに **PECS原則の典型的な応用例**です。

---

必要であれば、「型推論が関わるとどうなるか」や「ワイルドカードを使わずに済む構造」についても説明できます！

# Q,

```java
<R> Stream<R> map(Function<? extends T, ? super R> mapper)
```

上記のように、仮に引数と戻り値の型のワイルドカードの設定を変えると問題でしょうか？

とても良い視点です。

結論からいうと：

---

## ❌ `map(Function<? extends T, ? super R>)` のような宣言は不適切で、**型安全性や動作の期待に合いません**。

---

## ✅ 正しい宣言のおさらい

```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper)
```

この形式は、「**T を入力として受け取り、R またはそのサブ型を返す関数**」を渡せるようにしたものです。

---

## 🔍 仮にこうしたら？：`Function<? extends T, ? super R>`

```java
<R> Stream<R> map(Function<? extends T, ? super R> mapper)
```

この宣言にすると何が問題か、以下の2点から考えます。

---

## ① 引数：`? extends T`（引数が T のサブ型）

```java
Function<? extends T, ...>
```

- これは「Tのサブクラスしか受け取れない」ことを意味します。
- しかし `map()` の内部で渡す値は `T` 自体であり、**T がそのサブクラスかどうかは分からない**。
- → `apply(T)` を安全に呼び出せなくなるため **不適切**。

---

## ② 戻り値：`? super R`（戻り値が R のスーパークラス）

```java
Function<..., ? super R>
```

- これは「戻り値が R か、その親クラス」も許容するという意味です。
- でも、`map()` の戻り値は `Stream<R>` として定義されています。
- **スーパークラスを返す関数から得られる値は、R とは限らない**ので、
    - **`Stream<R>` を安全に構築できなくなる**。
- → **型が崩れる／キャストが必要になる／不整合になる**。

---

## ✅ 具体例で比較

### 正しいパターン：

```java
Stream<Integer> intStream = Stream.of(1, 2, 3);

Stream<String> stringStream = intStream.map(
    (Number n) -> "Value: " + n  // Function<? super Integer, ? extends String>
);
```

- `Integer` は `Number` のサブクラス → `? super Integer` に合う
- 戻り値は `String` → `? extends String` に合う

---

### 間違ったパターン（仮に許されるとしたら）：

```java
Stream<Integer> intStream = Stream.of(1, 2, 3);

Stream<String> stringStream = intStream.map(
    (Integer n) -> (Object) ("Value: " + n)  // Function<? extends Integer, ? super String>
);
```

- 戻り値が `Object` 型 → `Stream<String>` に入らない（キャスト必要）
- 引数の型が `Integer` で固定 → `? extends T` の柔軟性も意味をなさない

---

## ✅ なぜ `? super T, ? extends R` がベストか？

| 部位 | 指定 | 意味 |
| --- | --- | --- |
| 引数型 | `? super T` | `T` で渡してもOKな型（Tの親含む）を受け取る（安全） |
| 戻り値型 | `? extends R` | `R` とそのサブクラスを返す（柔軟・型安全） |

---

## ✅ まとめ

| 記述 | 意味 | 問題点 |
| --- | --- | --- |
| `Function<? super T, ? extends R>` | 正常：Tのスーパー型を受け取り、Rのサブ型を返す | 安全・柔軟 |
| `Function<? extends T, ? super R>` | 異常：Tのサブ型しか受け取れず、戻り値がRのスーパークラス | 型不整合の危険あり、設計と矛盾 |

---

必要であれば、**なぜコンパイルできてしまうケースもあるのか**、**エラーになるパターンの再現**などもコード例付きでご紹介します！

# Q,

引数は基本何型のデータが入力されるか不明なので、入ってくるデータの型を広く受け入れるために親クラス型に設定する意味がある。
一方、戻り値の型は処理の内容によって決まることから、あらかじめ予測がたつので戻り値の型を特定して厳密に型指定する余地を与えるためにサブクラスで指定できるようになっている。
以上のような認識はあっていますか？

はい、Hiroakiさんのその認識は**非常に的確で、本質を捉えています**。

以下に要点を整理・補足しながら確認いたします。

---

## ✅ 結論：その認識は **正しい** です。

---

## 🔍 引数：`? super T` を使う理由（受け入れ口は広く）

> 「何型が入力されるか分からないから、T の親も受け入れられるようにしておく」
> 

これはまさに：

- **受け取る（consume）側は、T かその親クラスなら安全に使える** という考え方。
- `Function<? super T, R>` なら、`T` を `apply()` の引数に渡しても確実に受け取れる。

### 例：

```java
Function<Object, String> f = obj -> obj.toString();
Stream<Integer> s = ...
s.map(f); // OK：Function<? super Integer, String> にマッチ
```

- `Object` は `Integer` の親 → `? super Integer` に適合
- つまり「**T のスーパータイプを使っても安全に引数として渡せる**」というのが `? super T` の意味

---

## 🔍 戻り値：`? extends R` を使う理由（返す型は想定できる）

> 「処理内容で戻り値の型が決まるから、Rの範囲内で柔軟性を持たせる」
> 

これも正しいです。

- 戻り値は、`R` またはそのサブクラスであれば、`Stream<R>` に入れても安全。
- *戻り値の型は呼び出し側が決める（型推論で決まる）**ことが多いので、柔軟に受け入れられる設計になっている。

### 例：

```java
Function<Integer, CharSequence> f = i -> "value: " + i;
Stream<Integer> s = ...
Stream<CharSequence> result = s.map(f); // OK：Function<Integer, ? extends CharSequence>
```

- `"value: " + i` は `String` 型（`CharSequence` のサブクラス）
- 戻り値が `? extends CharSequence` だから `Stream<CharSequence>` に入れてOK

---

## ✅ 補足まとめ

| 要素 | ワイルドカード | 理由・設計意図 |
| --- | --- | --- |
| **引数型** | `? super T` | T を安全に渡すため、親型も許容して柔軟性を持たせる |
| **戻り値型** | `? extends R` | 呼び出し側で受け取れるように、R のサブ型も許容（型推論に柔軟） |

---

## 🧠 補助イメージ（読みと書きの違い）

- **引数 = 入力 = 書き込み先 → 広く受け取りたい → `super`**
- **戻り値 = 出力 = 読み込み元 → 厳密に受け取りたい → `extends`**

---

## ✅ 結論として

> Hiroakiさんのこの理解は、Java の**型設計思想とジェネリクスの原則（PECS）**を、実装レベルでしっかり踏まえていて非常に良い理解です。
> 

この視点があると、APIの使い方だけでなく**ライブラリ設計やインタフェース設計**にも強くなれます！

今後、`Consumer`, `Function`, `Supplier` などの設計理由を読むうえでも大いに役立ちます。

# Q,

<? extends A>は、「？はAを継承したもの」ということで、？はAもしくはAのサブクラスという制限をもうけることで、ジェネリクスの不変性を回避しその制限下の複数のクラスを読み込むことができる。
ただし、クラスの上限は決まっているものの、どのクラスが読み込まれるか不明なため書き込みは不可。
<? super B>は、「？はBのスーパークラス」で、当該制限の下限が？で？が読み込まれることが決定しているのでどの型が読み込まれるか判明してその型をしていできるので書き込みができる。という認識はあっていますか？

はい、Hiroakiさんの認識は概ね正確です。ただし、いくつか表現や理論をより明確にすると、理解がさらに深まると思います。以下に補足と整理を行います。

---

## ✅ ジェネリクスのワイルドカードの基本整理

| 記法 | 意味 | 読み込み | 書き込み | 備考 |
| --- | --- | --- | --- | --- |
| `<? extends A>` | AまたはAのサブクラスが許容される | ✅ 可 | ❌ 不可 | 読み込み専用「Producer（生産者）」 |
| `<? super B>` | BまたはBのスーパークラスが許容される | ❌ 制限あり | ✅ 可 | 書き込み専用「Consumer（消費者）」 |

---

## 💡 認識の確認と補足

### `<? extends A>`

- **Hiroakiさんの認識：**
    
    ✔「AまたはAのサブクラス」という上限を設定することで、不変性を回避し読み込みが可能になる
    
    ✔「具体的にどのクラスかわからないので書き込み不可」
    
- **補足ポイント：**
    - `List<? extends A>` に対して `A` や `A` のサブクラスを**安全に読み取る**ことができます。
    - しかし、たとえ `A` のインスタンスでも**書き込むことはできません**。なぜなら、コンパイラはそのリストの実際の型（例えば `List<SubA>`）を知りません。
    - **例：**

```java
List<? extends Number> list = new ArrayList<Integer>();
Number n = list.get(0);   // OK
list.add(10);             // コンパイルエラー
```

---

### `<? super B>`

- **Hiroakiさんの認識：**
    
    ✔「BまたはBのスーパークラス」として下限を設定し、
    
    ✔「どの型を渡しても、Bとして安全に扱えるため書き込み可能」
    
- **補足ポイント：**
    - `List<? super B>` に対しては `B` または `B` のサブクラスを**安全に書き込めます**。
    - 読み取りは `Object` 型にしかできない（具体的な型が不明なため）。
    - **例：**

```java
List<? super Integer> list = new ArrayList<Number>();
list.add(10);            // OK
Object obj = list.get(0); // OK（ただし型は Object）
```

---

## 🔁 総まとめ：PECS原則

- **PECS：** *Producer Extends, Consumer Super*
    - **データの生産（読み込み）目的 ⇒ `extends`**
    - **データの消費（書き込み）目的 ⇒ `super`**

---

ご質問のように、読み込みと書き込みの可否の理由を「型の不確定性（どの型が来るかわからない）」と結びつけて考える姿勢はとても良いです。上限・下限の意味と合わせて、目的（読みたいのか書きたいのか）を考えると使い分けしやすくなります。

さらに深く理解したい場合は、「型の安全性」と「キャストの必要性」の観点から見ても面白いです。希望があればその点も補足できますよ。