# 型推論について

# Q,

APIの型推論の基準をAPIごとに変えるコンパイラの設計をするということもあるということですね。

はい、Hiroakiさん、まさにその通りです。

厳密には、**コンパイラ（`javac`）は API ごとに型推論ルールを変えているわけではありませんが、**

**API の設計（特にメソッドの型引数の使い方）と呼び出し側の文脈によって、**

**「異なるように見える型推論結果」が導かれる**ようになっています。

---

## ✅ 正確に言うと…

> 🔹 コンパイラはすべてのメソッド呼び出しに対して Java Language Specification（JLS）に従って一貫した推論アルゴリズムを使います。
> 

ですが：

> 🔹 API側のジェネリクス宣言の違い（例えば引数の数、varargsの位置、戻り値との関係）や
> 
> 
> 🔹 **呼び出し時の文脈（右辺の型や渡す引数の型）**によって
> 
> → 結果として **「APIごとに型推論の動きが違って見える」**のです。
> 

---

## 🎯 たとえば：`Arrays.asList` vs `List.of`

どちらも型引数付きの varargs メソッドですが：

### `Arrays.asList(T... a)`

- メソッド宣言が「T の配列」をそのまま `List<T>` に渡す構造
- 旧来の API で柔軟な推論が働きやすい

```java
List<String> list = Arrays.asList(new String[] {"a", "b"}); // T = String と推論
```

---

### `List.of(E... elements)`

- JDK 9で導入された不変リストAPI
- 安全重視の設計
- コンパイラは「配列を 1 要素とみなす」→ `E = String[]` と推論される

```java
List<String[]> list = List.of(new String[] {"a", "b"}); // E = String[] と推論
```

---

## ✅ なぜ「APIによって異なるように見える」のか？

| 要因 | 内容 |
| --- | --- |
| APIの宣言構造 | `<T> List<T> asList(T... a)` vs `<E> List<E> of(E... elements)` |
| 呼び出しの文脈 | 配列リテラル or 配列変数か／代入先が明示されているか |
| 型推論の制約 | Javaコンパイラは「可能な限り正確に推論する」ことを優先する |
| 設計思想の違い | Arrays.asList は柔軟、List.of は厳密・不変リスト前提 |

---

## ✅ まとめ

> 🔹 コンパイラの推論ルールそのものは一貫しています。
> 
> 
> 🔹 **しかし、APIの設計（型宣言や引数の構造）と使用コンテキストによって、APIごとに“異なる推論のように見える”結果が導かれます。**
> 

---

### 💡補足：

こうした現象は **Javaの型推論（特に varargs + ジェネリクス）**の難所であり、

Java開発者の中でも誤解されやすいポイントです。

JDKの設計者もそれを認識しており、`List.of` などではあえて「保守的な推論」が働くように設計しています。

---

もっと深く知りたければ、`javac -XprintRounds` などで型推論の途中経過を見る方法や、

OpenJDKの型推論エンジンの設計に関する資料もご紹介できます！

# Q,

> 🔹 コンパイラの推論ルールそのものは一貫しています。
🔹 しかし、APIの設計（型宣言や引数の構造）と使用コンテキストによって、APIごとに“異なる推論のように見える”結果が導かれます。
> 

上記の解説について確認です。
上記説明だと、推論ルール(仮)というの各要素のあつまりがあり、その各要素である、APIの設計（型宣言や引数の構造）と使用コンテキストによって、その推論ルール内にある要素中、この要素の組み合わせならばこう推論するというような事前に決まっている選択肢を取るというようなアルゴリズムのようなものがある認識は合っていますか？

はい、Hiroakiさん、

そのご認識は**非常に的確**で、本質をとらえています。

---

## ✅ 結論：その認識は **正しい** です。

> 🔹 「Javaコンパイラの型推論」は、一貫したアルゴリズムに従って動作しており、
> 
> 
> 🔹 そのアルゴリズムは、**APIの型定義**や**呼び出し文脈（使用コンテキスト）といった要素の組み合わせ**を評価して、
> 
> 🔹 「この条件ならこの型を推論する」というような**選択肢を事前に備えたルール集合（≒型推論戦略）」に従って処理されます。
> 

---

## ✅ もう少し具体的に言うと：

Javaの型推論（特にジェネリクス + varargs の場合）は

**Java Language Specification（JLS）15.12.2.7 [Type Inference](https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12.2.7)** に定義されたルールに沿って次のような順で処理されます：

---

### 🧠 型推論アルゴリズムの大まかな流れ（抽象化）：

1. **メソッド定義の型パラメータ（T, Eなど）を収集**
2. **呼び出し時に与えられた実引数の型を調査**
3. **仮引数（T...など）との適合性を評価**
4. **推論可能な最も具体的な型を決定**
5. **呼び出し先の期待される型（右辺の型など）とも整合性を確認**
6. **すべて満たす型 `T` が存在すれば採用、なければ型エラー or Raw型へフォールバック**

---

## 🔍 例：`List.of(new String[] {"a", "b", "c"})`

- `E... elements` に `String[]` を渡す
- → 実引数は `String[]`
- → コンパイラは「E = String[]」と判断（varargsの1要素）
- → 結果：`List<String[]>`

---

## ✅ つまり Hiroakiさんの言葉で言えば：

> 🔹 推論ルール（仮）という各要素のあつまりがあり、
🔹 APIの設計（型宣言や引数の構造）と使用コンテキストによって、
🔹 「この要素の組み合わせならばこう推論する」というような
🔹 事前に決まっている選択肢を取るアルゴリズムのようなもの
> 

🟢 → **まさにその通りです。**

Javaコンパイラ（`javac`）はこのルールに従って「一貫して」推論を行っており、

その結果として、**APIごとに「異なる推論」に見える現象**が生じるのです。

---

## ✅ もし補足を求めるなら…

- 「その推論ルール（戦略）はどこに書いてあるのか？」
- 「それを読む練習のために、JLSをどう読めばいいのか？」
- 「実際に javac に何が起きているのか調べる方法は？」

こういった内容も含めて、お手伝いできますので、ぜひ気軽に聞いてください。

このテーマは本当にJavaの深い理解につながります！

# Q,

「その推論ルール（戦略）はどこに書いてあるのか？」をお願いします

とても良い質問です、Hiroakiさん。

---

## ✅ 回答：Javaの型推論ルール（戦略）は、以下に**公式に記述されています**

---

### 🔹 **Java Language Specification (JLS)**

📖 **JLS §15.12.2.7: Type Inference**

[https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12.2.7](https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12.2.7)

このセクションでは、Javaコンパイラが**型引数をどのように推論するか**が詳細に記述されています。

---

## ✅ 概要：JLS §15.12.2.7 の中身（要点）

### 型推論のステップ（簡略化）

1. **メソッド呼び出しの仮引数と実引数の型を収集**
2. **型引数（Tなど）を「どの型にすべきか」制約として列挙**
3. **制約の整合性を解析**
4. **最も具体的な型（most specific type）を選ぶ**
5. **文脈的な期待型（LHSなど）と一致するかチェック**

---

## ✅ 関連セクションの一覧（JLS 第15章）

| セクション | 内容 |
| --- | --- |
| 15.12 | Method Invocation Expressions（メソッド呼び出しの構文） |
| 15.12.2 | Compile-Time Step 2: Determine Method Signature |
| 15.12.2.1 | Identify Potentially Applicable Methods |
| 15.12.2.2 | Phase 1: Specific Arity (非varargs 呼び出し) |
| 15.12.2.4 | Phase 2: Variable Arity (varargs 呼び出し) |
| **15.12.2.7** | **Type Inference（型推論） ← 💡 一番重要！** |
| 15.12.2.8 | Invocation Type Inference（呼び出し時の型推論） |
| 15.12.2.9 | Applicability of Methods by Subtyping |
| 15.12.2.10 | Most Specific Method |
|  |  |

---

## ✅ List.of などに関連する推論の例（JLS内）

JLSには直接 `List.of(...)` の記載はありませんが、以下のような内容が重要です：

### 抜粋例（要点の意訳）：

> If a method is invoked with a variable arity parameter, and the argument is a single array expression, then the method is applicable by variable arity only if the array expression is compatible with the varargs parameter type.
> 

つまり：

- `E... elements` に `new String[] {...}` を渡した場合：
    - **配列1つだけなら、要素ではなく配列全体が「1つの引数」になる**
    - → `E = String[]` と推論される

➡ `List.of(new String[] {"a", "b", "c"})` → `List<String[]>`

---

## ✅ 補足：OpenJDKの型推論ソースを見たい場合

JLSの内容を実装しているのは、OpenJDKの `javac` コンパイラです。

GitHub（OpenJDK）での主なソースファイル：

- [`Infer.java`](https://github.com/openjdk/jdk/blob/master/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Infer.java)
    
    → 型引数推論のアルゴリズム本体
    
- [`Resolve.java`](https://github.com/openjdk/jdk/blob/master/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java)
    
    → メソッドの解決と選択（オーバーロードなど）
    
- [`Types.java`](https://github.com/openjdk/jdk/blob/master/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java)
    
    → 型の互換性や代入可能性のチェック
    

---

## ✅ まとめ

| 質問 | 回答 |
| --- | --- |
| 型推論のルールはどこに書いてあるか？ | **Java Language Specification（JLS） §15.12.2.7** |
| 具体的に何が書かれている？ | **型引数をどう決定するかのアルゴリズム手順**が明記されている |
| APIごとの違いは？ | **型パラメータの宣言と実引数の文脈の違い**により、JLSのルールに従って異なる推論結果が導かれる |

---

ご希望があれば、実際に JLS の該当セクションを一緒に読んで、コード例と照らし合わせながら解釈していくこともできますよ！

「JLSリーディングのコツ」もお伝えできますので、お気軽にどうぞ。

# Q,

「それを読む練習のために、JLSをどう読めばいいのか？」をお願いします

素晴らしい問いです、Hiroakiさん。

**JLS（Java Language Specification）を読む練習**は、Javaの深い理解にとって非常に価値があります。

---

## ✅ 結論：「JLSを読む練習」は、**構造を理解し、スコープを限定して、手元のコードと結びつける**ことで実践できます。

以下のステップで読むのが効果的です👇

---

## 🧭 ステップ 1：**JLSの構造を知る**

JLSは巨大なので、最初から通読するのではなく、「目的別にセクションを引く」使い方が大事です。

| 章 | 内容 |
| --- | --- |
| 第3章 | 字句構造（識別子、リテラルなど） |
| 第4章 | 型と汎型（Generics） ← 💡 超重要 |
| 第5章 | 型変換、キャスト、ワイドニングなど |
| 第6章 | 宣言（クラス、メソッド、スコープ） |
| 第7章 | 名前空間とインポート |
| **第15章** | **式（Expressions）← 型推論はここ！** |
| 第16章 | 文（Statements：if/switch/whileなど） |

📍**型推論に関係する主なセクション：**

- §4.5〜4.10（ジェネリクスの型構造）
- §15.12（メソッド呼び出し）※特に：
    - §15.12.2.7 Type Inference（型推論）
    - §15.12.2.4 Variable Arity（可変長引数）

---

## 🧪 ステップ 2：**自分のコードと照らし合わせて読む**

例：次のコードを考えます。

```java
List<String> list = List.of(new String[] {"a", "b", "c"});
```

これを読み解くなら：

1. `List.of(...)` が **ジェネリックメソッド（E... elements）** であることを確認
2. `new String[] {...}` が **1要素の引数（配列）** になることを認識
3. §15.12.2.7 の **推論手順（インスタンス推論／メソッド適用性）** を読む

このように、**1つのコードから逆引きで該当セクションを探して読む**と理解が深まります。

---

## 🛠 ステップ 3：**ポイントを絞って読む（全部読まない）**

JLSは法律文書のように厳密で難解なので、全部を精読する必要はありません。

🔍 例えば `Type Inference` を読むときは：

```java
"A type inference algorithm determines the invocation type of a method ..."

→ メソッド呼び出しにおいて、型推論アルゴリズムがどの型を選ぶかがここで決まる
```

さらに下にある：

```java
"In this process, the bounds on the type parameters are inferred ..."
```

→ ここで言う「bounds」は、T が「何型でなければならないか（上限・下限）」という制約です。

---

## 🧩 ステップ 4：補助資料や翻訳を活用する

- 日本語でのJLS解説サイトや書籍（Java言語仕様書、技術書典など）
- 公式 JDK の [OpenJDKのjavacソースコード](https://github.com/openjdk/jdk) と対比
- IntelliJ や Eclipse の「型のヒント」機能と合わせて読む

---

## ✅ 補足：読み方のコツ（要約）

| コツ | 説明 |
| --- | --- |
| ① 目的を決める | 「型推論を知りたい」「switch式の仕様が知りたい」など明確に |
| ② 該当セクションを探す | JLSの目次 or Google検索でピンポイントに絞る |
| ③ 実例を用意して照らす | 1つのJavaコードから逆にJLSの説明を読む |
| ④ 難しければ要約に頼る | 逐語訳より要点サマリで理解を深める |
| ⑤ JLSとOpenJDK両方で補完 | JLSは仕様、OpenJDKは実装という関係性で使う |

---

## ✅ 実践におすすめのトレーニング例

### 📘 お題：

次のコードがどう推論されるか、JLSで読み解いてみる：

```java
List<String> list = Arrays.asList(new String[] {"a", "b", "c"});
```

- §15.12.2.7：T = String になる理由（仮引数 T... に適合）
- §4.5.1：配列の型とジェネリクスの適合性
- §5.1.6：配列からジェネリクスへの変換（必要があれば）

---

## ✅ まとめ

| 質問 | 回答 |
| --- | --- |
| JLSを読む練習方法は？ | 「目的を持ち、該当コードと結びつけて、必要な範囲だけ読む」のが最適 |
| どこを読めばよい？ | 型推論：JLS §15.12.2.7（Type Inference）が最重要 |
| コツは？ | サンプルコードと合わせて読む／全部読まない／補助資料も使う |

---

JLSリーディングを継続すると、Javaを「言語仕様」から理解できるレベルに到達します。

もし、JLSを読む上で「この文言がわかりにくい」などあれば、いつでも一緒に解釈しますよ！