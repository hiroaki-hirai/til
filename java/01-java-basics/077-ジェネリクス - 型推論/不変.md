# 不変

# Q,

通常の型の場合は、共変を認めるのに、ジェネリクスには共変性を認めない理由は、実行時まで型が決まらない状態（共変によりサブクラスの型のインスタンスになる可能性あり）だとコンパイラの型判断は問題なく通っても例外が発生する可能性があるが、最初から不変としておくことで、型のミスマッチを防ぐことができるからという認識は合っていますか？

はい、Hiroakiさん、その認識は**非常に本質的かつ正確です。**

以下に、論点を整理しながら補足を交えて解説します。

---

## ✅ あなたの認識の要点（確認）

> 通常の型（例えば String → Object）では共変が許されているが、
> 
> 
> **ジェネリクス型では共変性を許すと、実行時の型安全が破られる可能性がある**。
> 
> よって、最初から**ジェネリクスは不変（invariant）にして、型のミスマッチをコンパイル時に防いでいる**。
> 

➡ **完全に正しい理解です。**

---

## 🔷 なぜ「通常の型」では共変が許されるのか？

```java
String str = "hello";
Object obj = str;  // OK（共変性）
```

### ✅ 理由：

- `String` is-a `Object` → サブ型は親型として安全に扱える。
- Javaは「参照型の代入互換性（代入時の共変性）」を許容している。
- **参照先（インスタンス）の実型は失われない**ので、キャストで正確に扱える。

---

## 🔷 なぜ「ジェネリクス」では共変が許されないのか？

```java
List<String> stringList = new ArrayList<>();
List<Object> objectList = stringList; // ❌ 許されない（コンパイルエラー）
```

### ❗ 仮にこれが許された場合の問題：

```java
objectList.add(100);   // Integerを追加 → stringListにも入ってしまう！

String s = stringList.get(0);  // ☠️ ClassCastExceptionの危険
```

---

## ✅ あなたの言葉をもう一歩補足すると：

> Javaのジェネリクスは**型消去（type erasure）**により、実行時には型情報が存在しない。
> 
> 
> したがって、**実行時に型をチェックできないため、コンパイル時に厳密に型をチェックする必要がある**。
> 

→ これが「**ジェネリクスは不変でなければならない**」という根本理由です。

---

## 🔸 まとめ表

| 比較項目 | 通常の型 | ジェネリクス型 |
| --- | --- | --- |
| 共変性 | 許容される（`String` → `Object`） | ❌ 不許可（`List<String>` ≠ `List<Object>`） |
| 型安全性 | 実行時型情報あり → 問題なし | 実行時型消去あり → 危険性がある |
| コンパイル時チェック | 部分的 | 厳密に必要（型推論＋不変性） |
| 許容しない目的 | - | **実行時例外の未然防止（ClassCastException）** |

---

## ✅ 補足：共変性が許される他言語との違い

言語によっては以下のような型指定で**明示的に共変性を許容**する仕組みがあります：

| 言語 | 特徴 |
| --- | --- |
| Kotlin | `interface Producer<out T>` など、**`out`** キーワードで共変指定 |
| Scala | `class Box[+T]` のように、`+T` で共変指定 |
| C# | `IEnumerable<out T>` のように、`out` で共変指定 |

➡ Javaは「**型消去＋後方互換性**」のため、このような**構文的な共変指定は導入していない**（代わりに `? extends` で限定的に表現）。

---

## ✅ 結論

> ✔️ あなたの理解：「ジェネリクスは不変であることで、コンパイル時に型ミスマッチを防ぐ」という認識は正確です。
> 
> 
> Javaは**型消去＋コンパイル時型安全性の確保**を最優先しているため、**共変性を禁止**しています。
> 

---

もしご興味があれば、「`? extends` や `? super` を使った場合の代入パターン図」もあわせてご紹介できます！

# Q,

```java
String[] strings = new String[3];
Object[] objects = strings;  // ✅ 共変なのでOK

objects[0] = "hello";   // OK
objects[1] = 42;        // ☠️ ArrayStoreException（実行時例外）
```

上記のような例外の危険性を避けるために、ジェネリクスの不変性がある理解は合っていますか？

はい、Hiroakiさん、その理解は**完全に正しいです**。

その `ArrayStoreException` のような**実行時の型不整合をコンパイル時に防ぐため**に、**Javaのジェネリクスは「不変（invariant）」として設計されています。**

---

## ✅ 結論：

> 「配列の共変によって起こりうる実行時の型不整合を、ジェネリクスでは最初から禁止することで防ごうとしている**」
> 
> 
> ➡ この考え方は、**Javaジェネリクス設計の中核**です。
> 

---

## 🔷 背景と比較整理

### 📌 配列の共変（unsafe）

```java
String[] strings = new String[3];
Object[] objects = strings;     // OK（共変）

objects[0] = 42;                // ☠️ 実体が String[] なので実行時例外
```

- **見かけの型：`Object[]`**
- **実体の型：`String[]`**
- JVMはこの不整合に気づいて `ArrayStoreException` を投げるが、それは**実行時**であり、**コンパイル時は通ってしまう**。

---

### 📌 ジェネリクスの不変（safe）

```java
List<String> list = new ArrayList<>();
List<Object> objList = list; // ❌ コンパイルエラー：不変だから代入できない
```

- **ジェネリクスでは `List<String>` ≠ `List<Object>`**
- よって、**異なる型の要素を追加できてしまうような構文が成立しない**
- 型の不整合による実行時例外を、**コンパイル時に未然にブロック**

---

## ✅ 目的は「型安全性」の最大化

| 機能 | 配列 | ジェネリクス |
| --- | --- | --- |
| 共変性 | 許容 | 不許容（不変） |
| 実行時型情報 | あり | **なし（型消去）** |
| 型安全の保証手段 | 実行時に型チェック（ArrayStoreCheck） | **コンパイル時に厳格な型チェック** |
| 例外の可能性 | ArrayStoreException | **基本的になし（安全）** |
| 設計哲学 | 柔軟性重視（古い仕様） | 安全性重視（後発設計） |

---

## 🔸 JVM的視点（補足）

- 配列型は実行時にも「具体的な型情報（`String[]` など）」を保持している
- ジェネリクスは**型消去（type erasure）**により、**実行時には型パラメータは存在しない**
- よって、**ジェネリクスでは「実行時に型エラーを防ぐ」ことができない**
- だからこそ、**コンパイル時に絶対に型安全性を確保する必要がある**
    
    → そのために不変性（invariance）という制限がある
    

---

## ✅ 結論まとめ

| 質問 | 回答 |
| --- | --- |
| 配列の共変による例外リスクを防ぐためにジェネリクスは不変性を採用しているのか？ | ✅ **その通りです** |
| ジェネリクスは実行時の型安全性をどのように実現しているか？ | 型消去により実行時の安全性は持たず、**コンパイル時に型安全を保証する設計**になっている |

---

この不変性の補完として使われるのが、**`? extends` や `? super` によるワイルドカードによる共変・反変の制御**です。

もしこのあたりの応用（リストの読み書き可否や代入可能性）を詳しく確認したい場合は、そのまま図解付きで整理します！