# プリミティブ型 - 不可

# Q,

プリミティブ型 はジェネリクスの型パラメータには使えない理由はありますか？

はい、とても良い質問です。

プリミティブ型（`int`, `double`, `boolean` など）が **ジェネリクスの型パラメータに使えない理由**には、Java の設計上の歴史的・技術的な背景があります。

---

## ✅ 結論から言うと：

### 「**ジェネリクスは型消去（type erasure）によって実装されている**」ため、プリミティブ型が使えません。

---

## 🔍 背景解説

### ◾ Javaのジェネリクスは「型消去ベース」

Java のジェネリクスは、**コンパイル時だけ型チェックに使い、実行時には型情報が消える（＝型消去）**という仕組みで実装されています。

たとえば：

```java
List<String> list = new ArrayList<>();
```

これはコンパイル後には実質的に：

```java
List list = new ArrayList(); // 実行時には型パラメータが消える
```

---

### ◾ つまり、型パラメータ `T` は **Object型として扱われる**

```java
class Box<T> {
    T value;

    void set(T val) {
        this.value = val;
    }

    T get() {
        return value;
    }
}
```

これは型消去により、おおむね以下のように変換されます：

```java
class Box {
    Object value;

    void set(Object val) {
        this.value = val;
    }

    Object get() {
        return value;
    }
}
```

> このように、型パラメータ T は最終的に Object型として扱われるため、プリミティブ型（int, doubleなど）は使えないのです。
> 

---

## ✳️ プリミティブ型は Object ではない

- `int`, `boolean`, `char` などは **オブジェクト型（Objectのサブクラス）ではない**
- したがって、`Object` 型の変数に直接代入できず、ジェネリクスの中で扱えない

---

## ✅ 回避策：ボクシングを使う

Java ではプリミティブ型に対応する**ラッパークラス**を使うことで、ジェネリクスで扱えるようにしています：

| プリミティブ型 | ラッパークラス |
| --- | --- |
| `int` | `Integer` |
| `double` | `Double` |
| `boolean` | `Boolean` |
| ... | ... |

---

## 🛠️ Javaが型消去ベースを採用した理由

- **後方互換性**を保つため（Java 5でジェネリクスを導入する際、既存のJVM・バイトコードとの互換性を維持）
- 他言語（C++など）のテンプレートとは異なり、Java は **単一のバイナリコードを生成し、型パラメータだけを使い回す**設計

---

## 🔮 参考：将来的には使えるようになる？

- Javaの**Project Valhalla**では、**プリミティブ型のような「値型（value types）」をジェネリクスでも使えるようにしよう**という試みがあります（例：`List<int>` が使えるようになる構想）。
- ただし、**現時点（Java 21時点）では未実装／実験的段階**です。

---

## ✅ まとめ

| ポイント | 内容 |
| --- | --- |
| 型消去の仕組み | ジェネリクスの型パラメータは Object に置き換わる |
| プリミティブ型は？ | Objectではないので代入できない |
| 対応方法 | ラッパークラスを使う（例：`Integer`） |
| 代替API | `IntBinaryOperator`など、専用の関数型インタフェース |

---

もし「型消去」の仕組みそのものをコードベースで理解したい場合、簡単なジェネリクスの例と型消去後のイメージコードも作成します！