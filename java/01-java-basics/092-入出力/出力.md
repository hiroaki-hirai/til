# 出力

# Q,

```java
【クラス階層】                              【データの流れ】

java.lang.Object
   │
   ├─ java.io.InputStream   （抽象クラス：バイトストリームの基底）
   │       ▲
   │       ├─ FileInputStream        ← ファイルからバイト
   │       ├─ BufferedInputStream    ← バイトをバッファリング
   │       └─ System.in              ← 標準入力（バイト）
   │
   │   バイトデータ（8bit単位）
   │   ─────────────────────────────────▶
   │
   ├─ java.io.Reader        （抽象クラス：文字ストリームの基底）
   │       ▲
   │       ├─ InputStreamReader      ← バイト→文字変換
   │       │       （エンコーディング指定可：UTF-8等）
   │       │
   │       └─ BufferedReader         ← 文字をバッファリング＆便利メソッド（readLine等）
   │
   │   文字データ（Unicode）
   │   ─────────────────────────────────▶
   │
   ▼
アプリケーションコード（文字列として利用）
```

上記のようなフロー図を出力バージョンで作成できますか？

はい、できます。

先ほどの「入力バージョン」を**出力ストリーム版**に置き換えたものを作成すると、こうなります。

---

## 【クラス階層】＋【データの流れ】（出力バージョン）

```java
【クラス階層】                              【データの流れ】

java.lang.Object
   │
   ├─ java.io.OutputStream （抽象クラス：バイトストリームの基底）
   │       ▲
   │       ├─ FileOutputStream       ← ファイルへバイト書き出し
   │       ├─ BufferedOutputStream   ← バイトをバッファリング
   │       ├─ System.out             ← 標準出力（バイト）
   │       └─ Socket.getOutputStream()← ネットワーク送信
   │
   │   バイトデータ（8bit単位）
   │   ◀────────────────────────────────
   │
   ├─ java.io.Writer       （抽象クラス：文字ストリームの基底）
   │       ▲
   │       ├─ OutputStreamWriter     ← 文字→バイト変換
   │       │       （エンコーディング指定可：UTF-8等）
   │       │
   │       └─ BufferedWriter         ← 文字をバッファリング＆便利メソッド（write, newLine等）
   │
   │   文字データ（Unicode）
   │   ◀────────────────────────────────
   │
   ▼
アプリケーションコード（文字列として生成・出力）
```

---

### 流れの説明（入力との対応）

- **入力**
    
    外部（キーボード、ファイル、ネットワーク）から**バイト列** → 必要に応じて文字に変換して利用
    
- **出力**
    
    アプリ内の**文字列（Unicode）** → 必要に応じてバイトに変換 → 外部（ファイル、ネットワークなど）へ送信
    

---

### 出力コード例

```java
try (BufferedWriter bw =
         new BufferedWriter(new OutputStreamWriter(
             new FileOutputStream("out.txt"), StandardCharsets.UTF_8))) {
    bw.write("こんにちは");
    bw.newLine();
}
```

- `String`（Unicode） → `OutputStreamWriter` で文字コード変換（UTF-8） →
    
    `FileOutputStream` でファイルにバイト書き込み
    

---

もし希望があれば、これと**入力バージョン**を左右に並べた

「入出力ストリーム全体マップ」を1枚にまとめられます。

そうすると、I/Oの全体像が一目で分かります。

# Q,

上記解説中、BufferedWriter は、どのような役割でしょうか？
アプリ中の文字をバッファリングして高速処理可能にして文章構成を再整形などしたものをOutputStreamWriter にて文字→バイトへ変換というイメージでしょうか？

はい、ほぼ合っていますが、

**BufferedWriter** の役割はもう少しシンプルで、

> 「アプリ中の文字データを一旦メモリ上のバッファにためてから、まとめて下位の Writer（例: OutputStreamWriter）に渡すことで、I/O 呼び出し回数を減らし、高速化する」
> 

というのが本質です。

**文章構成の再整形**までは自動ではやらず、あくまでバッファリングによる効率化が目的です。

---

## 1. BufferedWriter の役割

1. **バッファ（メモリ上の配列）に一時的にデータをためる**
2. バッファがいっぱいになったときや `flush()` / `close()` されたときに、まとめて下位の Writer へ送る
3. 下位の Writer（例: `OutputStreamWriter`）が必要なら**文字コード変換**を行い、さらに `OutputStream` にバイトとして書き込む

---

## 2. イメージ図（出力側）

```java
[アプリの文字列]
    ↓ write()
[BufferedWriter] — バッファに蓄積（char[]）
    ↓ flush()
[OutputStreamWriter] — 文字コード変換（UTF-8等）
    ↓
[OutputStream] — バイト単位で外部へ出力
```

---

## 3. なぜ高速化されるのか

- バッファなしの場合 → 1文字書くごとにOSやファイルシステムへI/O要求が発生（遅い）
- バッファありの場合 → ある程度まとめて1回で書き込むので、I/O回数が減って高速

---

## 4. コード例

```java
try (BufferedWriter bw =
         new BufferedWriter(new OutputStreamWriter(
             new FileOutputStream("out.txt"), StandardCharsets.UTF_8))) {

    bw.write("Hello");
    bw.newLine(); // 改行（プラットフォーム依存の改行文字を挿入）
    bw.write("World");
    // bw.flush(); // 必要なら明示的にフラッシュ
}
```

---

## 5. まとめ

- **BufferedWriter** は「文字出力の高速化」のためのバッファリングクラス
- **OutputStreamWriter** は「文字 → バイト変換」担当
- 「文章の再整形」までは行わない（改行やインデントを入れるのはアプリ側の責任）

---

もしHiroakiさんが希望するなら、

`BufferedWriter` と `OutputStreamWriter` の関係を、**入力側の `BufferedReader` と `InputStreamReader` の構造図**と対比して並べた表を作れます。

そうすると入出力の対称性が一目でわかります。

# Q.

OutputStreamWriter にて「文字 → バイト変換」したものを、ある程度溜めて出力するために、BufferedWriter を利用するということでしょうか？

はい、その理解でほぼ正しいです。

順番に整理するとこうなります。

---

## 1. 役割分担

- **OutputStreamWriter**
    - アプリ内の `char`（Java内部はUTF-16）を、指定した文字コード（UTF-8など）で**バイト列に変換**する
    - 変換後すぐに下位の `OutputStream` に渡す（バッファリング機能はない）
- **BufferedWriter**
    - アプリから受け取った文字（`char`）を**一時的にバッファにためる**
    - バッファがいっぱいになったときや `flush()` / `close()` のタイミングで下位の `Writer`（この場合は OutputStreamWriter）にまとめて渡す

---

## 2. 出力の流れ（BufferedWriter を使う場合）

```java
[アプリの文字列]
   ↓ write()（1文字ずつでもOK）
BufferedWriter（char[] のバッファに蓄積）
   ↓ バッファ満杯 or flush() 呼び出し
OutputStreamWriter（文字コード変換：UTF-16 → UTF-8）
   ↓
OutputStream（バイト列を外部に書き出し）
   ↓
ファイル / ネットワーク / 標準出力
```

---

## 3. BufferedWriter があるメリット

- **I/O回数が減る** → 高速化
    
    例：1000文字を1文字ずつ出す場合
    
    - バッファなし → 1000回I/O発生
    - バッファあり（例：8KB） → 数回のI/Oで済む
- **改行処理が楽になる**
    - `newLine()` メソッドでプラットフォーム依存の改行コードを挿入可能

---

## 4. コード例

```java
try (BufferedWriter bw =
         new BufferedWriter(
             new OutputStreamWriter(
                 new FileOutputStream("out.txt"),
                 StandardCharsets.UTF_8))) {

    bw.write("こんにちは");
    bw.newLine();
    bw.write("世界");
    // bw.flush(); // 必要なら明示的に出力
}
```

---

✅ まとめ

> OutputStreamWriter は「文字→バイト変換」担当
> 
> 
> **BufferedWriter** は「変換前の文字をためてまとめ書き」担当
> 

---

もしHiroakiさんがOKなら、この「BufferedWriter＋OutputStreamWriter」の構造を、**入力側の BufferedReader＋InputStreamReader** と対比させた**双方向I/O構造図**を作れます。

そうすると入出力の仕組みがきれいに対称構造として見えるようになります。