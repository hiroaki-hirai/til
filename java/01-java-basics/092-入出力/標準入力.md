# 標準入力

# Q,

```java
try (BufferedReader br = new BufferedReader (new InputStreamReader(System.in)))
```

上記のコードについて解説してください。

では、順番に分解しながら解説しますね。

このコードは **try-with-resources構文** を使って、`System.in`（標準入力）からテキストを読み取る準備をしている部分です。

---

## 1. 全体の形：try-with-resources

```java
try (BufferedReader br = new BufferedReader(
        new InputStreamReader(System.in))) {
    // 入力処理
}
```

- **`try ( ... ) { ... }`**
    
    Java 7 以降で導入された構文で、`(...)` 内で宣言したリソースは、`try` ブロックを抜けるときに **自動的に `close()` される** 仕組みです。
    
- この場合、`BufferedReader br` がリソースとして登録されているので、`try` の処理終了時に `br.close()` が自動的に呼ばれます。

---

## 2. 中身のインスタンス生成の流れ

```java
new BufferedReader(
    new InputStreamReader(System.in)
)
```

### (1) `System.in`

- **標準入力ストリーム**
    
    キーボード入力や、外部からの標準入力（パイプ入力など）をバイト単位で受け取るための `InputStream`。
    
- 型は `InputStream`（バイトストリーム）なので、そのままだと文字単位の読み取りはできません。

---

### (2) `new InputStreamReader(System.in)`

- **`InputStream` → `Reader` 変換**
    - `InputStreamReader` は「バイト入力ストリーム」を「文字入力ストリーム（Reader）」に変換します。
    - バイトを文字に変換するときは、デフォルトでプラットフォーム依存の文字エンコーディング（例：UTF-8）を使用します。
- この変換を行う理由：
    
    標準入力はバイト単位なので、`BufferedReader` のような**文字ベースのAPI**で扱うためには `Reader` に変換する必要があります。
    

---

### (3) `new BufferedReader(...)`

- **読み込み効率化（バッファリング）**
    - `BufferedReader` は `Reader` をラップして、バッファ（内部メモリ）を使った効率的な読み込みを可能にします。
    - また、`readLine()` メソッドで1行単位の読み取りが簡単にできるようになります。

---

## 3. 実行イメージ

1. ユーザーがキーボードに文字を入力。
2. その入力が `System.in` でバイトとして取得される。
3. `InputStreamReader` がそのバイトを文字に変換する。
4. `BufferedReader` がその文字データを効率的に読み込み、`readLine()` などで利用可能にする。
5. `try` ブロック終了時に `br.close()` が自動呼び出しされ、ストリームを閉じる。

---

## 4. サンプルコード

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        try (BufferedReader br = new BufferedReader(
                new InputStreamReader(System.in))) {
            System.out.print("入力してください: ");
            String line = br.readLine();
            System.out.println("入力内容: " + line);
        }
    }
}
```

**ポイント**

- `throws IOException` が必要（I/O処理はチェック例外を投げる可能性があるため）。
- `try-with-resources` によって `close()` の呼び忘れを防げる。

---

## 5. まとめ（階層構造）

```java
System.in                →  InputStream (バイト単位)
   ↓ InputStreamReader   →  Reader       (文字単位)
       ↓ BufferedReader  →  高速化 & 行単位読み取り
```

- **try-with-resources** → 自動 `close()` で安全
- **InputStreamReader** → バイト → 文字 変換
- **BufferedReader** → 高速読み込み & 便利メソッド

---

もしHiroakiさんが希望するなら、

この `BufferedReader` を **Scanner** に置き換えた場合の違いも整理できますが、どうしますか？

これはJavaの入力処理の比較でよく出るポイントです。

# Q,

上記のコードは実務で一般的な記述になりますか？

はい、実務でも比較的一般的な書き方です。

ただし **場面によっては別の選択肢（Scannerやライブラリ利用）が優先される** こともあります。

現場での傾向を整理するとこんな感じです。

---

## 1. この書き方が一般的になる場面

- **標準入力（コンソール）から1行ずつ読みたい**
- **余計な依存を入れず、JDK標準のAPIだけで完結させたい**
- **try-with-resourcesで確実にクローズしたい**
- **パフォーマンス重視（BufferedReaderは高速）**
- **文字コードを明示できる**（例：`new InputStreamReader(System.in, StandardCharsets.UTF_8)`）

---

## 2. 他の方法が使われやすい場面との比較

| 方法 | 主な用途 | 長所 | 短所 |
| --- | --- | --- | --- |
| **BufferedReader + InputStreamReader** | ファイル/ネットワーク/標準入力の行単位読み取り | 高速・シンプル・エンコーディング指定可 | トークン単位の分割は自分で書く必要 |
| **Scanner** | 標準入力から数値や単語を取りたいとき | 区切り文字で分割して簡単に取得可 (`nextInt()` など) | 大量入力では遅め・細かい制御が苦手 |
| **Files.lines(Path)** | ファイルのストリーム処理 | 簡潔・Stream APIと相性良し | 標準入力には使えない |
| **外部ライブラリ（Apache Commons IO など）** | 実装コードを短く済ませたい | 簡単・便利 | 依存が増える |

---

## 3. 実務での傾向（私の経験則）

- **CLIツールや簡易ユーティリティ** → この `BufferedReader` の書き方はよく使われます。
- **数値やパラメータ読み込み** → `Scanner` が採用されることが多い。
- **業務システム本体** → 標準入力はあまり使わず、ファイルやネットワーク経由の `BufferedReader` が多い。
- **Webアプリ** → 直接標準入力はほぼなし。代わりにHTTPリクエストから`BufferedReader`を使う。

---

## 4. 現場で推奨される形

実務では、文字コードを**明示**しておくのがベストプラクティスです。

（環境依存で文字化け防止のため）

```java
try (BufferedReader br = new BufferedReader(
        new InputStreamReader(System.in, StandardCharsets.UTF_8))) {
    String line = br.readLine();
    System.out.println("入力: " + line);
}
```

---

つまり、この書き方は**教科書的でもあり、現場でも十分通用する定番パターン**です。

ただし、「何を読み込むか」と「使い勝手」を考えて、`Scanner` など他の選択肢に切り替えることもあります。

---

もし希望があれば、この`BufferedReader`方式と`Scanner`方式の**性能比較＋コード例**を作れます。

そうすると、どの場面でどちらを使うべきか判断しやすくなります。

# Q,

Scanner も標準入力で文字列等を入力できますが、System.inから文字列ではなくバイトとして取得される方が細かな操作ができるということでしょうか？

そうです、まさにその通りで、根っこの違いは

> Scanner は「文字列（トークン）」として読むことが前提
> 
> 
> **System.in は元々「バイトストリーム」なので、バイトとして扱えばより低レベル・細かい制御が可能**
> 

という点にあります。

---

## 1. System.in の正体

- 型は **`InputStream`**（バイト単位のストリーム）
- 標準入力の段階では「文字」ではなく「バイトの連なり」としてしか見えていない
- そのまま `read()` すれば、1バイトずつ **整数（0〜255）** として取得できる
- 文字コード変換もバッファリングも自分でコントロールできる

---

## 2. Scanner の位置づけ

- `Scanner` は **System.in を内部的に `InputStreamReader` で文字ストリーム化** してから、さらに区切り文字で分割（トークン化）する
- つまり

```java
System.in (バイト) 
   → InputStreamReader (文字変換)
       → Scanner (トークン分割)
```

- 既に「文字」に変換された後なので、文字コードの変換方法やバイト単位の読み取りはできない
- 代わりに `nextInt()` や `next()` などで、文字列を数値や単語に簡単に変換できる

---

## 3. バイトとして読むメリット（低レベル操作）

バイト単位で扱うと、こんなことができます。

| バイト単位で可能なこと | 文字単位との違い |
| --- | --- |
| 任意の文字コード（UTF-8, Shift_JIS, EUC-JPなど）を自分で変換 | Scannerだと事前変換済み |
| 改行やタブなどもバイトコード値で直接判定 | 文字化の影響なし |
| バイナリデータ（画像・PDFなど）も読み込み可 | 文字ストリームはバイナリに弱い |
| 読み込みのバッファサイズやタイミングを細かく制御 | Scannerは内部バッファ固定 |

---

## 4. まとめると

- **Scanner** → 「高レベルAPI」：文字列や数値を簡単に取得するためのラッパー
- **BufferedReader / InputStreamReader** → 「中レベルAPI」：文字単位で効率的に読み込む
- **System.in 直接 or InputStream** → 「低レベルAPI」：バイト単位で読み込むので最も細かく制御可能

---

もし希望があれば、

同じ `System.in` を **①バイト単位、②文字単位、③トークン単位** の3段階で読み込むサンプルコードを作って、挙動と使い分けを見せられます。

それを見ると「どの層で何をしているか」がはっきりします。

# Q,

同じ [System.in](http://system.in/) を ①バイト単位、②文字単位、③トークン単位 の3段階で読み込むサンプルコードを作って、挙動と使い分けを確認したいです。

では、同じ `System.in` を使って

**①バイト単位 → ②文字単位 → ③トークン単位**

の3段階で読み込むサンプルコードをまとめます。

---

## サンプルコード

```java
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

public class StdInReadDemo {
    public static void main(String[] args) throws IOException {

        // --- ① バイト単位で読み込む ---
        System.out.println("① バイト単位読み込み: 1行入力してEnter（バイト値表示）");
        try (InputStream in = System.in) {
            // read() は1バイトずつ整数で返す（改行含む）
            // 改行コードはOSによって異なる（Windows: CRLF → 13, 10）
            int b;
            while ((b = in.read()) != -1) { 
                System.out.println("バイト値: " + b);
                if (b == '\n') break; // 1行分だけ読む
            }
        }

        // --- ② 文字単位で読み込む ---
        System.out.println("\n② 文字単位読み込み: 1行入力してEnter（文字として表示）");
        try (BufferedReader br = new BufferedReader(
                new InputStreamReader(System.in, StandardCharsets.UTF_8))) {
            int ch;
            while ((ch = br.read()) != -1) { // 1文字ずつ読み込み
                System.out.println("文字: " + (char) ch);
                if (ch == '\n') break; // 改行まで
            }
        }

        // --- ③ トークン単位で読み込む ---
        System.out.println("\n③ トークン単位読み込み: 複数単語を入力してEnter（空白区切りで表示）");
        try (Scanner sc = new Scanner(System.in, StandardCharsets.UTF_8)) {
            while (sc.hasNext()) { // 空白・改行で区切る
                String token = sc.next();
                System.out.println("トークン: " + token);
                if (token.equals("exit")) break; // exitで終了
            }
        }
    }
}
```

---

## 実行例（Windows, UTF-8）

```java
① バイト単位読み込み: 1行入力してEnter（バイト値表示）
abc
バイト値: 97
バイト値: 98
バイト値: 99
バイト値: 13
バイト値: 10

② 文字単位読み込み: 1行入力してEnter（文字として表示）
abc
文字: a
文字: b
文字: c
文字:

③ トークン単位読み込み: 複数単語を入力してEnter（空白区切りで表示）
apple orange banana exit
トークン: apple
トークン: orange
トークン: banana
トークン: exit
```

---

## 使い分けの特徴

| 段階 | API | 主な用途 | 特徴 |
| --- | --- | --- | --- |
| ① バイト単位 | `InputStream` (`System.in`) | バイナリデータ、細かい制御 | 文字コード変換前なのでローレベル。バイナリ処理や独自プロトコル解析向き |
| ② 文字単位 | `BufferedReader` + `InputStreamReader` | テキスト処理 | バイト→文字変換済み。文字コードを明示できる。行単位・文字単位両方可能 |
| ③ トークン単位 | `Scanner` | 単語・数値の入力処理 | 区切り文字で自動分割。高レベルで簡単だが細かい制御は苦手 |

---

これを見ると、**下に行くほど「高レベルで簡単だが自由度が減る」**

**上に行くほど「低レベルで面倒だが自由度が高い」** という構造になっています。

---

この流れを図にすると、

**System.in (InputStream)**

↓（①）バイト

↓ InputStreamReader（文字変換）

↓（②）文字

↓ Scanner（区切り解析）

↓（③）トークン

となります。

---

Hiroakiさんの学習進度だと、この3段階を**パイプライン構造**として図解しておくと

「なぜ BufferedReader の前に InputStreamReader が必要か」や

「Scanner がバイト操作できない理由」が一発でわかると思います。

希望があれば、この3段階の**流れを1枚の図**にまとめます。

# Q,

この3段階の流れを1枚の図にまとめてください。

では、3段階の流れを **バイト → 文字 → トークン** のパイプラインとして図にまとめます。

`System.in` がどう変換されていくのかを一目で見られるようにしました。

---

```java
             ┌────────────────────────────────────┐
             │            標準入力（キーボードなど）           │
             └────────────────────────────────────┘
                              │
                              ▼
                 ┌─────────────────────┐
① バイト単位     │  System.in (InputStream) │
                 │  ─ バイトストリーム       │
                 │  ─ read() → int(0〜255)  │
                 └─────────────────────┘
                              │ 文字コード変換（UTF-8等）
                              ▼
                 ┌────────────────────────────┐
② 文字単位       │ InputStreamReader + BufferedReader │
                 │  ─ Reader（文字ストリーム）         │
                 │  ─ read(), readLine()              │
                 └────────────────────────────┘
                              │ 区切り文字解析（空白・改行など）
                              ▼
                 ┌───────────────────────────┐
③ トークン単位   │ Scanner                    │
                 │  ─ next(), nextInt(), ...  │
                 │  ─ 空白・改行で自動分割      │
                 └───────────────────────────┘
```

---

### 補足

- **① バイト単位**
    - 最も低レベル。文字コード変換を自分で行える
    - バイナリデータも扱える
- **② 文字単位**
    - テキスト処理向き。文字コード指定が可能
    - 行単位読み込みなど便利なメソッドあり
- **③ トークン単位**
    - 入力を自動的に単語や数値に分割してくれる
    - 細かい制御は苦手

---

この図は、入力処理の**抽象度の階層構造**を表していて、下に行くほど**抽象度が高く簡単**になりますが、**自由度は減ります**。

Hiroakiさんがもしこの図を「出力処理版」にも広げたい場合、逆方向（文字 → バイト → 出力先）でまとめられます。