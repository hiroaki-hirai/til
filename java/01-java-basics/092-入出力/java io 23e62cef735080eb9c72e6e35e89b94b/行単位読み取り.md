# 行単位読み取り

# Q、

[java.io](http://java.io/),java.nio を通して改行処理ができるメソッドは、readLine()以外に他にありますか？

はい、`readLine()` 以外にも **java.io / java.nio** 双方で改行を処理できる（＝行単位で読み取れる）メソッドやAPIがあります。

ただし、`readLine()` が唯一の低レベル直接的APIで、他はほとんど**ラッパーメソッドやユーティリティ**です。

---

## 1. **java.io 側**

### 1-1. 代表的な行読み込みメソッド

| クラス | メソッド | 特徴 |
| --- | --- | --- |
| **BufferedReader** | `String readLine()` | 改行コードを吸収して1行の文字列を返す（改行は含まれない） |
| **LineNumberReader**（`BufferedReader`のサブクラス） | `String readLine()` | `BufferedReader.readLine()` と同じだが、行番号をカウントして `getLineNumber()` で取得可能 |
| **Console** | `String readLine()` | コンソールから1行読み込み（エコーバックあり） |

---

## 2. **java.nio 側**

### 2-1. 高水準ユーティリティ（内部で`readLine()`相当を使用）

| クラス | メソッド | 特徴 |
| --- | --- | --- |
| **Files** | `List<String> readAllLines(Path path)` | ファイル全行を一括読み込み（全行リストとして返す） |
| **Files** | `Stream<String> lines(Path path)` | ファイルを遅延評価で1行ずつ読み込む（ストリーム処理向け） |
| **Scanner**（java.utilだがjava.nioとも併用可） | `String nextLine()` | 任意の`Readable`（`BufferedReader`や`FileReader`など）や`InputStream`から1行単位で読み込む |

---

## 3. **補足：改行処理のアプローチ**

- **低レベル**: 自分でバッファを読みながら改行コード（`\n`, `\r`, `\r\n`）を探す
    
    → `InputStream.read()`, `Reader.read()` などで実装
    
- **高レベル**: `readLine()` や `Files.lines()` のように既存メソッドで行単位読み取り
    
    → 改行コード差異（LF/CRLF）も吸収してくれる
    

---

## 4. まとめ表

| API種類 | メソッド | 改行処理の有無 | 備考 |
| --- | --- | --- | --- |
| **java.io** | `BufferedReader.readLine()` | ○ | 最も基本的 |
| **java.io** | `LineNumberReader.readLine()` | ○ | 行番号付き |
| **java.io** | `Console.readLine()` | ○ | ユーザー入力用 |
| **java.nio.file.Files** | `readAllLines()` | ○ | 全行リスト化 |
| **java.nio.file.Files** | `lines()` | ○ | Streamで行処理 |
| **java.util.Scanner** | `nextLine()` | ○ | 区切り文字変更も可 |

---

つまり、

> 「改行処理できるメソッド」は、readLine()だけでなく、Files.lines() や Scanner.nextLine() など複数存在する。
> 
> 
> ただし、内部的には結局 `BufferedReader.readLine()` と同等の処理をしているものが多い。
> 

---

もし希望があれば、この全メソッドについて **「改行コードの扱い比較表」** を作成できます。

そうすると、「どのAPIがCRLF/LFをどう扱うか」が一目でわかります。

# Q,

この全メソッドについて 「改行コードの扱い比較表」 を作成してください。

了解です。主要な “行読み” メソッドについて、改行コード（LF/CR/CRLF）や細かな挙動を横断で比較しました。実務で迷いがちな**末尾の改行の扱い**や**最終行が改行なしの場合**、**文字コード**まで含めています。

# 改行コードの扱い比較表

| メソッド | 対応する改行 | 返却文字列に改行を含む？ | 最終行が改行なしでも返る？ | 文字コードの扱い | メモリ特性 | 備考 |
| --- | --- | --- | --- | --- | --- | --- |
| `BufferedReader.readLine()` | `\n`, `\r`, `\r\n` を行末として認識 | 含まない | 返る（行として返す） | `Reader` 依存（例: `InputStreamReader(charset)` で指定） | 1行ずつ、バッファ済み | 行単位読み取りの基本。CR/LF差異を吸収 |
| `LineNumberReader.readLine()` | `\n`, `\r`, `\r\n` | 含まない | 返る | `Reader` 依存 | 1行ずつ、バッファ済み | `readLine()` と同等の行処理＋行番号取得可 |
| `Console.readLine()` | 実質 `\n`（コンソール入力の行区切り）※OS依存で `\r\n` も可 | 含まない | 入力確定で返る | コンソールのエンコーディング依存（JVM/OS設定） | 1行ずつ | 対話入力向け。パスワードは `readPassword()` |
| `Files.readAllLines(Path[, charset])` | `\n`, `\r`, `\r\n` | 含まない | 返る | 引数の `charset` で明示推奨（未指定だと実装依存の既定） | **全行をリストに読み込み（全件メモリ）** | 小〜中規模ファイルに向く。手軽だが大きいファイルは非推奨 |
| `Files.lines(Path[, charset])` | `\n`, `\r`, `\r\n` | 含まない | 返る | 引数の `charset` | **遅延ストリーム（逐次・低メモリ）** | 内部的に `BufferedReader` ベース。必ず `try-with-resources` でクローズ |
| `Scanner.nextLine()` | `\n`, `\r`, `\r\n` を行区切りとして判定 | 含まない | 返る | 入力ソースに依存（`new Scanner(InputStream, charset)` で指定可） | 1行ずつ | `delimiter` 設定は `next()` 系に影響、`nextLine()` は改行基準で行取得 |

## 細かな注意点（実務Tips）

- **改行は結果文字列に含まれません**：どのメソッドも返すのは「行本体」。ログ整形などで改行が必要なら自分で `+ "\n"` する。
- **最終行が改行なしでも行として返る**：ファイル末尾に改行がなくても、最後の行は取得されます（`null` は EOF のみ）。
- **CR（`\r`）単独もサポート**：古い Mac 形式（CR 単独）も `BufferedReader` 系や `Files.*` は行末として扱えます。
- **文字コードは明示が安全**：`FileReader` や既定のエンコーディングに頼らず、`InputStreamReader(..., StandardCharsets.UTF_8)` や `Files.lines(path, UTF_8)` のように**必ず明示**。
- **大規模ファイル**：`readAllLines` は全読み込みなので避け、`Files.lines`（Stream）や `BufferedReader.readLine()` で逐次処理しましょう。
- **`Scanner` の使い所**：トークン分割（数値/単語など）と併用する小規模入力に便利。大量データの行処理は `BufferedReader` / `Files.lines` のほうが高速・低オーバーヘッドになりやすい。

必要なら、**各APIで CR/LF/CRLF を含むサンプルファイルに対して実験コード**（ベンチ付き）も用意します。どれで行末がどう切れるか、実測で確認できますよ。