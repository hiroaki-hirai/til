# メソッド (副作用メイン)

# Q,

Consumerを引数にとる副作用メインのメソッドには、forEach以外でありますか？

はい、Hiroakiさん、鋭い視点です！

`Consumer` を引数にとり、**「副作用を目的とする」メソッド**は `forEach` 以外にも複数存在します。

以下に代表的なものを **カテゴリ別＋具体例つき** でまとめます。

---

## ✅ 結論：`Consumer` を受け取り、副作用（出力・記録・変更など）を目的とするメソッドは意外と多くあります。

---

## 🔹 1. `Optional` 系

### `ifPresent(Consumer<? super T> action)`

- 値が存在する場合のみ副作用を実行
- **副作用が主目的**の代表例です

```java
Optional<String> name = Optional.of("Taro");
name.ifPresent(System.out::println); // ← 値があれば出力（副作用）
```

---

### `ifPresentOrElse(Consumer<? super T>, Runnable)`

- 値の有無に応じて処理を分岐（いずれも副作用）

```java
name.ifPresentOrElse(
    System.out::println,                 // 値あり
    () -> System.out.println("なし")     // 値なし
);
```

---

## 🔹 2. `Stream` 系

### `peek(Consumer<? super T>)`

- **中間操作**として副作用を挿入する（ログなど）

```java
List<String> result = List.of("a", "b", "c").stream()
    .peek(s -> System.out.println("通過: " + s)) // 副作用
    .map(String::toUpperCase)
    .toList();
```

> peek() はデバッグやログ記録用で、純粋関数的には非推奨な使い方になることもあります。
> 

---

### `forEach(Consumer<? super T>)`（終端操作）

```java
stream.forEach(System.out::println); // 完全に副作用のみ
```

---

## 🔹 3. `Map` 系（Java 8以降）

### `forEach(BiConsumer<? super K, ? super V>)`

```java
Map<String, Integer> map = Map.of("apple", 1, "banana", 2);

map.forEach((key, val) -> System.out.println(key + "=" + val));
```

- `BiConsumer`（2引数）ですが、副作用が目的の `forEach`

---

## 🔹 4. `Iterable`・`Collection` の `removeIf(Predicate)`

- `Consumer` ではないですが、副作用（コレクションからの削除）を起こすという意味で似た構造です。

```java
list.removeIf(s -> s.startsWith("a")); // 状態変更
```

---

## ✅ まとめ表

| メソッド名 | 所属 | 説明 | 副作用の例 |
| --- | --- | --- | --- |
| `forEach` | `Iterable`, `Stream` | 各要素に対して処理 | 出力・ログなど |
| `ifPresent` | `Optional` | 値があれば実行 | ログ、通知など |
| `ifPresentOrElse` | `Optional` | 値あり/なし両方対応 | 条件付き出力 |
| `peek` | `Stream` | 中間操作での副作用 | デバッグログ |
| `Map.forEach` | `Map` | キー・バリュー両方で処理 | 状態出力 |
| `removeIf` | `Collection` | 条件を満たす要素を削除 | コレクション変更 |

---

## ✅ さらに：**自作クラスでの活用**

自作の `ListProcessor` クラスなどでも、副作用目的の `accept(Consumer<T>)` メソッドを定義可能です：

```java
class ListProcessor<T> {
    private final List<T> data;
    ListProcessor(List<T> data) { this.data = data; }

    public void processEach(Consumer<? super T> action) {
        data.forEach(action); // 自作forEach的なもの
    }
}
```

---

必要であれば、**ConsumerとFunctionを切り替えることで「副作用なし」に変える例**もご紹介できます！