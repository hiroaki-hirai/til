# 副作用

[純粋関数的](%E5%89%AF%E4%BD%9C%E7%94%A8%2021c62cef7350803f9ffbd6dd131f772c/%E7%B4%94%E7%B2%8B%E9%96%A2%E6%95%B0%E7%9A%84%2021f62cef735080fca0f4dc3edf8b4923.md)

# Q,

副作用という語彙は、どういった状況を表す言葉ですか？

「副作用（side effect）」という言葉は、**プログラムの関数やメソッドが、戻り値以外に周囲の状態を変えること**を指す専門用語です。

---

## ✅ 副作用とは？

> ある関数・メソッドを呼び出したときに、その関数の結果（戻り値）とは別に「何かしらの影響（効果）」が他にも生じること
> 

---

## ✅ 典型的な副作用の例

| 操作 | 状況 |
| --- | --- |
| `System.out.println()` | 標準出力に文字を表示する（画面に影響） |
| 変数の書き換え | グローバル変数やフィールドの値を更新する |
| ファイル書き込み | ディスク上にデータを保存する |
| データベースへの挿入 | 永続的な状態を変更する |
| ネットワーク通信 | 外部との状態変化・影響がある |

---

## ✅ 副作用が **ない** 処理の例（純粋関数）

```java
int add(int x, int y) {
    return x + y;
}
```

- この関数は **引数にだけ依存し、外部の状態を変更しない**
- ⇒ こういう関数は **副作用がない（pure function）**

---

## ✅ Javaにおける副作用の文脈でよく出る場面

### 1. `forEach()` の中で副作用を意識する

```java
list.forEach(System.out::println); // ← 標準出力という副作用
```

### 2. `map()` などの中では副作用を避けるべき

```java
list.stream()
    .map(x -> {
        // System.out.println(x); ← 実は副作用（避けるべき）
        return x.toUpperCase();
    })
```

- `map` は「変換」に集中するべきで、**出力や書き込みのような副作用は避ける設計**が良い

---

## ✅ 副作用を理解するメリット

- テストしやすいコード（純粋関数）を書けるようになる
- 状態の予測がしやすく、バグが減る
- 並列・非同期処理で問題が起こりにくくなる

---

## ✅ まとめ

| 観点 | 副作用あり | 副作用なし（純粋関数） |
| --- | --- | --- |
| 例 | `System.out.println()`、ファイル書き込み | `return a + b` |
| 状態を変える？ | ✅ 変える | ❌ 変えない |
| テストしやすさ | 難しい | しやすい |
| 並列性の安全性 | 低い | 高い |

---

ご希望があれば、「副作用を意識したコードのリファクタリング例」や「Javaで純粋関数的に書くテクニック」もご紹介できます！

# Q,

「副作用を意識したコードのリファクタリング例」をお願いします。

はい、Hiroakiさんのご要望にお応えして、

**「副作用を意識したコードのリファクタリング例」**を、ビフォー・アフター形式で解説します。

---

## 🎯 目標

副作用のある処理（出力・ログ・状態変更など）を**分離して、純粋な処理と分ける**ことで、

テストしやすく・予測しやすいコードにする。

---

## 🧱 Before：副作用が混ざったコード（よくある例）

```java
List<String> names = List.of("taro", "hanako", "jiro");

List<String> result = new ArrayList<>();
for (String name : names) {
    String upper = name.toUpperCase();
    System.out.println(upper); // ← 出力（副作用）
    result.add(upper);
}
```

### ❌ 問題点

- 「変換」と「出力」が混ざっている（副作用と純粋処理の混在）
- テストや並列処理に弱い
- 出力の有無によって処理の意味が変わるように見えてしまう

---

## ✅ After：副作用を分離したコード（リファクタ後）

```java
// 純粋関数的な変換処理
List<String> toUpperList(List<String> input) {
    return input.stream()
                .map(String::toUpperCase)
                .toList();  // Java 16+
}

// 出力処理は別に呼び出す（必要なら）
void printList(List<String> list) {
    list.forEach(System.out::println);
}
```

```java
List<String> names = List.of("taro", "hanako", "jiro");

List<String> upperNames = toUpperList(names); // ← 純粋関数
printList(upperNames);                         // ← 副作用はここだけ
```

---

## ✅ メリット

| 観点 | Before | After |
| --- | --- | --- |
| テストのしやすさ | 出力を見ないと正解がわからない | `toUpperList` だけテストすればOK |
| 再利用性 | 出力前提の処理なので限定的 | 出力しない場面にも使える |
| 並列処理との相性 | 出力があると競合や混乱の元 | 分離して並列化しやすい |

---

## 🎯 別例：DB書き込みを副作用とした例

### ❌ NG例（副作用込み）

```java
public void saveUser(String name) {
    String normalized = name.trim().toLowerCase();
    database.save(normalized); // ← 書き込み（副作用）
}
```

### ✅ OK例（副作用分離）

```java
public String normalizeUserName(String name) {
    return name.trim().toLowerCase(); // ← 純粋処理
}

public void saveUser(String rawName) {
    String normalized = normalizeUserName(rawName);
    database.save(normalized); // ← 副作用はここに限定
}
```

---

## ✅ まとめ

| 指針 | 内容 |
| --- | --- |
| 副作用とは？ | 戻り値以外に状態や環境へ影響する処理（出力・書き込み・通信など） |
| リファクタのポイント | 純粋な「変換・判定」などの処理を関数化し、副作用から切り離す |
| メリット | テストしやすく、保守性・再利用性・並列性が高くなる |

---

必要であれば、「副作用を最小限に抑えるストリームの使い方」や「テストダブル（モック）との関係」もご紹介できます！

# Q,

副作用には、どのようなものがありますか？
System.out.print()のような出力や、以下のような変更などでしょうか？

```java
for (StringBuilder sb : builders) {
    sb.append("X"); 
}
```

素晴らしい質問です、Hiroakiさん。

副作用（**side effect**）という概念は、プログラムの**関数・メソッドが「外部状態」に影響を与えること**を指します。

以下に体系的に整理します。

---

## ✅ 副作用（side effect）とは？

> 関数やメソッドが、引数やローカル変数以外の「外部に影響を与える」動作をすること
> 

---

## ✅ 主な副作用の種類（代表例）

| 種類 | 例 | 説明 |
| --- | --- | --- |
| **標準出力** | `System.out.print()` / `println()` | コンソールへの出力。プログラム外の表示状態に影響。 |
| **ファイル操作** | ファイルへの書き込み、読み込み | ディスクの状態が変わる。 |
| **変数の変更** | `array[i] = x;` / `sb.append(...)` | メソッドの外の変数やデータ構造に変更を加える。 |
| **例外のスロー** | `throw new RuntimeException();` | 実行の制御フローに影響。 |
| **ユーザー入力待ち** | `Scanner.nextLine()` | 外部環境とのインタラクション。 |
| **DBやネットワーク通信** | SQL実行 / API送信 | 外部システムに状態変更を引き起こす。 |

---

## ✅ ご質問のコードについて

```java
for (StringBuilder sb : builders) {
    sb.append("X"); 
}
```

これはまさに副作用です！

- `sb` は `builders` 配列の中の `StringBuilder` オブジェクトを指しています。
- `append("X")` は **オブジェクトの内部状態（文字列内容）を変更**します。
- したがって、**このループは「builders 配列の中身」を変更する副作用を持つ処理**です。

---

## ❌ 逆に副作用がない例（純粋関数的）

```java
public String addX(String input) {
    return input + "X";  // 新しい文字列を作って返す（元のinputは変わらない）
}
```

- これは**入力をもとに出力を返すだけで、外部には影響を与えません。**
- こうした関数を「**純粋関数（pure function）**」と呼び、テストや再利用性に優れます。

---

## ✅ まとめ：副作用の有無を見極める軸

| 判断基準 | 副作用がある | 副作用がない |
| --- | --- | --- |
| **外部状態が変わるか？** | ✅ 変わる | ❌ 変わらない |
| **オブジェクトを破壊するか？** | ✅ `append()`、`set()` | ❌ `toString()`、`substring()` |
| **外部出力をするか？** | ✅ `print()`, `write()` | ❌ 内部処理だけ |
| **再実行して結果が変わる可能性があるか？** | ✅ 入力待ち、乱数、時刻 | ❌ 完全に決まった結果 |

---

副作用の理解は、**バグの防止・テストの設計・関数型プログラミング**を学ぶうえで非常に重要です。

さらに興味があれば、「副作用のあるメソッド設計時のベストプラクティス」や、「Javaでの純粋関数的設計」もご紹介できます！

# Q,

> オブジェクトを破壊するか？	✅ append()、set()	❌ toString()、substring()
> 

解説中、上記記載についてappend(), set()の他にあればまとめてください。

はい、Hiroakiさんのご要望どおり、

**「オブジェクトを破壊する（＝内部状態を変更する）副作用のあるメソッド」**を代表的なクラスごとにまとめてご紹介します。

ここで言う「破壊」とは：

> そのオブジェクトの状態を変えてしまい、再利用時に元の値が使えなくなる処理です。
> 

---

## ✅ 副作用を伴う（破壊的）メソッドの代表例

### 🔷 `StringBuilder` / `StringBuffer`

| メソッド | 内容 |
| --- | --- |
| `append(...)` | 文字列を末尾に追加 |
| `insert(int, ...)` | 指定位置に挿入 |
| `delete(int, int)` | 指定範囲の文字を削除 |
| `deleteCharAt(int)` | 指定位置の1文字を削除 |
| `replace(int, int, String)` | 範囲を置き換え |
| `reverse()` | 文字列を反転 |
| `setCharAt(int, char)` | 指定位置の文字を変更 |
| `setLength(int)` | 長さを変更（短縮またはパディング） |

🧠：**すべて同じ `StringBuilder` インスタンスに対して直接作用**します。

---

### 🔷 `List`（例：`ArrayList`）

| メソッド | 内容 |
| --- | --- |
| `add(...)` | 要素を追加 |
| `remove(...)` | 要素を削除 |
| `set(int, E)` | 指定位置の要素を変更 |
| `clear()` | すべての要素を削除 |
| `sort(...)` | 要素の並び順を変更 |
| `retainAll(...)`, `removeAll(...)` | 条件に合う要素を破棄・保持 |

🧠：**コレクションは参照を共有していると、外からも影響を受けやすい点に注意。**

---

### 🔷 `Map`

| メソッド | 内容 |
| --- | --- |
| `put(K, V)` | 要素を追加または上書き |
| `remove(K)` | 指定キーの要素を削除 |
| `clear()` | 全要素削除 |
| `putAll(...)` | 他のMapの内容を追加 |
| `compute(...)`, `merge(...)` | 値を条件付きで変更 |

---

### 🔷 `Arrays` ユーティリティ（静的だが破壊的操作）

| メソッド | 内容 |
| --- | --- |
| `Arrays.sort(array)` | 配列そのものの順序を変更（破壊的） |
| `Arrays.fill(array, value)` | 全要素を同じ値で上書き |

---

## ❗ 補足：非破壊（非副作用）なメソッドの例との対比

| クラス | 非破壊メソッド | 内容 |
| --- | --- | --- |
| `String` | `substring()`, `toUpperCase()` | 新しいオブジェクトを返すだけ |
| `List`（Stream API） | `stream().filter(...).collect(...)` | 元のリストは変更されない |
| `Arrays` | `copyOf(...)`, `stream(...)` | 新しい配列やストリームを作るだけ |

---

## ✅ まとめ

副作用（破壊）を起こす代表的なメソッドは、以下のように整理できます：

- **可変オブジェクトに対して直接状態を変える操作**
- 典型的には `append`, `set`, `add`, `remove`, `sort`, `clear` など
- **破壊的な操作はコードの予測可能性を下げる**ため、必要性と影響を明確に意識することが重要です

---

必要であれば、「副作用を避ける設計」や「イミュータブルコレクションの活用法」についてもご紹介します！

# Q,

> 外部出力をするか？	✅ print(), write()	❌ 内部処理だけ
> 

解説中、上記記載についてprint(), write()の他にあればまとめてください。

とても良い視点です、Hiroakiさん！

**「外部出力をする＝副作用がある」**という観点から、

`print()`, `write()` の他にどんなメソッドが該当するかを体系的にまとめます。

---

## ✅ 外部出力を行う代表的なメソッド群（＝副作用あり）

### 🔷 1. **標準出力（コンソール）**

| メソッド | 説明 |
| --- | --- |
| `System.out.print(...)` | コンソールに出力（改行なし） |
| `System.out.println(...)` | コンソールに出力（改行あり） |
| `System.out.printf(...)` | フォーマット付き出力 |
| `System.err.print(...)` | エラーストリームに出力 |

🧠 標準出力への書き込みは **ユーザーやログへの外部通知**という意味で副作用です。

---

### 🔷 2. **ファイル出力**

| メソッド | 説明 |
| --- | --- |
| `FileWriter.write(...)` | ファイルに文字を書き込む |
| `BufferedWriter.write(...)` | バッファ付きで書き込む |
| `PrintWriter.println(...)` | ファイルや他の出力先に行単位で出力 |
| `Files.write(Path, byte[])` | ファイルにバイト列を書き込む（Java NIO） |

---

### 🔷 3. **ネットワーク出力**

| メソッド | 説明 |
| --- | --- |
| `OutputStream.write(...)` | ソケットなどの出力ストリームにデータ送信 |
| `PrintStream.print(...)` | ネットワークストリームに出力可（System.outもこれ） |
| `HttpURLConnection.getOutputStream().write(...)` | HTTPボディを送信 |

🧠 これらは **外部システムや他プロセスに影響を及ぼす**ため、典型的な副作用です。

---

### 🔷 4. **GUIへの描画・更新**

| メソッド | 説明 |
| --- | --- |
| `JLabel.setText(...)` | 画面表示が変わる |
| `JTextArea.append(...)` | テキスト表示が変わる |
| `Graphics.drawString(...)` | 画面に描画する |

🧠 表示が変わる＝「ユーザーの見ている世界を変える」＝副作用と考えます。

---

### 🔷 5. **ログ出力**

| メソッド | 説明 |
| --- | --- |
| `Logger.info(...)`, `warn(...)`, `error(...)` | ログファイルや標準出力に出力 |
| `System.out.println(...)`（ログ代用） | 単純なログ用途でも副作用扱い |

---

### 🔷 6. **DBへの書き込み**

| メソッド | 説明 |
| --- | --- |
| `PreparedStatement.executeUpdate()` | DBに挿入・更新・削除（副作用大） |
| `JdbcTemplate.update(...)` | Spring JDBCでの変更系操作 |
| `EntityManager.persist(...)` | JPAによる保存処理 |

---

## ✅ まとめ：外部出力として副作用を持つ代表的メソッド

| 分類 | 代表メソッド例 |
| --- | --- |
| 標準出力 | `print()`, `println()`, `printf()` |
| ファイル出力 | `write()`, `println()`, `Files.write()` |
| ネットワーク送信 | `OutputStream.write()`, `getOutputStream()` |
| GUI描画 | `setText()`, `drawString()` |
| ログ出力 | `Logger.info()`, `System.out.println()` |
| データベース変更 | `executeUpdate()`, `persist()` |

---

## 🧠 補足：なぜ「外部出力」は副作用なのか？

- 実行環境の**外部状態に変化を与える**
- 同じ引数で呼んでも、**出力先の状態や時間によって動作が変わる可能性がある**
- **テストや再利用が難しくなる**

---

もし興味があれば、「副作用を切り離す設計（Command-Query分離原則など）」や「ログ出力と純粋関数の両立方法」についてもお話しできますよ！