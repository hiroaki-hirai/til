# null 安全性

# Q,

null 安全について確認です。
標準APIについては、基本的に null 安全を担保するようにバリデーションが組み込まれている。
ただし、オーバーライドを予定しているメソッドに関しては、自身でnull安全を組み込む必要がある。
という認識は合っていますか？

はい、Hiroakiさんのご認識は**概ね正しい**ですが、少しだけ補足・整理しておくとより明確になります。

---

## ✅ 結論：標準APIの `null` 安全性とオーバーライド設計の整理

### 🔹 標準API（Java SE ライブラリ）の `null` 対応

| 観点 | 説明 |
| --- | --- |
| **入力時のnull検査** | 多くのAPIは `null` に対して `NullPointerException` を明示的に投げる設計（例：`Objects.requireNonNull()` を使用） |
| **出力時のnull返却** | `Map.get()` などは `null` を返すことがある（＝存在しないことのシグナルとして） |
| **明示的なnull禁止** | `List.of(null)` など、不変コレクションAPIでは明確に `null` 禁止 → `NullPointerException` が即時発生 |
| **非null明示のアノテーション** | 一部APIでは `@NonNull` や `@Nullable` アノテーション（主にIDEや静的解析向け） |

→ **安全性を保つため、ライブラリ内部でバリデーションが施されていることが多い**

ただし、完全に `null-safe` というよりは、「**`null` が来たらエラーで知らせる設計**」が基本です。

---

### 🔹 オーバーライドする側（自身のコード）での対応

| 観点 | 説明 |
| --- | --- |
| **オーバーライド対象のメソッドにnullが来る可能性** | インターフェースや抽象クラスのメソッドは、**契約としてnullを想定しない設計が多い**（ただしドキュメントで確認要） |
| **自身のオーバーライド実装でのバリデーション** | `null` が来る可能性がある場合は、自衛的に `Objects.requireNonNull()` などで明示チェックを行うべき |
| **公開メソッドは防御的設計が必要** | ライブラリ提供者やAPI開発者は、呼び出し元のミスも想定して `null` をチェックすべき |

→ **オーバーライド時は、自分で `null` 安全を担保する必要があるケースが多い**です。

---

## ✅ 例：オーバーライドメソッドでの null 対応

```java
@Override
public void accept(String input) {
    Objects.requireNonNull(input, "input must not be null");
    System.out.println(input.toUpperCase());
}
```

このように、自身が `Consumer<String>` などの関数型インターフェースを実装する場合にも、**防御的にチェックするのが望ましい**です。

---

## ✅ 総まとめ：認識の修正ポイント

| 項目 | Hiroakiさんの認識 | 補足・調整後の説明 |
| --- | --- | --- |
| 標準APIはnull安全か？ | 基本的に安全 | ✔ ただし「nullを防ぐ」というより「nullならエラーを明示的に投げる」設計が多い |
| オーバーライド時の対応 | 自分で対応が必要 | ✔ 正解。引数がnullの可能性があるなら、**防御的チェックが必要** |
| 全APIがnullチェック済みか | ◯（と見える） | ❌ 一部はnullを許容（例：Map.get）、また `null` を受け取ることを仕様としているAPIもある |

---

## ✅ 追加で押さえておくと良い知識

- `Objects.requireNonNull(obj)` は簡易 `null` チェックで NPE を即時に投げる
- `Optional` の導入（Java 8以降）により、nullを返す代わりに「値がある/ない」を表現するモダンAPIが増えている
- Spring などのDIコンテナでも、nullチェックは開発者責任となる場面が多い