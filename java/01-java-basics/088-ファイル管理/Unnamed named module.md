# Unnamed named module

# Q,

通常、eqlipseにてコードを作成しようとした場合、自分で作成するパッケージは、Baseモジュール内に作成している認識はあっていますか？

はい、Hiroakiさんの認識は**状況によっては正しい**ですが、少しだけ補足が必要です。

以下で **「Baseモジュール内に作成される」とは何を指すのか**を明確にしながら、Eclipseの挙動とモジュールシステムとの関係を整理します。

---

## ✅ 結論（先に答え）

> Eclipseでモジュールを使っていない通常のプロジェクトを作成した場合、作成するパッケージは「モジュールに属さない（unnamed module）」に属しています。
> 
> 
> つまり、「Baseモジュール」ではなく「**モジュールなし（未命名モジュール）**」の中です。
> 

---

## 🔷 Eclipseプロジェクトとモジュールの関係

### ① `module-info.java` が**ない**プロジェクト

- 作成するクラスやパッケージは、すべて **「Unnamed Module」** に所属します。
- クラスパスベースの動作になり、モジュールシステムは働きません。

👉 **この状態がデフォルト（一般的）**です。

---

### ② `module-info.java` を**自分で作成した場合**

- 明示的な **「Named Module（名前付きモジュール）」** になります。
- Eclipse上では、そのプロジェクト全体がモジュールと見なされ、書いた `module-info.java` の内容に基づいてアクセス制御されます。

---

## 🔸「Baseモジュール」とは？

Hiroakiさんが言う「Baseモジュール」が以下のどれかによって意味が変わります：

| 表現 | 実際の意味 |
| --- | --- |
| `java.base` モジュール | JDK標準の最小モジュール。すべてのモジュールが暗黙的に依存しています。 |
| Eclipse上の「src」 | プロジェクトのルートディレクトリ。モジュールとは無関係です。 |
| 自作モジュールの名前 | 自分で作成した `module-info.java` によって定義されたモジュール名 |

---

## 🔍 Eclipseで確認するには？

1. `module-info.java` が存在しない → → 未命名モジュール（モジュール制御なし）
2. `module-info.java` を自分で作成した → → それが「モジュール」であり、作成するパッケージは**そのモジュールに属する**

---

## ✅ 補足：自作パッケージはどのモジュールに属するか？

| 状況 | 所属するモジュール |
| --- | --- |
| `module-info.java` がない | **Unnamed Module**（非モジュール型） |
| `module-info.java` を作成した | **Named Module**（自作モジュール） |

---

## ✅ 結論（再掲）

> Eclipseで普通にプロジェクトを作成し、module-info.java を書いていない場合、自作パッケージは「Unnamed Module」に属します。
> 
> 
> つまり、**Baseモジュールという名前のモジュールに属しているわけではありません**（ただし、`java.base`モジュールには自動的に依存しています）。
> 

---

ご希望があれば、以下のトピックも補足できます：

- Eclipseでモジュールプロジェクトを作る手順
- `module-info.java` を追加する方法と影響
- 「Unnamed Module」内でのアクセス制御の特徴

お気軽にお知らせください！

# Q,

実務では、Named Moduleのほうが一般的でしょうか？

とても良い質問です。

結論から言うと：

---

## ✅ 結論

> 2025年時点の実務では、Named Module（名前付きモジュール）はまだ一般的とは言えません。
> 
> 
> 多くのプロジェクトは依然として **Unnamed Module（非モジュール型／クラスパスベース）** を使っています。
> 

---

## 🔍 理由と背景

### ❶ **実務の多くは Java 8～17 を対象**

- Java 9 でモジュールシステムが導入されましたが、**完全な移行はしていないプロジェクトが多数**。
- Spring Boot、Maven、Gradle などの主要エコシステムが **クラスパス前提で設計されている部分が多い**。

---

### ❷ **移行コストが高い**

- 既存のライブラリやフレームワークが Named Module に完全対応していない。
- モジュール境界に合わせて `exports`・`requires` を書く必要があり、**構造変更が大がかりになる可能性あり**。

---

### ❸ **利点が活きる場面が限定されている**

| Named Module が有利な場面 | 説明 |
| --- | --- |
| セキュリティの高い環境 | 内部APIのカプセル化が厳密にできる |
| 組み込み系や軽量JREを構築したい場合 | `jlink` によるJRE最適化 |
| SDKやAPIライブラリを提供する場合 | 明示的な公開・非公開制御が便利 |

※逆に、社内向けのWebアプリなどでは過剰になることが多いです。

---

## 📊 現実的な採用状況（目安）

| プロジェクトの種類 | Named Module の採用傾向 |
| --- | --- |
| 一般的なWebアプリ（Spring等） | ❌ あまり使われない（classpath） |
| SDK・ライブラリ提供 | ✅ 利用される場合がある |
| Java SEベースのツール | ✅ 採用されることもある |
| 小規模・個人開発 | ❌ 通常は使わない |

---

## 🔧 補足：Spring Boot とモジュールシステムの関係

Spring BootなどのDIフレームワークはリフレクション（`Class.forName()`）を多用します。

そのため `opens` を細かく書く必要があり、**モジュールシステムとの相性があまり良くない**です。

---

## ✅ 結論（再掲）

> 実務では、Named Module は限定的に使われているのが現状です。
> 
> 
> 特に大規模プロジェクトやセキュリティ重視のケース、ライブラリ開発などでは検討されますが、
> 
> **一般的な業務アプリ開発では未導入のケースが多く、クラスパスベースが主流です。**
> 

---

必要であれば、「導入すべきかどうかの判断基準」や「段階的に導入する方法」などもお伝えできます。興味ありますか？