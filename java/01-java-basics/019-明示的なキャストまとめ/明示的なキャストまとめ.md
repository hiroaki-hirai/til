# 明示的なキャストまとめ

# Q,

本来、大きな範囲の値を小さな型の変数に代入するときには明示的なキャストが必要ですが、その例外として、int型の値をbyteやshort型の変数に代入する場合は明示的なキャストは不要という理解で合っていますか？
また、このような例外は他にありますか？

Hiroakiさんのご認識は**一部正しくて一部誤解が含まれています**。以下で正確に整理します。

---

### ✅ 正しい理解

Javaでは、**リテラルの `int` 値** が **代入先の型の範囲内に収まる場合**、明示的なキャストなしに `byte` や `short` に代入可能です。

### 例（OKなケース）:

```java
byte b = 100;       // OK: 100 は byte の範囲内（-128〜127）
short s = 30000;    // OK: 30000 は short の範囲内（-32,768〜32,767）
```

これが可能なのは、**「コンパイル時に値が確定していて範囲内である」**と判断できるからです。

---

### ❌ 誤解のある点

同じ `int` でも、**変数や式の場合はキャストが必要**です。

### 例（NGなケース）:

```java
int i = 100;
byte b = i;         // コンパイルエラー：明示的なキャストが必要
```

```java
byte b = (byte) i;  // 明示的キャストでOK
```

---

### 🔁 他に同様の例外（リテラル→代入可能なケース）

| 代入先型 | 代入元リテラル | 条件 |
| --- | --- | --- |
| `byte` | `int`リテラル | -128〜127の範囲ならOK |
| `short` | `int`リテラル | -32,768〜32,767の範囲ならOK |
| `char` | `int`リテラル | 0〜65535の範囲ならOK（文字コード範囲） |

```java
char c = 65;       // OK（'A'の文字コード）
char c = -1;       // NG（charは負を持てない）
```

---

### ✅ ポイントまとめ

| パターン | 明示的キャスト必要？ | 条件 |
| --- | --- | --- |
| `int`リテラル → `byte/short/char` | ❌ 不要 | 値が範囲内で**リテラル**であること |
| `int`変数 → `byte/short/char` | ✅ 必要 | 暗黙の変換は不可（変数の値はコンパイル時に不明） |

以下に、**Java Silver試験対策として「int → byte/short/char」のキャストに関する**よくある**ひっかけ例題集**をまとめました。各問題には**正誤理由**と**補足解説**も添えています。

---

## ✅ 例題集：int → byte/short/char のひっかけ問題

---

### ❶ 【リテラル → byte】明示的キャスト不要？

```java
byte b = 100;
System.out.println(b);
```

**Q: コンパイルは通るか？**

✅ **答え：通る**

**理由**：100は `byte` の範囲内（-128〜127）かつ**リテラル**のため、自動で型変換される。

---

### ❷ 【変数 → byte】暗黙変換できるか？

```java
int i = 100;
byte b = i;
System.out.println(b);
```

**Q: コンパイルは通るか？**

❌ **答え：通らない**

**理由**：`int` 変数を `byte` に代入するには**明示的キャストが必要**。値が範囲内でも不可。

---

### ❸ 【式 → short】これは通るか？

**Q: コンパイルは通るか？**

```java
short s = 10 + 20;
System.out.println(s);
```

✅ **答え：通る**

**理由**：`10 + 20` はコンパイル時に評価され、結果 `30` は `short` の範囲内。**定数畳み込み（constant folding）**が起こるためキャスト不要。

---

### ❹ 【式（変数あり）→ short】これはどうか？

```java
final int x = 10;
short s = x + 20;
```

**Q: コンパイルは通るか？**

✅ **答え：通る**

**理由**：`x` が `final` かつ初期化済みなら定数扱いとなり、式の結果はコンパイル時に判定できる。

---

### ❺ 【式（非final）→ short】

```java
int x = 10;
short s = x + 20;
```

**Q: コンパイルは通るか？**

❌ **答え：通らない**

**理由**：`x` が `final` でないため、式の結果が定数とみなされず、`int` → `short` は暗黙変換できない。

---

### ❻ 【charへの負のリテラル】

```java
char c = -1;
```

**Q: コンパイルは通るか？**

❌ **答え：通らない**

**理由**：`char` は符号なし（0～65535）。負数は代入できない。

---

### ❼ 【charへの範囲内のintリテラル】

```java
char c = 65;
System.out.println(c);
```

**Q: コンパイルは通るか？**

✅ **答え：通る**

**理由**：65は `char` の範囲内。これは `'A'` として出力される。

---

### ❽ 【byteのオーバーフロー確認】

```java
byte b = 128;
```

**Q: コンパイルは通るか？**

❌ **答え：通らない**

**理由**：128は `byte` の範囲（-128～127）を超えるため、暗黙変換できない。

---

## 🔁 補足：暗黙変換される唯一の例

| 型 | 代入元がintリテラル | 範囲内ならキャスト不要 |
| --- | --- | --- |
| byte | ✅ | ✅ |
| short | ✅ | ✅ |
| char | ✅ | ✅（0以上のみ） |

ただし、**変数や計算式（非final）**は **例外なくキャストが必要**。

以下に、**Java Silver試験レベルでひっかけやすい「long」「float」「double」関連の代入・キャスト問題集**を、前回と同じ形式で整理しました。

---

## ✅ 例題集：long / float / double への代入キャストのひっかけ問題

---

### ❶ 【int → long】明示的キャストは必要？

```java
int i = 100;
long l = i;
```

**Q: コンパイルは通るか？**

✅ **答え：通る**

**理由**：`int` → `long` は**拡大変換（widening conversion）**なのでキャスト不要。

---

### ❷ 【longリテラル → int】

```java
int i = 100L;
```

**Q: コンパイルは通るか？**

❌ **答え：通らない**

**理由**：`100L` は `long` リテラル。`long` → `int` は**縮小変換**で、**明示的キャストが必要**。

---

### ❸ 【小数リテラル → float】

```java
float f = 3.14;
```

**Q: コンパイルは通るか？**

❌ **答え：通らない**

**理由**：`3.14` は `double` 型リテラル。`double` → `float` は縮小変換。明示的キャストが必要。

✅ 正しく書くなら：

```java
float f = 3.14f;
```

または

```java
float f = (float) 3.14;
```

---

### ❹ 【floatリテラル → double】

```java
double d = 1.23f;
```

**Q: コンパイルは通るか？**

✅ **答え：通る**

**理由**：`float` → `double` は拡大変換。暗黙変換OK。

---

### ❺ 【intリテラル → float】

```java
float f = 100;
```

**Q: コンパイルは通るか？**

✅ **答え：通る**

**理由**：`int` → `float` は拡大変換。リテラルでも変数でもOK。

---

### ❻ 【doubleリテラル → int】

```java
int i = 10.0;
```

**Q: コンパイルは通るか？**

❌ **答え：通らない**

**理由**：`10.0` は `double`。`double` → `int` は縮小変換。明示的キャストが必要。

---

### ❼ 【double → float（キャストあり）】

```java
double d = 9.8;
float f = (float) d;
```

**Q: コンパイルは通るか？**

✅ **答え：通る**

**理由**：明示的にキャストしているためOK。

---

### ❽ 【float → int（キャストなし）】

```java
float f = 5.5f;
int i = f;
```

**Q: コンパイルは通るか？**

❌ **答え：通らない**

**理由**：`float` → `int` は縮小変換。キャストが必要。

---

### ❾ 【式中にdoubleがある場合】

```java
int i = 1 + 2.0;
```

**Q: コンパイルは通るか？**

❌ **答え：通らない**

**理由**：`1 + 2.0` の結果は `double`。`double` → `int` にはキャストが必要。

✅ 正しく書くには：

```java
int i = (int)(1 + 2.0);
```

---

### 🔟 【long → float という拡大変換】

```java
long l = 10000000000L;
float f = l;
```

**Q: コンパイルは通るか？**

✅ **答え：通る**

**理由**：`long` → `float` は拡大変換。ただし**精度は失われる可能性あり**（floatは23bit精度）。

---

## 🔁 まとめ表：拡大変換・縮小変換のポイント

| 変換 | キャスト不要 | 備考 |
| --- | --- | --- |
| `int → long` | ✅ 拡大変換 | 自動でOK |
| `int → float` | ✅ 拡大変換 | 精度に注意 |
| `long → float` | ✅ 拡大変換 | 精度劣化あり |
| `float → int` | ❌ 必要 | 縮小変換、明示キャスト必須 |
| `double → float` | ❌ 必要 | 縮小変換、キャスト必須 |
| `double → int` | ❌ 必要 | 同上 |

Hiroakiさんが既に押さえている「基本的なプリミティブ型（byte, short, int, long, float, double, char）」間の**拡大変換・縮小変換**に加えて、以下のような**応用的または見落としやすいパターン**もあります：

---

## ✅ その他の応用・盲点パターン（Silver〜Goldレベル）

---

### ❶ 【char → int への拡大変換（暗黙OK）】

```java
char c = 'A';
int i = c;  // OK
```

- **`char` → `int` は拡大変換扱い**（charは0〜65535の符号なし整数）

---

### ❷ 【byte + byte の結果は int】

```java
byte a = 10;
byte b = 20;
byte c = a + b;  // ❌ コンパイルエラー
```

- 理由：**byte + byte の結果は int 型**になるため、`byte` に代入するにはキャストが必要。

✅ 修正例：

```java
byte c = (byte)(a + b);
```

---

### ❸ 【boolean は変換対象外】

```java
boolean flag = true;
int i = flag;  // ❌ コンパイルエラー
```

- **boolean型は他の型と相互変換できない唯一のプリミティブ型**。

---

### ❹ 【算術式に混在する複数の型】

```java
int i = 10;
double d = 2.5;
double result = i + d;  // OK: int → double に自動拡大
```

- Javaは**式全体の型を自動的に昇格**（最も広い型に）します。

---

### ❺ 【数値 → char の縮小変換】

```java
int i = 65;
char c = (char) i;  // OK（明示キャスト）
System.out.println(c);  // → 'A'
```

- `int` → `char` は縮小変換なので**キャスト必須**。

---

### ❻ 【long → double の拡大変換】

```java
long l = 1234567890123456789L;
double d = l;  // OKだが、精度の損失あり
```

- **拡大変換だが精度劣化に注意**（doubleは約15桁精度）

---

### ❼ 【final 変数と定数畳み込み】

```java
final int x = 100;
byte b = x;  // OK: x が final で範囲内なら例外的にキャスト不要
```

---

## ❌ 存在しない変換（問われることあり）

| 型 | 変換の可否 | 解説 |
| --- | --- | --- |
| boolean ↔ int 等 | ❌ 一切変換不可 | 暗黙も明示キャストも不可 |
| float → boolean | ❌ 不可 | 条件式にboolean型を期待 |
| double → char | ❌ 明示キャスト必要 | 縮小変換、範囲超過に注意 |

---

### ✅ 応用理解のための暗記ポイント（Goldレベル向け）

- `byte`, `short`, `char` → 計算式に使うと**intに昇格**
- 演算式中で最も広い型に全体が拡大される（例：`int + float → float`）
- 精度重視 → `BigDecimal` / `BigInteger`（ただしSilver範囲外）