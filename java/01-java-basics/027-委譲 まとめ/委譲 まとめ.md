# 委譲 まとめ

```java
public static String valueOf(Object obj) {
    return (obj == null) ? "null" : obj.toString();
}
```

null 安全性確保＋toString() 委譲という解説がありました。
ここでは、valuOfメソッドに実引数として代入された値の型によってObjectクラスを継承している各クラスでオーバーライドされたtoStringメソッドに処理が移る(委譲)、という動作をしますが、こういった仕組みのみが委譲に当たりますか？
委譲を組み込むときのパターンは何通りかありますか？

とても本質的で深い質問です。

おっしゃるとおり、`String.valueOf(Object obj)` における `obj.toString()` の呼び出しは、**「toStringメソッドの呼び出し責任を委ねる」という意味での委譲（delegation）」**にあたります。

しかし、それは「委譲」の中の**ごく一部の代表的パターン**に過ぎません。

---

## ✅ 結論：委譲はもっと広い概念であり、「処理の一部または全部を他のオブジェクトに任せること」

- 「委譲」は単なる `obj.toString()` のような **メソッド呼び出し** だけでなく、
- より広く「**オブジェクト設計上の責任の分散方法**」として使われます。

---

## ✅ 代表的な「委譲」のパターンと実装例（Java的視点）

---

### ① **メソッド呼び出しの委譲（最も単純）**

```java
public class Printer {
    public void print(String message) {
        System.out.println(message);
    }
}

public class Logger {
    private Printer printer = new Printer();

    public void log(String message) {
        printer.print("[LOG] " + message);  // ← 委譲
    }
}
```

- `Logger` が `Printer` の責務（出力）を「**委譲**」している
- ✅ **主に「処理を一部任せる」目的**

---

### ② **インターフェース実装の委譲（戦略パターンやラッパーに多い）**

```java
public interface Authenticator {
    boolean authenticate(String user, String password);
}

public class DefaultAuthenticator implements Authenticator {
    public boolean authenticate(String user, String password) {
        return "admin".equals(user);
    }
}

public class SecureSystem {
    private Authenticator authenticator;

    public SecureSystem(Authenticator auth) {
        this.authenticator = auth;
    }

    public void login(String user, String pass) {
        if (authenticator.authenticate(user, pass)) {
            System.out.println("Login OK");
        }
    }
}
```

- ✅ **実装の切り替えを可能にする**委譲パターン（戦略パターン）
- 内部的に処理を任せている

---

### ③ **委譲を使った継承の代替（構成 vs 継承）**

```java
public class Engine {
    public void start() {
        System.out.println("Engine started");
    }
}

public class Car {
    private Engine engine = new Engine();

    public void drive() {
        engine.start();  // 委譲
        System.out.println("Car is moving");
    }
}
```

- ✅ 「Car is-a Engine」とせず、「Car has-a Engine」として**構成による再利用**
- オブジェクト指向設計における「**継承より委譲**」の好例

---

### ④ **Javaの標準APIでも委譲されている例**

- `Collections.unmodifiableList(list)` などは、内部で **元のリストに操作を委譲**して読み取りだけ許可
- `String.valueOf()` → 実際は `toString()` を**オブジェクトに任せる**

---

## ✅ 「委譲」を組み込むパターンの代表分類（4種類）

| パターン | 主な用途 | 例 |
| --- | --- | --- |
| メソッド単位の委譲 | 責務分離、部品化 | `printer.print()` |
| インターフェース経由の委譲 | 柔軟な戦略切り替え、依存性注入 | `Authenticator` |
| コンポジション（構成）の委譲 | 継承の代替、再利用 | `Engine` を持つ `Car` |
| 標準APIによる委譲 | ラッパーや安全制御 | `Collections.unmodifiableList` |