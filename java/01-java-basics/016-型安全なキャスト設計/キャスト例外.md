# キャスト例外

# Q,

親クラスA、子クラスBでそれぞれに同じ子クラスでオーバーライドされたメソッドがある場合、エントリーポイントにて以下のコードは、コンパイルエラーにはならないが、例外が走るということですが、その解説をお願いします。

```java
A a = new A();
B b = (B) a;
b.hello();
```

はい、これはとても良い質問です。

以下のコードは**コンパイルは通るが、実行時に `ClassCastException` が発生します**。

```java
A a = new A();
B b = (B) a;     // ← ここで例外が発生する
b.hello();
```

---

## 🔍 結論：なぜ例外が発生するのか？

### ❗`ClassCastException` の原因：

- 変数 `a` の実体は **`A` クラスのオブジェクト**。
- それを `B` 型にキャストしているが、`a` は **本物の `B` ではない**。
- Javaでは「実体がBである」必要があるため、**不正なキャストと判定されて例外が発生**します。

---

## 🧠 詳しく：キャストのルール

```java
A a = new A();      // 実体は A
B b = (B) a;        // 実体は B ではないため、失敗
```

- Javaでは**コンパイル時には型の継承関係だけを見て判断**します。
- でも**実行時には実体の型**（インスタンスのクラス）がチェックされ、合わなければ `ClassCastException` が発生します。

---

## ✅ 正常に動くコード（逆のケース）

```java
A a = new B();      // 実体は B
B b = (B) a;        // 実体も B → キャスト成功
b.hello();          // B の hello() が呼ばれる
```

この場合は、**実体が `B`** なので安全にキャストできます。

---

## 🧪 確認用コード

```java
class A {
    void hello() {
        System.out.println("Hello from A");
    }
}

class B extends A {
    @Override
    void hello() {
        System.out.println("Hello from B");
    }
}

public class Main {
    public static void main(String[] args) {
        A a = new A();       // 実体は A
        B b = (B) a;         // ← ここで ClassCastException
        b.hello();           
    }
}
```

---

## 🛠 補足：実体の型を確認するには？

キャストの前に `instanceof` を使ってチェックすると安全です：

```java
if (a instanceof B) {
    B b = (B) a;
    b.hello();
} else {
    System.out.println("a is not an instance of B");
}
```

---

何が起きているかを図解で見たい場合もご希望があれば用意できます！