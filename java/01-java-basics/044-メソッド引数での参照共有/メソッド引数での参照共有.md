# メソッド引数での参照共有

Javaにおける「**メソッド引数での参照共有**」は、**引数として渡されたオブジェクトの内部状態がメソッド内で変更されると、呼び出し元にもその変更が反映される**という非常に重要な概念です。

---

## ✅ Javaの引数渡しの本質

Javaでは**すべての引数渡しは「値渡し」**です。

ただし、**参照型の場合は「参照値（ポインタ）」が値として渡される**ので、**結果的に呼び出し元のオブジェクトに影響を与えることができる**という動作になります。

---

## 🔍 基本イメージ（参照型の値渡し）

```java
void modify(StringBuilder sb) {
    sb.append("X");
}

public static void main(String[] args) {
    StringBuilder original = new StringBuilder("A");
    modify(original);
    System.out.println(original); // → AX
}
```

### 🔸 どうして「AX」と出力されるのか？

- `original` は `new StringBuilder("A")` というオブジェクトの**参照値**を保持
- `modify(original)` のとき、その**参照値のコピー**が `sb` に渡される
- `sb` は同じオブジェクトを指しているため `.append("X")` によって**オブジェクトの中身が変更される**

---

## 🔸 変数の関係図（イメージ）

```java
original ───────┐
                ▼
            [ StringBuilder("A") ] → .append("X") → "AX"

sb (引数) ───────┘（同じオブジェクトを指している）
```

---

## ✅ 重要：参照先は共有されるが、**再代入すると別物**

```java
void reassign(StringBuilder sb) {
    sb = new StringBuilder("B");
}

public static void main(String[] args) {
    StringBuilder original = new StringBuilder("A");
    reassign(original);
    System.out.println(original); // → A（変わらない）
}
```

### なぜ？

- `sb = new StringBuilder("B");` で**新しいオブジェクトを参照するようになっただけ**
- 呼び出し元の `original` は依然として `"A"` のオブジェクトを指している

---

## ✅ 結論（Javaのメソッド引数の特徴）

| 項目 | 説明 |
| --- | --- |
| Javaの引数渡し | **値渡し**（参照値も含む） |
| 参照型の挙動 | オブジェクトの**中身は変更できる** |
| 再代入の挙動 | 引数側で `=` しても**呼び出し元には影響しない** |
| 変更が伝播するケース | メソッド内で**参照先の中身を変更**したときのみ |

---

## ✅ まとめコード比較

### 🟢 中身を変更（変化は伝わる）

```java
void change(List<String> list) {
    list.add("X");
}
```

🔴 再代入（変化は伝わらない）

```java
void change(List<String> list) {
    list = new ArrayList<>();
    list.add("X");
}
```

# Q,

sb = original ということですね。
これは、先ほどの拡張for文の参照の共有と同じとみていますがあっていますか？

はい、**その理解は完全に正しいです。**

---

## ✅ 結論：

> sb = original; という代入は、
> 
> 
> **拡張for文で `sb` に `builders[i]` の参照が渡される**ことと本質的に同じです。
> 

---

## 🔍 具体的に並べて比較すると：

### ◾ 通常の参照代入パターン：

```java
StringBuilder original = new StringBuilder("A");
StringBuilder sb = original;
sb.append("X");
System.out.println(original); // → AX（同じオブジェクトを共有）
```

---

### ◾ 拡張for文の参照共有パターン：

```java
StringBuilder[] builders = {
    new StringBuilder("a"),
    new StringBuilder("b")
};

for (StringBuilder sb : builders) {
    sb.append("X");
}
// builders[0] → "aX", builders[1] → "bX"
```

---

## ✅ 共通点は「**参照値のコピー**」

どちらも以下のような動作をしています：

- **参照型の変数に別の参照値を代入**
- 変数が違っても**指しているオブジェクトが同じ**
- そのため、**オブジェクトの内部を変更すれば他の参照元にも反映される**

---

## 🧠 イメージ（どちらもこうなる）

```java
original → 🧱 "A"
sb       ─┘（同じ🧱を指している）

builders[0] → 🧱 "a"
sb（拡張for文） ─┘（同じ🧱を指している）
```

---

## ✅ 補足：拡張for文がやっていること（イメージ）

```java
for (StringBuilder sb : builders) {
    // 実質的に
    // for (int i = 0; i < builders.length; i++) {
    //     StringBuilder sb = builders[i];
    //     sb.append("X");
    // }
}
```

---

## ✅ まとめ

| 概念 | 説明 |
| --- | --- |
| `sb = original` | originalの参照値をsbにコピー（同じオブジェクトを指す） |
| `sb : builders`（拡張for） | builders[i] の参照値をsbにコピー（同上） |
| 結果 | sbからオブジェクトを変更すると、元の変数にも反映される |

# Q,

防御的コピーは、new で新しくオブジェクトを作成することで参照の共有をはずすものという理解ですがあっていますか？
また、参照の切り離し方も同じでしょうか？

はい、Hiroakiさんの理解は**非常に正確**です。

「防御的コピー」も「参照の切り離し」も、**`new` で新しいオブジェクトを生成することによって、元のオブジェクトと参照を共有しない状態を作る**という点で共通しています。

ただし、それぞれの**目的と文脈**には違いがありますので、以下に整理して解説します。

---

## ✅ 防御的コピー（Defensive Copy）

### 🔹 意味：

外部から渡されたオブジェクトの**参照をそのまま使うと危険なので**、**`new` でコピーして安全な状態を作る手法**。

### 🔹 主な目的：

- **不正な変更を防ぐ**
- **オブジェクトの不変性（immutability）を守る**

### 🔹 具体例：

```java
class Person {
    private final Date birthDate;

    public Person(Date birthDate) {
        this.birthDate = new Date(birthDate.getTime()); // 防御的コピー
    }

    public Date getBirthDate() {
        return new Date(birthDate.getTime()); // 外部への参照漏れ防止
    }
}
```

✅ なぜ必要？

```java
Date d = new Date();
Person p = new Person(d);
d.setTime(0); // ← 元のDateを変更しても
System.out.println(p.getBirthDate()); // ← pの中は安全（コピーされてるから）
```

---

## ✅ 参照の切り離し（Reference Decoupling）

### 🔹 意味：

変数同士が**同じオブジェクトを参照している状態から意図的に切り離す**こと。

**目的は「干渉を防ぐ」「独立した状態にしたい」**とき。

### 🔹 主な目的：

- **別々の状態を持ちたい**
- **副作用を防ぎたい**
- 一般的には「**防御的コピーの応用的な側面**」

### 🔹 具体例：

```java
StringBuilder a = new StringBuilder("X");
StringBuilder b = a;        // 参照共有（b.append → aにも影響）
b = new StringBuilder(a.toString()); // 参照の切り離し（aとbは別物）
```

---

## ✅ 両者の共通点と違い

| 項目 | 防御的コピー | 参照の切り離し |
| --- | --- | --- |
| 方法 | `new` や `.clone()` などでコピーを作る | `new` や `.toString()` などでコピー |
| 主な目的 | 外部からの予期しない変更を防ぐ | 共有をやめて別状態を持たせる |
| 対象 | フィールド・引数・戻り値など | 任意の参照変数 |
| タイミング | 受け取った瞬間 or 返す瞬間 | 状況に応じて任意 |
| よく使う文脈 | 不変オブジェクト、ライブラリの安全設計 | 自分でロジックを書くときの安全対策 |

---

## 🧠 補足：コピーの種類

| 種類 | 内容 | 例 |
| --- | --- | --- |
| **浅いコピー（Shallow Copy）** | フィールドの参照だけコピー | `new ArrayList<>(oldList)` |
| **深いコピー（Deep Copy）** | フィールドの中身も再帰的にコピー | 手動で全要素をコピー／clone実装 |