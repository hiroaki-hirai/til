# Hash～

# Q,

HashSet などのハッシュコードで管理されるデータ群は、どのような基準でコードを割り振られるのでしょうか？
仮に "C", "B", "A" という順序で追加されたデータならどうなるでしょうか？

良い質問です。`HashSet` などのハッシュベースのコレクション（`HashMap`、`HashTable` など含む）では、**オブジェクトの `hashCode()` に基づいてデータの格納場所が決定**されます。以下で詳しく説明します。

---

### 🔸 `HashSet` の仕組み概要

- `HashSet` は内部的に `HashMap` を使用しています。
- 要素を追加すると、そのオブジェクトの `hashCode()` を計算し、**配列（バケット）内のインデックス**を決定します。
- そのインデックスに、要素が格納されます（衝突があればリストやツリー構造で解決）。

---

### 🔹 `hashCode()` の基準

Java の `Object` クラスにはデフォルトの `hashCode()` 実装がありますが、多くのクラス（例: `String`, `Integer` など）はこれを**オーバーライド**しています。

### 例：`String` の `hashCode()` の計算式

```java
s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
```

例：

```java
"A".hashCode() = 65
"B".hashCode() = 66
"C".hashCode() = 67
```

---

### 🔸 `"C", "B", "A"` の順で `HashSet` に追加した場合

```java
Set<String> set = new HashSet<>();
set.add("C");
set.add("B");
set.add("A");
```

このとき：

- `hashCode()` の順で内部的にバケットに格納される。
- **順序は保証されない**（`Set` は順序保持しない）。
- `toString()` や `for-each` で表示すると、追加順ではない可能性が高い。

### 実際の出力例（JDKバージョンや実装依存）：

```java
[A, B, C]
または
[B, A, C]
または
[C, A, B]
など順不同
```

---

### 🔹 順序を保証したい場合は？

- `LinkedHashSet` を使用すると「追加順」を保持します。
- `TreeSet` を使えば「ソート順（自然順序やコンパレータ）」で保持します。

---

### ✅ 補足：バケットの決定と再ハッシュ

- `hashCode()` の値は配列サイズ（通常は2の累乗）で割った**剰余**で、バケットインデックスが決まります。
- 例えば配列サイズが 16 なら `hashCode() % 16`。
- サイズが拡張されると、**再ハッシュ**が行われ、バケットの位置も変わる可能性があります。

---

### ✅ まとめ

| 項目 | 説明 |
| --- | --- |
| `hashCode()` | オブジェクトのハッシュ値（数値） |
| 使用目的 | バケット（配列インデックス）の決定 |
| `HashSet` の順序 | 保証されない（`hashCode()` と等価性のみに基づく） |
| 保持順を保証したい場合 | `LinkedHashSet`（追加順）または `TreeSet`（ソート順）を使う |

---

ご希望であれば、`LinkedHashSet`・`TreeSet` での出力比較コードもご用意します！