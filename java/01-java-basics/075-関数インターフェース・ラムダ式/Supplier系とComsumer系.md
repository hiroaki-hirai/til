# Supplier系とComsumer系

# Q,

引数を受け取らず処理を走らせ、その結果を戻す場合（Supplier系）と、引数を受け取ってその値を元に処理をして、結果は戻さない場合(Consumer系)。

結果を返す場合は、その結果の値を変数や引数へ代入して次の処理に使用できる。
結果を返さない場合は、その時点の処理のみ実行。

上記の認識は合っていますか？

はい、Hiroakiさんのご認識は**非常に正確です**。

Supplier系・Consumer系の関数インタフェースの**入出力の設計的な意味と用途の違い**を的確に捉えています。

以下に、それぞれの役割とその意図を整理します。

---

## ✅ Supplier系とConsumer系の違い（目的と使い道）

| 種類 | 役割 | 入力 | 出力 | 典型用途 |
| --- | --- | --- | --- | --- |
| `Supplier<T>` | **値を提供する** | なし | 値を返す（T） | 遅延実行・キャッシュ・設定取得 |
| `Consumer<T>` | **値を使って処理を実行する** | 値を受け取る（T） | 返さない（void） | ログ出力・保存・副作用のある処理 |

---

## 🎯 認識の検証

> 引数を受け取らず処理を走らせ、その結果を戻す場合（Supplier系）
> 
> 
> → ✅ **合っています。**
> 
- 引数なし
- 戻り値あり（処理結果を次に使える）

```java
Supplier<String> supplier = () -> "value";
String result = supplier.get(); // → 結果を変数に格納して次に使える
```

---

> 引数を受け取ってその値を元に処理をして、結果は戻さない場合(Consumer系)
> 
> 
> → ✅ **これも合っています。**
> 
- 引数あり
- 戻り値なし（その場で処理して終わり）

```java
Consumer<String> consumer = val -> System.out.println(val);
consumer.accept("hello"); // → その場で処理して完了、戻り値なし
```

---

## ✅ 設計観点での意味の違い

| 観点 | Supplier | Consumer |
| --- | --- | --- |
| 関心 | 「**何かを作る・返す**」こと | 「**何かを使って処理する**」こと |
| 再利用性 | 高い（戻り値を別処理に流用可能） | 一過性（その場限りの実行） |
| 状態 | 状態を**生成**する | 状態を**消費・反映**する |

---

## ✅ 実務での使い分けの例

| 処理 | 使用する関数型 |
| --- | --- |
| 設定値の読み込み | `Supplier<Config>` |
| ユーザー入力をDBに保存 | `Consumer<User>` |
| リストをログ出力 | `Consumer<List<?>>` |
| トークン生成 | `Supplier<String>` |

---

## ✅ 補足：関数型4分類との関係

| 入力 | 出力 | 対応する型 | 用途 |
| --- | --- | --- | --- |
| なし | あり | `Supplier<T>` | 値の提供・遅延評価 |
| あり | なし | `Consumer<T>` | 処理実行・副作用 |
| あり | あり | `Function<T, R>` | 値の変換・処理結果の利用 |
| あり×2 | あり | `BiFunction<T, U, R>` | 複数入力から1出力 |

---

## ✅ 結論

Hiroakiさんのまとめ：

> 結果を返す場合は、その結果の値を変数や引数へ代入して次の処理に使用できる。
> 
> 
> 結果を返さない場合は、その時点の処理のみ実行。
> 

→ **はい、正しいです。** それぞれが担う「責任のスコープの違い」をよく表しています。

---

必要があれば、Function系・BiFunction系・Operator系との違いもあわせて整理できます。