# 関数インタフェース一覧

# Q,

RunnableやCallableも含めて、関数インタフェースの機能一覧等を作成してください。

以下に、Javaの代表的な関数型インタフェース（Functional Interface）を目的・構造・主な用途とともに整理した「機能一覧表」をお示しします。

**`Runnable` や `Callable` を含む全体像**として、参照や比較に便利な構成です。l

---

## ✅ Javaの主要関数型インタフェース：機能一覧表

| インタフェース名 | メソッド構文 | 引数 | 戻り値 | 用途 / 特徴 |
| --- | --- | --- | --- | --- |
| **Runnable** | `void run()` | × | × | 引数・戻り値なしの処理（並列処理だけでなく汎用にも） |
| **Callable<V>** | `V call() throws Exception` | × | ○ | 戻り値付きの非同期・並列処理（`ExecutorService` 等で使用） |
| **Supplier<T>** | `T get()` | × | ○ | 値を生成して返す。引数なしで戻り値がある処理（遅延実行など） |
| **Consumer<T>** | `void accept(T t)` | ○ | × | 引数を受け取り処理のみ行う。副作用を伴う処理に |
| **BiConsumer<T, U>** | `void accept(T t, U u)` | ○2つ | × | 2引数のConsumer（ログ出力、マッピング処理など） |
| **Function<T, R>** | `R apply(T t)` | ○ | ○ | 引数を加工し、別の型を返す（値変換やマッピング処理） |
| **BiFunction<T, U, R>** | `R apply(T t, U u)` | ○2つ | ○ | 2引数を処理して1つの戻り値を返す |
| **UnaryOperator<T>** | `T apply(T t)` | ○ | ○（同型） | 同じ型で変換（例：数値の加算、文字列整形など） |
| **BinaryOperator<T>** | `T apply(T t1, T t2)` | ○2つ | ○（同型） | 2つの同型値を処理して1つにする（加算、比較など） |
| **Predicate<T>** | `boolean test(T t)` | ○ | ○（boolean） | 条件チェックやフィルタに使う |
| **BiPredicate<T, U>** | `boolean test(T t, U u)` | ○2つ | ○ | 2引数の論理判定 |

---

## ✅ よく使う場面と目的別分類

### 🎯 値を「返す」系（戻り値あり）

| 名前 | 用途例 |
| --- | --- |
| `Supplier<T>` | デフォルト値の遅延生成、キャッシュ読み込み |
| `Function<T, R>` | 値の変換（文字列 → 数値など） |
| `UnaryOperator<T>` | 値の加工（trim、toUpperCaseなど） |
| `Callable<V>` | スレッド内で結果を返す処理 |
| `Predicate<T>` | 条件判定（nullチェック、範囲条件など） |

---

### ⚙️ 処理「のみ」実行（戻り値なし）

| 名前 | 用途例 |
| --- | --- |
| `Runnable` | 何かを実行するだけの処理（非同期・UI更新・ログ） |
| `Consumer<T>` | 値を使って副作用（出力、DB書き込みなど） |
| `BiConsumer<T, U>` | Mapへのput処理、複数値のログ出力など |

---

### 🔄 複数引数で「変換」や「演算」したい場合

| 名前 | 用途例 |
| --- | --- |
| `BiFunction<T, U, R>` | 2つの値を受け取り、新しい値を生成（例：合成ID） |
| `BinaryOperator<T>` | 数値の合算、最大・最小の取得 |
| `BiPredicate<T, U>` | 2値の比較（equals、範囲内チェックなど） |

---

## ✅ 補足：カスタム関数インタフェースを使いたい場合

Javaでは必要に応じて独自の関数インタフェースを作成可能です：

```java
@FunctionalInterface
interface Action {
    void execute(); // Runnableと同等（より意図的に書ける）
}
```

---

## ✅ 全体マップ：Java関数インタフェース早見図

```java
         ┌────────────┐
         │ Runnable   │ ← 引数× 戻り値×
         └────────────┘
         ┌────────────┐
         │ Callable<V>│ ← 引数× 戻り値〇（例外あり）
         └────────────┘
         ┌────────────┐
         │ Supplier<T>│ ← 引数× 戻り値〇
         └────────────┘
         ┌────────────┐
         │ Consumer<T>│ ← 引数〇 戻り値×
         └────────────┘
         ┌──────────────┐
         │ BiConsumer<T,U>│ ← 引数2 戻り値×
         └──────────────┘
         ┌────────────┐
         │ Function<T,R>│ ← 引数〇 戻り値〇
         └────────────┘
         ┌────────────────────┐
         │ BiFunction<T,U,R>  │ ← 引数2 戻り値〇
         └────────────────────┘
         ┌─────────────────┐
         │ UnaryOperator<T>│ ← Functionのサブ型（T→T）
         └─────────────────┘
         ┌──────────────────┐
         │ BinaryOperator<T>│ ← BiFunctionのサブ型（T×T→T）
         └──────────────────┘
         ┌────────────┐
         │ Predicate<T>│ ← 引数〇 戻り値 boolean
         └────────────┘
         ┌─────────────────┐
         │ BiPredicate<T,U>│ ← 引数2 戻り値 boolean
         └─────────────────┘
```

---

## ✅ まとめ

| 分類 | インタフェース | 特徴 |
| --- | --- | --- |
| 引数も戻り値も不要 | `Runnable` | 汎用実行処理に使える（並列処理以外もOK） |
| 引数なし、戻り値あり | `Supplier<T>` / `Callable<T>` | 遅延評価や非同期処理に |
| 引数あり、戻り値なし | `Consumer<T>` | 副作用（出力・登録など）に使う |
| 引数あり、戻り値あり | `Function<T, R>` | 値の変換やマッピング処理に |
| 条件評価系 | `Predicate<T>` | フィルターやバリデーションに便利 |

---

必要であれば「これらのインタフェースをいつどのように使い分けるべきか」「現場での使用パターンとアンチパターン」なども整理可能です。

# Q,

上記のまとめを確認すると、CallableとSupplierの構成が似ていますが、CallableはRunnableとは違い、並行・並列処理に使用ケースが限定される認識は合っていますか？

はい、Hiroakiさんの認識は**おおむね正確**ですが、より明確に整理すると以下のようになります。

---

## ✅ Callable vs Supplier の違いと使い分け

| 特徴 | `Callable<V>` | `Supplier<T>` |
| --- | --- | --- |
| 📦 インタフェース定義 | `V call() throws Exception` | `T get()` |
| ✅ 戻り値あり | 〇 | 〇 |
| ❌ 例外スロー可能 | 〇（`throws Exception` あり） | ✕（例外はスローできない） |
| 🔁 並行・並列処理前提 | **基本的に YES**（`ExecutorService.submit()` などで使用） | **NO**（汎用的な遅延実行用） |
| 🛠️ 用途 | スレッドタスクの非同期処理（＋戻り値あり） | 遅延評価、構成値の生成、メソッド引数での処理委譲など |

---

### ✅ 使い方の実例で整理

### Callable の使用例（スレッドプールで非同期実行）

```java
ExecutorService executor = Executors.newSingleThreadExecutor();

Callable<String> task = () -> {
    Thread.sleep(1000);
    return "完了";
};

Future<String> result = executor.submit(task);
System.out.println(result.get());  // ← 完了（ブロックあり）
```

- **特徴**：`submit()` などで並行処理されるタスクを記述する用途に特化
- **例外処理が必要**：`call()` メソッドは `throws Exception`

---

### Supplier の使用例（Optional, Stream, DI などで遅延実行）

```java
Supplier<String> messageSupplier = () -> "遅延生成メッセージ";
System.out.println(messageSupplier.get());
```

- **特徴**：その場で使える汎用関数。Optionalの `orElseGet()`、Streamの `generate()` にも利用
- **軽量かつ例外なし**

---

## ✅ まとめ：Hiroakiさんの認識との照合

| 項目 | Hiroakiさんの認識 | 実際の整理 |
| --- | --- | --- |
| CallableはRunnableとは異なる | ✅ 正しい | Callableは戻り値あり＋例外スロー可 |
| Callableは並列処理に使う | ✅ ほぼ正しい | 実質的に`ExecutorService.submit()`等と組み合わせて使うことが多い |
| Supplierと構造が似ているが用途が異なる | ✅ 正しい | 構造は似ているが、用途と例外処理で明確に差別化されている |

---

もし必要であれば「Runnable / Callable / Supplier / Future の設計構造図」や、「関数インタフェースの選定マトリクス」もご用意します。