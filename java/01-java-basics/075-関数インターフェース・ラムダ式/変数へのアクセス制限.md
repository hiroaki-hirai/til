# 変数へのアクセス制限

# Q、

ラムダ式内からアクセスできる変数は、final宣言されているか、実質的にfinalでなければならい認識ですが、それはなぜですか？

はい、Hiroakiさんのご認識どおりです。

Javaの**ラムダ式（lambda expression）内で参照できるローカル変数は、`final`か"実質的にfinal"でなければなりません。**

これは**Javaの仕様であり、内部的な仕組み（クロージャ）に関係しています。**

以下、理由と背景をわかりやすく解説します。

---

## 🔍 結論：なぜ「final」または「実質的にfinal」が必要か？

### ✅ 1. **ラムダ式はクロージャとして動作する**

- ラムダ式は「囲っているスコープ（外側の変数）」に**アクセスできる関数オブジェクト**です。
- しかし、Javaでは**変数の"コピー"がラムダに渡される**という性質があるため、
    - 元の変数が**変更可能だと一貫性が保証できなくなる**。

```java
void test() {
    int x = 10;
    Runnable r = () -> System.out.println(x); // OK: x は実質的に final
}
```

→ `x` が後から変更されないことが保証されていれば、ラムダ式は安心して使える。

---

### ✅ 2. **ラムダ式内から使う変数はコンパイル時にキャプチャされる**

- Javaのラムダ式は、**対象のローカル変数を値として「キャプチャ」**します（copy by value）。
- そのため、ラムダの外側で変数が変更されると、**ラムダ内との整合性が崩れる**可能性があります。

```java
void test() {
    int num = 5;
    Runnable r = () -> System.out.println(num); // 実質finalならOK
    num = 10; // エラー！ numはfinalではない
}
```

→ `num` が後から変更される可能性があると、`r` が正しい値を参照できる保証ができません。

---

### ✅ 3. **Javaの安全設計ポリシー**

- Javaは**マルチスレッドでも安全に動くこと**を前提にしている言語です。
- ラムダ式が**遅延実行されることが多い**ため、非finalな変数にアクセスさせると**タイミングによって値が変わってしまう**可能性があります。
- これを防ぐために、「**ラムダ内で使うローカル変数は、変更されないことを保証する（final）**」というルールがあるのです。

---

## ✅ 用語整理：「実質的にfinal」とは？

```java
int x = 10; // ここでxは実質的にfinal
x = 20;     // これはNG → もはや「実質的にfinal」ではない
```

- 「実質的にfinal」とは、「**一度も再代入されていない変数**」という意味です。
- `final`キーワードがなくても、一度しか代入されていなければコンパイル時に「これはfinal扱いで安全だ」と判断されます。

---

## ✅ まとめ

| ポイント | 説明 |
| --- | --- |
| ❗ 制限の理由 | ラムダ式が変数の**コピー（値）をキャプチャ**するから |
| ✅ 必要条件 | 変数は`final`または**実質的にfinal** |
| 🧠 背景 | 実行タイミングの違い・マルチスレッドでも安全に使えるように |
| 💡 例外 | インスタンス変数やstatic変数はこの制限を受けない（参照できる） |

---

興味があれば、**内部的にラムダ式がどのように変換されているか（例：匿名クラスとの違い）**も解説できます！

# Q,

ラムダ式のように、変数のコピーが渡される場合と、変数そのものへアクセスできる場合と異なる認識ですがあっていますか？
認識通りであれば、どういったケースがそれぞれにあたるか整理してください。

はい、Hiroakiさんの認識は**非常に正確**です。

Javaでは、**「変数のコピーが渡されるケース」と「変数そのものへアクセスできるケース」**が明確に区別されており、**対象となる変数のスコープや種類**によって挙動が異なります。

以下に、それぞれのケースと具体例を整理して解説します。

---

## ✅ 1. **コピー（値）としてキャプチャされる変数**

### 🟢 該当ケース：**ローカル変数（メソッド内変数）**

ラムダ式や匿名クラスから参照されるローカル変数は、**実行時に変数の値（コピー）をキャプチャ**します。

### 🔒 特徴

- **変更不可（finalまたは実質final）**
- **値のコピーであって、変数そのものではない**
- 外部で変更してもラムダに反映されない

### 🧪 例：

```java
void test() {
    int x = 10; // 実質final
    Runnable r = () -> System.out.println(x); // xはキャプチャされる（コピー）
    r.run(); // 出力：10
    // x = 20; // ← エラー！xはラムダで使っているので再代入不可
}
```

---

## ✅ 2. **変数そのものにアクセスできるケース**

### 🟡 該当ケース：

- **インスタンス変数**
- **クラス変数（static）**
- **配列やオブジェクトの参照（ただし参照自体がfinalである必要あり）**

### 🔓 特徴

- ラムダ式や匿名クラスから**自由にアクセス・変更できる**
- 値ではなく**変数そのものへの参照**が渡っている

### 🧪 例1：インスタンス変数

```java
class MyClass {
    int count = 0;

    void runTask() {
        Runnable r = () -> count++; // OK：インスタンス変数は直接アクセス可
        r.run(); // count == 1
    }
}
```

### 🧪 例2：配列やオブジェクトの参照

```java
void test() {
    int[] arr = {1}; // 参照は実質final
    Runnable r = () -> arr[0]++; // OK：配列要素は変更可能
    r.run(); // arr[0] == 2
}
```

> 🔍補足：arr自体の参照は変更できない（final的扱い）が、参照先の内容は変更できるというポイントが重要です。
> 

---

## ✅ まとめ表

| 変数の種類 | ラムダからのアクセス | 値のコピー or 参照 | 再代入可能か |
| --- | --- | --- | --- |
| **ローカル変数** | ○（ただしfinal/実質final） | 値のコピー | ❌ 不可（読み取り専用） |
| **インスタンス変数** | ○ | 参照 | ✅ 可 |
| **static変数** | ○ | 参照 | ✅ 可 |
| **配列/オブジェクトのフィールド** | ○（参照がfinalならOK） | 参照（内部状態変更可） | ✅ 可 |

---

## ✅ さらに踏み込むと…

### ❓ なぜローカル変数は「コピー」なのか？

Javaでは、メソッド内のローカル変数は**スタック上に展開されてメソッド終了とともに消える**ため、

ラムダ式や匿名クラスが**後から実行されたときに参照できるように「コピー」を保存しておく**必要があります。

一方、インスタンス変数やstatic変数は**ヒープ上にあり生存期間が長い**ため、**参照のままで安全**です。

---

## ✅ 補足：Java以外との違い（例：JavaScript）

| 言語 | キャプチャ方式 | 備考 |
| --- | --- | --- |
| Java | 値キャプチャ（読み取り専用） | スコープ外のローカル変数はコピー |
| JavaScript | 変数キャプチャ（参照） | 外部のローカル変数も変更可能 |

---

必要であれば「ラムダ式 vs 匿名クラスの変数キャプチャの違い」も比較できますので、お気軽にどうぞ！