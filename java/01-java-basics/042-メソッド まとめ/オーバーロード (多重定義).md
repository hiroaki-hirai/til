# オーバーロード (多重定義)

以下にJava Silver〜Goldの試験対策として有効な「**オーバーロード（Overload）**」に関する**パターン問題（ひっかけ含む）**を作成しました。

各問題に「**設問＋選択肢＋正解＋解説**」の形式でまとめています。

---

## ✅ オーバーロード問題①：基本構文の確認

```java
class OverloadTest {
    void print(int x) {
        System.out.println("int: " + x);
    }

    void print(String x) {
        System.out.println("String: " + x);
    }

    public static void main(String[] args) {
        OverloadTest ot = new OverloadTest();
        ot.print(100);
        ot.print("hello");
    }
}
```

Q1. 上記コードの出力として正しいものを選べ。

```java
int: 100  
String: hello
```

**正解：B**

**解説：** 引数の型によってメソッドが切り替わる。Javaは引数の型が異なれば別メソッドとみなす。

---

## ✅ オーバーロード問題②：型変換の優先順位

```java
class OverloadTest {
    void show(double x) {
        System.out.println("double");
    }

    void show(Integer x) {
        System.out.println("Integer");
    }

    public static void main(String[] args) {
        OverloadTest ot = new OverloadTest();
        ot.show(10); // ← int型リテラル
    }
}
```

### Q2. 実行結果として正しいものは？

A. double

B. Integer

C. コンパイルエラー

D. 実行時エラー

**正解：A**

**解説：** `10` は `int` → `double` に**自動型変換（拡大変換）される。`Integer` へのボクシングは拡大変換より優先度が低い**。

---

## ✅ オーバーロード問題③：可変長引数との競合

```java
class OverloadTest {
    void process(int x) {
        System.out.println("int");
    }

    void process(int... x) {
        System.out.println("int...");
    }

    public static void main(String[] args) {
        OverloadTest ot = new OverloadTest();
        ot.process(10);
    }
}
```

### Q3. 実行結果として正しいものを選べ。

A. int...

B. int

C. コンパイルエラー

D. 実行時エラー

**正解：B**

**解説：** `int` 単体のメソッドがあるため、可変長引数よりも**通常の一致する引数のメソッドが優先**される。

---

## ✅ オーバーロード問題④：戻り値の違いのみ

```java
class OverloadTest {
    int getValue() {
        return 10;
    }

    double getValue() {
        return 10.0;
    }
}
```

### Q4. このコードのコンパイル結果として正しいものは？

A. 正常にコンパイルされる

B. オーバーロードとして認識される

C. コンパイルエラーになる

D. 実行時に例外が発生する

**正解：C**

**解説：** **戻り値の型が違うだけではオーバーロードとはみなされない**。引数の型や数が違っていなければエラー。

---

## ✅ オーバーロード問題⑤：nullと参照型の曖昧性

```java
class OverloadTest {
    void print(String s) {
        System.out.println("String");
    }

    void print(Object o) {
        System.out.println("Object");
    }

    public static void main(String[] args) {
        OverloadTest ot = new OverloadTest();
        ot.print(null);
    }
}
```

### Q5. 実行結果として正しいものは？

A. Object

B. String

C. コンパイルエラー

D. 実行時エラー

**正解：B**

**解説：** `null` はどちらの参照型にも代入可能だが、**より具体的な型（String）のメソッドが優先される**。

---

## 📌 補足：頻出ひっかけポイント

| パターン | 解説 |
| --- | --- |
| `戻り値の型だけ違う` | × オーバーロードにならない（コンパイルエラー） |
| `可変長 vs 配列 vs 通常引数` | 通常 → 配列 → 可変長 の順に優先 |
| `null` を渡した場合 | より下位の型（サブクラス）が優先 |
| `プリミティブ vs ラッパー vs 自動変換` | 自動変換（拡大）がボクシングより優先される |

以下に「**オーバーロード vs オーバーライドの違い**」と「**コンストラクタのオーバーロード**」に関する問題を、Java Silver/Gold 試験風の形式で作成します。

---

## ✅ セクション①：オーバーロード vs オーバーライド 比較問題

---

### 🔷 Q1. オーバーロードとオーバーライドの違いとして**正しいもの**はどれか。

（複数選択）

A. オーバーロードはメソッド名が異なる必要がある

B. オーバーライドは引数の型や数を変えてもよい

C. オーバーロードは戻り値の型だけが違えばよい

D. オーバーライドはアクセス修飾子を広くしてもよい

E. オーバーロードは同一クラス内でも起きるが、継承関係の場合はそのクラス間でも起きる

F. オーバーライドは親クラスのメソッドを上書きする

**正解：D, E, F**

**解説：**

- A × → オーバーロードは「同じ名前」で引数が違う
- B × → オーバーライドは「引数が同じ」必要がある
- C × → 戻り値の違いだけではオーバーロードにならない
- D ○ → アクセス修飾子は広くするのはOK（狭くするとコンパイルエラー）
- E ○ → オーバーロードは同じクラス内＋継承関係
- F ○ → オーバーライドは継承関係で親メソッドを上書きする

---

### 🔷 Q2. 次のコードの出力結果として正しいものを選べ。

```java
class Parent {
    void greet() {
        System.out.println("Hello from Parent");
    }
}

class Child extends Parent {
    void greet(String name) {
        System.out.println("Hello " + name + " from Child");
    }
}

public class Test {
    public static void main(String[] args) {
        Child c = new Child();
        c.greet();
    }
}
```

A. Hello from Parent

B. Hello from Child

C. コンパイルエラー

D. Hello null from Child

**正解：A**

**解説：** `greet(String)` は**オーバーライドではなくオーバーロード**（引数が違うため）。

`greet()` は親クラスにしかないが、継承されているためそのまま呼び出される。

---

## ✅ セクション②：コンストラクタのオーバーロード 問題

---

### 🔷 Q3. 以下のコードの出力として正しいものを選べ。

```java
class Book {
    String title;

    Book() {
        this("No Title");
        System.out.println("No-arg constructor");
    }

    Book(String title) {
        this.title = title;
        System.out.println("Title constructor: " + title);
    }
}

public class Main {
    public static void main(String[] args) {
        Book b = new Book();
    }
}
```

```java
Title constructor: No Title  
No-arg constructor
```

**正解：B**

**解説：**

- `Book()` コンストラクタから `this("No Title")` により別のコンストラクタが呼ばれる → `Book(String)` が先に実行される
- その後、`Book()` の中の `System.out.println("No-arg constructor")` が出力される
- `this(...)` は**コンストラクタの最初の文でなければならない**

---

### 🔷 Q4. 次のコードは何を出力するか？

```java
class Sample {
    Sample(int x) {
        System.out.println("int");
    }

    Sample(double x) {
        System.out.println("double");
    }

    public static void main(String[] args) {
        new Sample(5);     // int型リテラル
        new Sample(5.0f);  // float型リテラル
    }
}
```

```java
int  
double
```

**正解：A**

**解説：**

- `5` → `int` 型 → `Sample(int)`
- `5.0f` → `float` → 直接一致はないが、`float → double` は拡大変換 → `Sample(double)`

---

## 📌 補足まとめ：Overload vs Override 比較表

| 観点 | オーバーロード | オーバーライド |
| --- | --- | --- |
| メソッド名 | 同じ | 同じ |
| 引数 | 違ってよい | 完全一致が必要 |
| 戻り値の型 | 違ってよい（引数が違えば） | 同じかサブ型 |
| 発生場所 | 同一クラス内 | サブクラスが親クラスを上書き |
| アクセス修飾子 | 影響しない | 親クラスより広くする必要あり |
| アノテーション | 付けない／任意 | `@Override` を推奨 |