# メソッド選択の優先度

この優先順位は、**メソッド呼び出し時の引数の「解決ルール（メソッド選択の優先度）」**に基づいています。

---

## ✅ 優先順位：プリミティブ引数のオーバーロード解決ルール

```java
void show(int x)
void show(double x)
void show(Integer x)
```

```java
ot.show(10); // int型リテラル
```

このとき、Javaは次の順序で解決します：

| 優先度 | 方法 | 解説 |
| --- | --- | --- |
| ① | 完全一致（exact match） | `int` → `show(int)`（◎） |
| ② | 拡大変換（widening primitive conversion） | `int` → `double`（○） |
| ③ | ボクシング（boxing conversion） | `int` → `Integer`（△） |
| ④ | 可変長引数（varargs） | 最後の手段（×） |

---

## 🔍 他に比較できる代表的な型と変換順

以下のような型でも類似の変換ルールが適用されます。

### 例：`char` の場合

```java
void show(int x)      // 拡大変換
void show(char x)     // 完全一致
void show(Character x) // ボクシング
```

```java
ot.show('A');
```

→ `show(char)` が選ばれます（完全一致が最優先）

---

## 🔁 プリミティブ型の拡大変換表（widening）

| 変換元 | 変換可能な型（優先順） |
| --- | --- |
| byte | short → int → long → float → double |
| short | int → long → float → double |
| char | int → long → float → double |
| int | long → float → double |
| long | float → double |
| float | double |

---

## 🆚 オートボクシングとの違い（重要）

| 用語 | 説明 | 優先度 |
| --- | --- | --- |
| 拡大変換（widening） | `int → double` のようにプリミティブ同士 | 高い |
| ボクシング（boxing） | `int → Integer` のようにプリミティブからラッパー | 低い |

つまり「**ボクシングは拡大変換よりも優先度が低い**」です。

---

## ✅ 補足：ラッパー型からの変換（アンボクシング）

```java
void show(int x)
void show(Object o)
```

```java
Integer i = 10;
ot.show(i);
```

→ `Integer` → **アンボクシングして `int`** → `show(int)` が呼ばれます。

---

## 🎯 まとめ：優先度の順番ルール

```java
① 完全一致（exact match）
② 拡大変換（widening）
③ ボクシング／アンボクシング（boxing/unboxing）
④ varargs（可変長引数）
⑤ Object型などへの最終委譲
```

# Q,

どのオーバーロードが選択されるかの優先順位を確認したいです。配列型の場合も込みで整理してください。

承知しました。

Javaで**どのオーバーロードされたメソッドが選択されるか**について、**基本的な解決ルールと、配列型を含む優先順位**を体系的に整理します。

---

## 🔷 Javaのメソッドオーバーロード解決ルール（基本編）

Javaのオーバーロード解決は**コンパイル時**に次の順序で判断されます。

### 優先順位（上に行くほど優先される）

| 優先 | 解決方法 | 例 |
| --- | --- | --- |
| ① | **完全一致（exact match）** | `foo(int)` に `int` 渡す |
| ② | **ボクシング／アンボクシングなしのWidening（拡張変換）** | `int → long` や `float → double` |
| ③ | **ボクシング（Boxing）** | `int → Integer` |
| ④ | **Widening + Boxing**（JLSで明確に非推奨） | `int → long → Long` |
| ⑤ | **varargs（可変長引数）** | `foo(int...)` |

---

## 🔷 配列型が関わる場合の優先順位

### 🧩 前提：配列型 vs 可変長引数（varargs）は明確に区別される

| 引数の型 | 呼び出し側の書き方 | 解釈 |
| --- | --- | --- |
| `int[]` | `foo(new int[]{1,2})` | 配列を渡している |
| `int...` | `foo(1,2)` or `foo(new int[]{1,2})` | 可変長引数扱い |

---

## 🔸 配列 vs 可変長引数の優先順位

| 優先 | シグネチャ | 対象引数 | 説明 |
| --- | --- | --- | --- |
| ① | `foo(int[])` | `new int[]{1,2}` | 配列として完全一致：**最優先** |
| ② | `foo(Object)` | `new int[]{1,2}` | 配列も `Object` として見なせる：**一段下** |
| ③ | `foo(int...)` | `1, 2` or `new int[]{1,2}` | 可変長引数は**最終手段** |

---

## 🔷 具体例での比較

### 例1：`int[]` vs `int...`

```java
void foo(int[] arr) {
    System.out.println("int[]");
}
void foo(int... arr) {
    System.out.println("int...");
}

foo(new int[]{1, 2});  // → int[] が呼ばれる
foo(1, 2);             // → int... が呼ばれる
```

### **例2：`Object` vs `int[]`**

```java
void foo(Object obj) {
    System.out.println("Object");
}
void foo(int[] arr) {
    System.out.println("int[]");
}

foo(new int[]{1, 2});  // → int[] が優先される（配列の完全一致）
```

### 例3：ボクシング vs 配列

```java
void foo(Integer i) {
    System.out.println("Integer");
}
void foo(int[] arr) {
    System.out.println("int[]");
}

foo(10);               // → Integer（ボクシング）
foo(new int[]{1, 2});  // → int[]（完全一致）

```

---

## 🔷 配列型の Widening（拡張）

- 配列同士の Widening も可能です（**ただし共変性に基づく**）
- `int[] → Object` ✅
- `String[] → Object[]` ✅
- `int[] → Object[]` ❌（プリミティブ配列は参照型配列と互換性なし）

```java
Object obj = new int[]{1,2};     // OK
Object[] objArr = new String[2]; // OK
Object[] objArr2 = new int[2];   // コンパイルエラー
```

---

## 🔚 まとめ：オーバーロードの解決優先順位（配列含む）

| 優先順位 | 内容 | 備考 |
| --- | --- | --- |
| ① | 完全一致（型がぴったり） | `int → int`, `int[] → int[]` |
| ② | プリミティブ拡張変換（widening） | `int → long` |
| ③ | ボクシング／アンボクシング | `int → Integer`, `Integer → int` |
| ④ | 配列の型一致 vs `Object` | `int[] → int[]` が `int[] → Object` より優先 |
| ⑤ | 可変長引数（varargs） | 最後の手段、他の候補がない場合のみ |

必要であれば、このルールの**JLS（Java Language Specification）上の出典や根拠**も示せます。ご希望あればお知らせください。