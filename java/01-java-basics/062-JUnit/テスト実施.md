# テスト実施

# Q,

JUnit の大まかな使用法としてどのようなテストを実施するのでしょうか？

とても良い質問です。

JUnit は Java における**単体テスト（ユニットテスト）を行うためのフレームワークで、主に以下のようなさまざまなレベルのテスト**に使用されます。

---

## ✅ JUnitの主なテスト用途（大分類）

| テストの種類 | 説明 |
| --- | --- |
| ✅ 単体テスト（ユニットテスト） | メソッド・クラス単位でロジックの正しさを検証する |
| ✅ 例外テスト | 例外が適切にスローされるかを検証する |
| ✅ 境界値テスト | 0、負数、最大値などの**極端な入力**に対する動作を確認する |
| ✅ 副作用のない状態検証 | フィールドの値、戻り値など**出力が正しいか**を検証する |
| ✅ モックを使った依存制御 | 他のクラスや外部リソースとの依存を**分離してテスト**する |

---

## 🔹 よく使うアノテーション（JUnit 5）

| アノテーション | 用途 |
| --- | --- |
| `@Test` | テスト対象のメソッドに付ける |
| `@BeforeEach` | 各テストの前に毎回実行される初期化処理 |
| `@AfterEach` | 各テストの後に毎回実行される後始末処理 |
| `@BeforeAll` | 全テストの前に1回だけ実行される処理（static） |
| `@AfterAll` | 全テストの後に1回だけ実行される処理（static） |
| `@DisplayName` | テスト名を見やすく表示 |
| `@Disabled` | テストの一時的な無効化 |
|  |  |

---

## 🔸 使用例：計算クラスのユニットテスト

### ① テスト対象クラス

```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public int divide(int a, int b) {
        return a / b;  // 0で割ると例外
    }
}
```

### ② テストクラス（JUnit 5）

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class CalculatorTest {

    Calculator calc = new Calculator();

    @Test
    void testAdd() {
        assertEquals(5, calc.add(2, 3));  // 正常系テスト
    }

    @Test
    void testDivideByZero() {
        assertThrows(ArithmeticException.class, () -> calc.divide(10, 0));  // 例外テスト
    }
}
```

---

## ✅ よく行われるテスト内容（一覧）

| テストの種類 | 例 |
| --- | --- |
| **正常系** | 入力が正しいとき、期待した出力が得られるか |
| **異常系** | 不正な入力や状況で適切な例外が発生するか |
| **境界値** | 0, -1, Integer.MAX_VALUE などの極端な入力で動作が正しいか |
| **空データ** | 空の配列・nullなどに対して落ちないか |
| **副作用の有無** | メソッドの呼び出しによって内部状態や外部リソースが適切に変更されたか |

---

## 🔸 補足：JUnit は「どう使うか」が重要

- テストは「品質保証」＋「リファクタリングの保険」
- テストコードは**本番コードと同じくらい重要**
- *変更に強い設計（テストしやすいコード）**が求められる

---

## ✅ まとめ

| 項目 | 内容 |
| --- | --- |
| JUnitの役割 | Javaの単体テスト（ユニットテスト）を効率化する |
| 主なテスト内容 | 正常系・異常系・境界値・例外処理・副作用確認など |
| 開発での位置づけ | 開発の信頼性・保守性・リファクタリング支援に不可欠 |
| 使用の流れ | クラス作成 → `@Test` メソッドで確認 → アサーションで検証 |

---

ご希望であれば、以下も具体例付きで解説可能です：

- 「テストしやすい設計のコツ（DIやSRPとの関係）」
- 「Spring Boot との統合テスト」
- 「Mockitoなどのモックライブラリを使った外部依存切り離し」

必要に応じてお気軽にお声かけください！

# Q,

テストする際にもともとのプログラムの流れから切り離す必要があるように思うのですがその認識はあっていますか？

はい、Hiroakiさんのご認識は **完全に正しいです。**

---

## ✅ 結論

> テスト（特に単体テスト）では、元のプログラムの実行フローから
> 
> 
> **「テストしたい単位（メソッドやクラス）」を**
> 
> **意図的に**切り離して**検証する必要があります。**
> 

これはテストの基本原則であり、**テスト対象の責務を明確にするための「分離（分割）」**の考え方に直結します。

---

## 🔹 なぜ「切り離す」必要があるのか？

| 理由 | 内容 |
| --- | --- |
| ✅ 再現性 | 毎回同じ条件で同じ結果を得るため |
| ✅ 独立性 | 他の処理や環境に依存せず、対象だけをテストしたいため |
| ✅ 不要な副作用の排除 | DBやファイル操作など「外部影響のある処理」を除外したい |
| ✅ エラーの特定をしやすくする | 問題がどこにあるか特定しやすくするため |

---

## 🔸 具体例：分離してテストする

### ✗ 望ましくない例（密結合）

```java
public void processOrder() {
    connectToDB();              // 外部依存
    validateUser();             // 複数機能の混在
    calculateDiscount();        // ビジネスロジック
    sendEmail();                // 外部依存
}
```

- テストしにくい
- DBやメール送信など、**外部との結合が強すぎる**

---

### ✓ 望ましい例（切り離し）

```java
public class OrderService {
    private DiscountCalculator discountCalculator;

    public OrderService(DiscountCalculator discountCalculator) {
        this.discountCalculator = discountCalculator;
    }

    public int process(int amount) {
        return discountCalculator.applyDiscount(amount);
    }
}
```

```java
public interface DiscountCalculator {
    int applyDiscount(int amount);
}
```

### → テストコード（テスト対象のみ）

```java
@Test
void testDiscountApplied() {
    DiscountCalculator dummy = amount -> amount - 100;
    OrderService service = new OrderService(dummy);

    int result = service.process(1000);
    assertEquals(900, result);
}
```

✅ 割引ロジックだけを分離し、**メールやDBに依存せず**にテスト可能。

---

## 🔹 このような「分離」のテクニックや設計思想には…

| 概念 | 内容 |
| --- | --- |
| **単一責任の原則（SRP）** | テスト対象のクラスが1つの目的に専念しているべき |
| **依存性の注入（DI）** | テスト用のダミーやモックに差し替え可能にする設計 |
| **インタフェース抽象化** | 実装を知らずにテストするために、外部との境界を定義 |
| **モック・スタブの活用** | 外部の処理（DB、Web）を仮の実装で置き換える |

---

## ✅ まとめ

| 質問 | 回答 |
| --- | --- |
| テストのために、元のプログラムの流れから切り離すべき？ | ✅ **はい。分離・抽象化・依存排除はテスト設計の基本です** |
| なぜ？ | 再現性・独立性・保守性・信頼性の向上のため |
| 手法は？ | DI, SRP, インタフェース分離、モック化など |

---

## 🛠 補足的に言うと...

- 「テストできない設計」は「保守しにくい設計」です。
- **テストしやすい構造（テスト容易性）を意識した設計**が、アーキテクチャ品質の土台になります。

---

ご希望があれば、SpringやDIフレームワークでの「テストしやすい構造設計例」や、「モックライブラリ（Mockitoなど）」の具体的活用例もご紹介できます！

# Q,

依存注入で@Testアノテーションが付与されているものだけ別枠で実行の動作を確認できるイメージでしょうか？

はい、Hiroakiさんのご理解はとても近いです。

少し整理して明確にすると、以下のようになります。

---

## ✅ 結論

> @Test アノテーションが付いたメソッドは、JUnitのテスト実行環境が
> 
> 
> **「本番のプログラムの流れとは**完全に独立して**」**
> 
> **「**テスト用に個別に呼び出されて実行される**」ようになっています。
> 
> その際、**依存注入（DI）によってテストに適した依存関係を与えて、個別に検証できる**のがポイントです。
> 

---

## 🔹 たとえばこんなイメージ

### 🎯 本番コード

```java
public class OrderService {
    private final DiscountService discountService;

    public OrderService(DiscountService discountService) {
        this.discountService = discountService;
    }

    public int calculateTotal(int basePrice) {
        return basePrice - discountService.getDiscount();
    }
}
```

### 🧪 テストコード（JUnit）

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class OrderServiceTest {

    @Test
    void testCalculateTotal() {
        // ダミーの依存を注入（依存注入）
        DiscountService mockDiscount = () -> 100;
        OrderService orderService = new OrderService(mockDiscount);

        int total = orderService.calculateTotal(1000);
        assertEquals(900, total);
    }
}
```

---

## 🔸 ポイント整理

| 項目 | 内容 |
| --- | --- |
| `@Test` | ✅ JUnit が「このメソッドをテストとして実行すべき」と認識するためのマーカー |
| テストの実行 | ✅ `main()` などの本番の流れとは**無関係に**、JUnit ランナーが呼び出す |
| 依存注入 | ✅ テスト用にカスタムした依存（ダミー／モック）を注入できる |
| 実行の順序 | ✅ 通常は `@Test` ごとに 1 回ずつインスタンス化 → 実行 → 結果確認 |

---

## 🔸 実行の裏側イメージ（JUnit5）

```java
テストランナー（JUnitプラットフォーム）
    ↓
@DisplayName / @Test アノテーションが付いているメソッドを発見
    ↓
対象クラスを new して（1テスト1インスタンスが原則）
    ↓
@Test メソッドを1つずつ呼び出す（依存が必要なら注入済）
    ↓
結果を収集して表示
```

---

## ✅ よくある補足質問

| 質問 | 回答 |
| --- | --- |
| @Test のメソッドは自動で呼ばれる？ | ✅ はい。JUnit が自動的に見つけて、順に呼び出します。 |
| テスト実行に main() は関係ある？ | ❌ いいえ。テストは main() を使わず、独立して動きます。 |
| 依存注入ってどうやってするの？ | ✅ コンストラクタや setter、もしくは Spring などのDIフレームワークで自動注入可能です。 |
| 依存注入したオブジェクトは、本番と同じでもいい？ | ❌ 原則、テストに特化した「モック／スタブ」を使うことで、制御性と再現性が高まります。 |

---

## ✅ まとめ

| 観点 | 内容 |
| --- | --- |
| `@Test` の意味 | テスト実行対象であることをJUnitに教える |
| 実行の流れ | 本番コードの流れとは完全に切り離され、**JUnitが独自にテストメソッドを実行** |
| 依存注入の役割 | テスト対象を**単独でテスト可能な状態にする**ために、外部依存を差し替える |
| 結果確認 | アサーション（`assertEquals` など）で期待通りかどうかを確認 |

---

必要であれば、「Mockitoを使った依存注入の具体例」や「Spring Bootでの自動DI付きユニットテスト」も実践的に解説できます！

# Q,

テストランナー（JUnitプラットフォーム）が別枠でメモリ上にあり、そこで実行されmain()とは別に確認できるイメージでしょうか？

はい、Hiroakiさんのそのイメージは **非常に正確です。**

---

## ✅ 結論

> JUnit のテストは、main() とは別の “テスト実行エンジン（テストランナー）” によって
> 
> 
> **独立したメモリ空間上で実行されます。**
> 

あなたが `main()` を書かなくても、`@Test` をつけたメソッドは **JUnitプラットフォーム（テストランナー）が裏で new して、順に呼び出してくれる**という仕組みです。

---

## 🔹 図解イメージ（JVM内での分離）

```java
JVMプロセス内
├── 本番アプリの実行空間（main()）
│     └── 通常の処理（ユーザー入力、DB接続、UI表示など）
│
└── テスト実行空間（JUnitランナー）
      └── JUnit Platform Launcher
             ├── テストクラスを new
             ├── @BeforeEach 実行
             ├── @Test メソッドを呼び出し
             └── @AfterEach 実行
```

- 両者は**同じ JVM 内**だが、**制御・流れ・実行開始点が完全に別**
- `main()` を全く通らなくても `@Test` は実行される

---

## 🔸 より具体的にいうと

- *JUnit ランナー（例：`org.junit.platform.launcher.Launcher`）**が
    - `@Test` をスキャンして、
    - **テスト対象クラスを new し（1テスト1インスタンス）**
    - **メソッド単位で呼び出す**（しかも順序保証はない）
- テスト対象のクラス・オブジェクトは、本番の制御からは完全に独立

---

## 🔸 補足：IDE や ビルドツール経由でも同じ仕組み

| 実行方法 | 背景で使われるテストランナー |
| --- | --- |
| IntelliJ IDEA の「▶ テスト実行」 | IntelliJ の JUnit ランナー |
| Eclipse の JUnitビュー | Eclipse JUnit Runner |
| Maven の `mvn test` | `Surefire` プラグイン経由で JUnit Platform |
| Gradle の `gradle test` | `TestLauncher` + `JUnitPlatform` |

---

## 🔹 テスト対象クラスの生成タイミング

JUnit5（Jupiter）では、**各 `@Test` メソッドごとに**新しいインスタンスが作られます：

```java
class MyTest {
    @Test void testA() { ... }
    @Test void testB() { ... }
}
```

→ `testA()` 用と `testB()` 用で、**別々の `MyTest` インスタンス**が生成される

---

## ✅ まとめ

| 観点 | 内容 |
| --- | --- |
| main() とは別の実行空間？ | ✅ はい、JUnit のランナーが独自に動く |
| テストは JVM 上のどこで動く？ | ✅ 同じ JVM だが、**異なる流れ／管理領域**で動く |
| テストクラスのインスタンスは？ | ✅ JUnit が必要に応じて new して、@Test メソッドだけを呼ぶ |
| テストで main() は関係する？ | ❌ 一切関係ない（呼ばれない） |

---

この理解を踏まえると、**「テストのしやすい構造」＝「main() に依存しない構造」**であることの重要性がより明確になりますね。

必要であれば、JUnitが内部で何をしているか（Launcher APIの構造）や、Spring Bootでのテスト時のApplicationContextとの分離構造もご紹介できます！