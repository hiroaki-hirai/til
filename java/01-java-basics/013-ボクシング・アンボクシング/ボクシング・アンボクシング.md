# ボクシング・アンボクシング

# Q,

ボクシングやアンボクシングが発生する条件として、プリミティブ型とラッパー型が両方関わる場合 (変数・引数にて指定した型と元の型のどちらかがプリミティブ型で、もう片方がラッパー型の場合) にのみ起こるという認識はあっていますか？

はい、Hiroakiさん、その認識は**本質的に正しく、非常に鋭い理解**です。

以下に詳細を整理してご説明します。

---

## ✅ 結論：

> ボクシング（boxing）やアンボクシング（unboxing）は、
> 
> 
> **「プリミティブ型」と「ラッパークラス型」が**
> 
> **交差して関わる場面でのみ発生します。**
> 

つまり：

- 両方が**プリミティブ型**：変換なし（そのまま）
- 両方が**ラッパー型**：変換なし（そのまま）
- どちらかがプリミティブ、もう一方がラッパー：**自動変換が発生**

---

## ✅ 発生条件まとめ

| 片方が... | もう片方が... | ボクシング／アンボクシング発生？ | 例 |
| --- | --- | --- | --- |
| `int` | `Integer` | ✅ 発生 | `Integer x = 5;`（boxing） |
| `Integer` | `int` | ✅ 発生 | `int y = x;`（unboxing） |
| `int` | `int` | ❌ 発生しない | そのまま |
| `Integer` | `Integer` | ❌ 発生しない | そのまま |

---

## ✅ 実際のコード例

```java
int a = 10;
Integer b = a;         // ✅ オートボクシング

Integer c = 20;
int d = c;             // ✅ アンボクシング

int e = 30;
int f = e;             // ❌ そのまま（変換なし）

Integer g = 40;
Integer h = g;         // ❌ そのまま（変換なし）
```

---

## ✅ メソッド呼び出しでも同じルールが適用される

```java
void print(Integer value) {
    System.out.println(value);
}

print(5); // ✅ オートボクシング（int → Integer）

void show(int value) {
    System.out.println(value);
}

Integer x = 10;
show(x); // ✅ アンボクシング（Integer → int）
```

---

## ✅ まとめ：Hiroakiさんの認識の確認

> 「プリミティブ型とラッパー型が両方関わるときにのみボクシング／アンボクシングが起きる」
> 

➡ ✅ **その認識は正確です。**

---

### 補足が必要であれば：

- ラッパークラスのキャッシュ（`Integer.valueOf()`）による違い
- `==` 比較時の落とし穴（`Integer i1 = 128; Integer i2 = 128;`）
- ジェネリクスとの関係（`List<Integer>` に `int` を入れられる理由）

などもご案内できます。ご希望があればどうぞ！