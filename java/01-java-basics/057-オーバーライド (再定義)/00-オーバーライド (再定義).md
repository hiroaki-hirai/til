# オーバーライド (再定義)

---

## 🧠 オーバーライド：Java Silver風パターン問題①（正しいオーバーライド）

### 【問題1】

次のコードを正しく実行したときの出力を選びなさい。

```java
class Animal {
    void speak() {
        System.out.println("Animal");
    }
}

class Dog extends Animal {
    @Override
    void speak() {
        System.out.println("Dog");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();
        a.speak();
    }
}
```

### 【選択肢】

A. Animal

B. Dog

C. コンパイルエラー

D. 実行時エラー

### ✅ 正解：**B**

### ✅ 解説：

- `Dog` クラスは `Animal` の `speak()` を正しくオーバーライド。
- `Animal a = new Dog();` により **動的バインディング** が働き、実体である `Dog` の `speak()` が呼ばれる。

---

## 🧠 オーバーライド：Java Silver風パターン問題②（戻り値の違い）

### 【問題2】

次のコードはコンパイルされますか？

```java
class Parent {
    int getValue() {
        return 10;
    }
}

class Child extends Parent {
    double getValue() {
        return 20.0;
    }
}
```

### 【選択肢】

A. コンパイル成功

B. コンパイルエラー：戻り値の型が異なるためオーバーライドにならない

C. 実行時エラー

D. オーバーロードとして認識される

### ✅ 正解：**B**

### ✅ 解説：

- オーバーライド時は、**戻り値の型も一致**する必要がある（共変戻り値はOKだが、`int` → `double` は不可）。
- これは**別メソッド**と認識されない（引数も同じなのでオーバーロードにもならない）。

---

## 🧠 オーバーライド：Java Silver風パターン問題③（アクセス修飾子）

### 【問題3】

次のコードは正しくコンパイルされますか？

```java
class Parent {
    protected void greet() {
        System.out.println("Hello from Parent");
    }
}

class Child extends Parent {
    @Override
    private void greet() {
        System.out.println("Hello from Child");
    }
}
```

### 【選択肢】

A. コンパイル成功

B. コンパイルエラー：アクセス修飾子の制限が強くなっている

C. 実行時エラー

D. greet() はオーバーロードとして扱われる

### ✅ 正解：**B**

### ✅ 解説：

- オーバーライド時に**アクセス修飾子を弱める（非公開にする）ことは不可**。
- `protected → private` は制限が強くなるため **コンパイルエラー**。
- 許可される変更：`protected → protected/public`。

---

## 🧠 オーバーライド：Java Silver風パターン問題④（staticとオーバーライド）

### 【問題4】

次のコードを実行するとどうなりますか？

```java
class Base {
    static void hello() {
        System.out.println("Base");
    }
}

class Derived extends Base {
    static void hello() {
        System.out.println("Derived");
    }
}

public class Main {
    public static void main(String[] args) {
        Base b = new Derived();
        b.hello();
    }
}
```

### 【選択肢】

A. Base

B. Derived

C. コンパイルエラー

D. 実行時エラー

### ✅ 正解：**A**

### ✅ 解説：

- `static` メソッドは**オーバーライドされず、隠蔽（シャドウイング）**される。
- `b.hello();` は参照型 `Base` に基づいて `Base.hello()` が呼ばれる。
- **動的バインディングは static メソッドには適用されない**。

---

## 🧠 オーバーライド：Java Silver風パターン問題⑤（例外の制限）

### 【問題5】

次のコードはコンパイルされますか？

```java
class A {
    void process() throws Exception {
        System.out.println("A");
    }
}

class B extends A {
    @Override
    void process() throws RuntimeException {
        System.out.println("B");
    }
}
```

### 【選択肢】

A. コンパイル成功

B. コンパイルエラー：例外の型が異なる

C. 実行時エラー

D. process() はオーバーロード扱いになる

### ✅ 正解：**A**

### ✅ 解説：

- **チェック例外（Exception）はオーバーライド時に狭めることはOK**。
- 例外の種類を `RuntimeException` にする（非チェック例外）も問題ない。
- 広げる（Exception → Throwableなど）はNG。

---

## 🧠 オーバーライドの要点まとめ

| チェックポイント | 説明 |
| --- | --- |
| 戻り値の型 | 同じ or サブクラス型（共変戻り値） |
| アクセス修飾子 | 同じ or より広い範囲（例：protected → public） |
| staticメソッド | オーバーライド不可。クラスにバインドされて隠蔽される |
| finalメソッド | オーバーライド不可 |
| throws句 | 同じ or 狭める方向（Exception → IOExceptionなど） |
| アノテーション（@Override） | 任意。ただしミスを防ぐために付けるのが推奨 |

---

## 🧠 オーバーライド：パターン問題⑥（引数の違い → オーバーロード）

### 【問題6】

次のコードを実行するとどうなりますか？

```java
class A {
    void show(String s) {
        System.out.println("A: " + s);
    }
}

class B extends A {
    void show(int i) {
        System.out.println("B: " + i);
    }
}

public class Main {
    public static void main(String[] args) {
        A obj = new B();
        obj.show("Hello");
    }
}
```

### 【選択肢】

A. B: Hello

B. A: Hello

C. コンパイルエラー

D. 実行時エラー

### ✅ 正解：**B**

### ✅ 解説：

- `show(int)` は **オーバーライドではなくオーバーロード**（引数型が違う）！
- `obj` の参照型は `A` なので、`A` にある `show(String)` が呼ばれる。
- `B` クラスで `show(String)` を**オーバーライドしていない**点が引っかけ。

---

## 🧠 オーバーライド：パターン問題⑦（final メソッドのオーバーライド）

### 【問題7】

次のコードはコンパイルされますか？

```java
class A {
    final void hello() {
        System.out.println("Hello from A");
    }
}

class B extends A {
    @Override
    void hello() {
        System.out.println("Hello from B");
    }
}
```

### 【選択肢】

A. コンパイル成功

B. コンパイルエラー：finalメソッドはオーバーライドできない

C. 実行時例外

D. hello() はオーバーロード扱いになる

### ✅ 正解：**B**

### ✅ 解説：

- `final` が付いたメソッドは **オーバーライド禁止**。
- コンパイルエラーになる。
- `@Override` があってもなくてもエラー。

---

## 🧠 オーバーライド：パターン問題⑧（@Override の効果）

### 【問題8】

次のコードをコンパイルした結果として正しいものを選びなさい。

```java
class A {
    void greet() {
        System.out.println("Hi");
    }
}

class B extends A {
    @Override
    void Greet() {
        System.out.println("Hello");
    }
}
```

### 【選択肢】

A. Hello と出力される

B. コンパイルエラー：@Overrideが無効な位置にある

C. Hi と出力される

D. 実行時例外

### ✅ 正解：**B**

### ✅ 解説：

- Javaは **大文字小文字を区別**するため、`Greet()` は `greet()` のオーバーライドではない。
- `@Override` を付けたのに、オーバーライドできていない → コンパイルエラー。
- `@Override` がなければオーバーロードとして通るが、意味が異なる。

---

## 🧠 オーバーライド：パターン問題⑨（抽象メソッドの実装）

### 【問題9】

次のコードを見て、正しい選択肢を選びなさい。

```java
abstract class Animal {
    abstract void makeSound();
}

class Cat extends Animal {
}
```

### 【選択肢】

A. コンパイル成功

B. Catクラスもabstractにすればコンパイル成功

C. makeSound() の戻り値を変更してオーバーライドすればOK

D. Animalクラスをfinalにすればエラーは解消する

### ✅ 正解：**B**

### ✅ 解説：

- `Animal` に抽象メソッド `makeSound()` がある。
- `Cat` がそれをオーバーライドしないなら、**自らも abstract になる必要がある**。
- そうしないと **未実装の抽象メソッドを持つ通常クラス**となり、コンパイルエラー。

---

## 🧠 オーバーライド：パターン問題⑩（protected → public）

### 【問題10】

次のコードはコンパイルされ、出力は何になりますか？

```java
class A {
    protected void run() {
        System.out.println("A");
    }
}

class B extends A {
    public void run() {
        System.out.println("B");
    }
}

public class Main {
    public static void main(String[] args) {
        A a = new B();
        a.run();
    }
}
```

### 【選択肢】

A. A

B. B

C. コンパイルエラー

D. 実行時エラー

### ✅ 正解：**B**

### ✅ 解説：

- `protected → public` はアクセス修飾子の制限を**緩める方向**なのでOK。
- `A a = new B();` → 実体はBなので、**オーバーライドされた run()** が実行される。

---

## 🔚 総まとめ：よく出るオーバーライド引っかけパターン

| 出題パターン | 説明 |
| --- | --- |
| 引数が違う → 実はオーバーロード | `void method(String)` vs `void method(int)` |
| 戻り値違い → オーバーライド失敗 | `int` vs `double` などはNG |
| アクセス修飾子が狭まる → コンパイルエラー | `public` → `protected` など |
| `final` メソッド → オーバーライド不可 | 明示的に禁止されている |
| `@Override` のミス → 誤記でコンパイルエラー | メソッド名の誤字などで発生 |

[要件](%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89%20(%E5%86%8D%E5%AE%9A%E7%BE%A9)%201fe62cef735080dda112caff4495664e/%E8%A6%81%E4%BB%B6%2025562cef7350806d9590c8aaf4f2d76a.md)

[共変戻り値](%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89%20(%E5%86%8D%E5%AE%9A%E7%BE%A9)%201fe62cef735080dda112caff4495664e/%E5%85%B1%E5%A4%89%E6%88%BB%E3%82%8A%E5%80%A4%2022162cef735080d18c8bd7001ddd3528.md)

[共変戻り値 - ジェネリクスの場合](%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89%20(%E5%86%8D%E5%AE%9A%E7%BE%A9)%201fe62cef735080dda112caff4495664e/%E5%85%B1%E5%A4%89%E6%88%BB%E3%82%8A%E5%80%A4%20-%20%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AA%E3%82%AF%E3%82%B9%E3%81%AE%E5%A0%B4%E5%90%88%2023562cef7350808e98cfc7840560e1d7.md)

[不可ケース](%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89%20(%E5%86%8D%E5%AE%9A%E7%BE%A9)%201fe62cef735080dda112caff4495664e/%E4%B8%8D%E5%8F%AF%E3%82%B1%E3%83%BC%E3%82%B9%2022162cef735080e4aa79c5dd913b10c5.md)

[vtable](%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89%20(%E5%86%8D%E5%AE%9A%E7%BE%A9)%201fe62cef735080dda112caff4495664e/vtable%2022162cef7350802da1fec19d693205c9.md)

[親クラスメソッドが呼ばれる場合](%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89%20(%E5%86%8D%E5%AE%9A%E7%BE%A9)%201fe62cef735080dda112caff4495664e/%E8%A6%AA%E3%82%AF%E3%83%A9%E3%82%B9%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%8C%E5%91%BC%E3%81%B0%E3%82%8C%E3%82%8B%E5%A0%B4%E5%90%88%2022d62cef735080eb815fef85ed861d67.md)

[引数](%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89%20(%E5%86%8D%E5%AE%9A%E7%BE%A9)%201fe62cef735080dda112caff4495664e/%E5%BC%95%E6%95%B0%2023562cef7350805096c8e9fc4cc9fb21.md)