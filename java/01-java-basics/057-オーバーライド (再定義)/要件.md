# 要件

# Q,

オーバーライドの要件として、シグニチャが同一であること、戻り値の方が同じかサブクラス型であること、アクセス修飾子が同じか、より緩くなることが挙げられますが、他にありますか？

いい視点ですね 👍

オーバーライド（**override**）の要件はご指摘の3つが主要ポイントですが、実はもう少し細かい条件があります。JLS（Java Language Specification）ベースで整理すると次の通りです。

---

## 🔷 オーバーライドの要件（まとめ）

### 1. **シグニチャが同一**

- メソッド名とパラメータリスト（型・順序）が完全に同じであること。
    
    （戻り値は含まれない＝戻り値だけ変えても別メソッドにはならない）
    

---

### 2. **戻り値の型**

- 同じ型 **または** 「共変戻り値（covariant return type）」
    - 例：親が `Number` を返すなら、子は `Integer` を返せる。

---

### 3. **アクセス修飾子**

- 親と同じか **より緩い（public に近い）可視性** にできる。
    - 例：`protected` → `public` はOK
    - 例：`public` → `protected` はNG（制限が強くなるため）

---

### 4. **例外宣言（throws 節）**

- チェック例外については、**親の宣言している例外と同じか、そのサブクラスに限定**される。
- 新しいチェック例外を追加することはできない。
- ただし **非チェック例外（RuntimeExceptionやErrorの系統）は自由に追加可能**。

---

### 5. **メソッドが `final` / `static` / `private` でないこと**

- `final` メソッド → オーバーライド禁止
- `static` メソッド → オーバーライドではなく「隠蔽（hiding）」になる
- `private` メソッド → そもそもサブクラスから見えないのでオーバーライド不可

---

### 6. **親のメソッドが継承可能であること**

- 親クラスが `private` だったり、サブクラスが別パッケージで `default（package-private）` の場合はオーバーライドできない。

---

### 7. **アノテーション（@Override）の使用**

- 強制ではないが、付けると「正しくオーバーライドしているか」コンパイラがチェックしてくれる。

---

### 8. **型パラメータの互換性**

- ジェネリクスを含むメソッドでも、**型消去後にシグニチャが一致**する必要がある。
- 例：

```java
class A {
    Number getValue() { return 0; }
}
class B extends A {
    @Override
    Integer getValue() { return 1; } // ✅ 共変戻り値
}
```

---

## ✅ 補足：似ているけど別物

- **オーバーロード**：パラメータリストが異なる場合
- **オーバーライド**：シグニチャが同じで、サブクラスが上書きする場合

---

## 🔚 まとめ（追加要件）

あなたが挙げた

- シグニチャ一致
- 戻り値は同じ or サブ型（共変戻り値）
- アクセス修飾子は同じか緩め

に加えて **必須で押さえるべき要件**は：

1. `throws` のチェック例外は親と同じかサブクラスに限定
2. `final` / `static` / `private` はオーバーライド不可
3. 親のメソッドがアクセス可能であること（可視性の制約）
4. ジェネリクス利用時は型消去後の一致が必要

---

👉 もしご希望なら、これを「オーバーロードとの比較表」としてまとめることもできますが、見たいですか？