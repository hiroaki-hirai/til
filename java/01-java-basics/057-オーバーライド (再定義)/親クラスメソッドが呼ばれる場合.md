# 親クラスメソッドが呼ばれる場合

# Q,

宣言型が親クラス型で、実行時型がサブクラス型の場合、サブクラスでオーバーライドしていない場合は、親クラスのメソッドが呼ばれる認識は合っていますか？

はい、Hiroakiさんのご認識は**正しいです**。

そのケースは **「動的バインディングが発生しない」** 状況であり、**親クラスのメソッドが呼ばれます**。

---

### 🔹用語の整理

- **宣言型（静的型 / 静的バインディング）**：変数の型（左辺の型）
- **実行時型（動的型 / 動的バインディング）**：代入されるインスタンスのクラス（右辺の型）

---

### 🔸 具体例

```java
class Parent {
    void greet() {
        System.out.println("Hello from Parent");
    }
}

class Child extends Parent {
    // greet() をオーバーライドしていない
}

public class Main {
    public static void main(String[] args) {
        Parent obj = new Child(); // 実行時型は Child、宣言型は Parent
        obj.greet(); // 呼ばれるのは Parent の greet()
    }
}
```

🔹結果：

```java
Hello from Parent
```

---

### ✅ ポイント

- オーバーライドして**いない**場合は、**親クラスのメソッドがそのまま使われる**。
- **メソッドがオーバーライドされていれば**、実行時の型（= Child）の方が呼ばれる（動的バインディングが発生）。

---

### 🔎 補足：フィールドのアクセスは「常に宣言型」

ちなみに、**フィールド（変数）の参照は動的バインディングされません**。常に宣言型の方が使われます：

```java
class Parent {
    String msg = "parent";
}

class Child extends Parent {
    String msg = "child";
}

public class Main {
    public static void main(String[] args) {
        Parent obj = new Child();
        System.out.println(obj.msg);  // → "parent"
    }
}
```

🔸 フィールドは**常に静的バインディング（宣言型基準）**です。

---

### ✅ 結論まとめ

| 種別 | オーバーライドあり | 結果 |
| --- | --- | --- |
| メソッド | ✅ | 実行時型（サブクラス）のメソッドが呼ばれる |
| メソッド | ❌ | 親クラスのメソッドが呼ばれる |
| フィールド | ― | 宣言型のフィールドが使われる |

---

必要があれば、`abstract`, `final`, `static` との関連も解説できます！