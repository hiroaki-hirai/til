# 実行順

# Q,

通常のtry-catch-finally の実行順と、try-with-rescorsesの実行順が異なるのはなぜですか？

素晴らしい質問です。

`通常の try-catch-finally` と `try-with-resources` の **実行順が異なる理由**は、両者の**目的と構文仕様の違い**にあります。

以下で、**実行順の違い・理由・構造の違い**を明確に整理して解説します。

---

## ✅ 結論

> try-catch-finally は例外処理を中心とした構造
> 
> 
> **`try-with-resources` はリソースの安全な解放（クローズ）を目的とした構造**
> 
> → そのため、**`finally` よりも先に `close()` を実行する仕様**になっています。
> 

---

## 🔹 まず比較：両者の実行順

### 🔸 ① 通常の `try-catch-finally`

```java
try {
    System.out.println("try");
} catch (Exception e) {
    System.out.println("catch");
} finally {
    System.out.println("finally");
}
```

✅ 実行順（例外なしの場合）

```java
try → finally
```

✅ 実行順（例外ありの場合）

```java
try → catch → finally
```

- **finally は必ず最後に実行される**のがポイント

---

### 🔸 ② `try-with-resources`

```java
try (MyResource r = new MyResource()) {
    System.out.println("try");
} catch (Exception e) {
    System.out.println("catch");
} finally {
    System.out.println("finally");
}
```

### `MyResource implements AutoCloseable` として `close()` を定義済みとします。

### ✅ 実行順（例外なしの場合）

```java
try → r.close() → finally
```

### ✅ 実行順（例外ありの場合）

```java
try →  r.close() → catch → finally
```

---

## 🔸 なぜ `close()` が `finally` よりも先に呼ばれるのか？

### ✅ 理由①：リソースの**安全な解放が最優先**

- `try-with-resources` の目的は、**例外の有無に関わらず必ずリソースを解放すること**
- `finally` より先に `close()` を呼ぶことで、**finally ブロックの中でリソースがすでに閉じられていることを保証**できる
- これにより、**finally 内での追加処理がリソースに依存しない前提で安全に書ける**

---

### ✅ 理由②：仕様として明記されている（JLS）

- Java言語仕様（JLS 14.20.3）では、try-with-resources のクローズ処理は、
    - **catch と finally に入る前に実行される**
    - すべてのリソースについて `close()` を呼んでから finally に進む

---

## 🔸 実際のコード変換イメージ（コンパイル後）

`try-with-resources` は、コンパイル時に内部的に次のようなコードに変換されるイメージです：

```java
MyResource r = new MyResource();
Throwable primaryException = null;
try {
    System.out.println("try");
} catch (Throwable t) {
    primaryException = t;
    throw t;
} finally {
    if (r != null) {
        if (primaryException != null) {
            try {
                r.close();
            } catch (Throwable t2) {
                primaryException.addSuppressed(t2); // ← サプレッション処理
            }
        } else {
            r.close();
        }
    }
    System.out.println("finally");
}
```

この変換が、「`close()` → `finally`」の順になる**技術的な理由**です。

---

## ✅ まとめ表

| 観点 | 通常の try-catch-finally | try-with-resources |
| --- | --- | --- |
| 主目的 | 例外の補足と後処理 | リソースの安全な解放 |
| `finally` の実行位置 | 最後に実行される | 最後に実行される（ただし close() の後） |
| `close()` の実行位置 | 手動（finally 内など） | 自動で `catch` / `finally` の**前に**呼ばれる |
| 実行順（例外なし） | try → finally | try → close → finally |
| 実行順（例外あり） | try → catch → finally | try →  close → catch → finally |

---

必要であれば、`close()` と `finally` の間に例外が発生した場合のサプレッションの動きなど、より高度なエラーハンドリングの仕様についてもご案内可能です！