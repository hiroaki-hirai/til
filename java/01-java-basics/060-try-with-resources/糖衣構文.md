# 糖衣構文

# Q,

本来は、close()が必要なところ、try-with-resource では close() の記載が不要という事は、裏でJVMが裏でクラスを自動作成している糖衣構文のような仕様なのでしょうか？

はい、Hiroakiさん、その理解は非常に近いです！

`try-with-resources` は **Javaコンパイラ（javac）による糖衣構文（syntactic sugar）** です。つまり、**ソースコード上では簡潔に書けますが、コンパイル時に実際の `close()` 呼び出しコードへと展開されている**という仕組みです。

---

## 🔍 ポイント：`try-with-resources` はコンパイル時に展開される

Javaコンパイラは `try-with-resources` を使ったコードを、**明示的に `close()` を呼び出すコードに書き換えた状態で `.class` ファイルを生成**します。

---

## 🔸 例：シンプルなコード

```java
try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
    System.out.println(br.readLine());
}
```

---

## 🔁 コンパイラが内部的に変換するコード（イメージ）

```java
BufferedReader br = new BufferedReader(new FileReader("file.txt"));
Throwable primaryException = null;

try {
    System.out.println(br.readLine());
} catch (Throwable t) {
    primaryException = t;
    throw t;
} finally {
    if (br != null) {
        if (primaryException != null) {
            try {
                br.close();
            } catch (Throwable closeException) {
                primaryException.addSuppressed(closeException);
            }
        } else {
            br.close();
        }
    }
}
```

🔸 ポイント：

- `close()` を明示的に呼んでいる
- `try-catch-finally` に展開され、例外が起きても `close()` が呼ばれる
- `close()` 中に発生した例外は `addSuppressed()` により記録される（Java 7以降の機能）

---

## ✅ まとめ：JVMが自動でやってくれるのではなく、**コンパイラが自動で書き換えている**

| 比較項目 | 説明 |
| --- | --- |
| JVMが動的に変換？ | ❌ いいえ |
| コンパイラが変換？ | ✅ はい。Javaの構文糖として扱われる |
| 実行時の動作 | `try-finally` で `close()` を呼ぶのと同じ挙動 |
| 開発者のメリット | より簡潔に、安全にリソース解放処理が書ける |

---

ご希望があれば、`javac` + `javap -c` を使って実際にどうバイトコードが出力されているかの具体的な手順もご紹介できます！