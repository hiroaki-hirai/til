# 代入とオブジェクトの内部変更

# Q,

```java
    String a = "hirai";
    String b = a;
    b = "hiroaki";
    System.out.println(a);
    System.out.println(b);

    StringBuilder c = new StringBuilder("hirai");
    StringBuilder d = c;
    d.append("hiroaki");
    System.out.println(c);
    System.out.println(d);
```

上記のコードにて、どちらの場合も、参照のコピーをしています。
その後、StringBuilderの場合は、内容をそのまま変更し、その影響が同じ参照となっている最初の変数にも反映されている。
Stringの場合は、bに新しい文字列の参照が代入されるが、ここではｂの参照が変更されるだけで、aに代入されているわけではないからaは変更されない。
この理解と先程の拡張forの問題と同じポイントと言う認識で合っていますか？

はい、Hiroakiさんのその理解は **完全に正確で核心を突いています。**

---

## ✅ 整理された理解（完璧です）

### 🔹 `String` の場合（イミュータブル）

```java
String a = "hirai";
String b = a;         // b は a の参照（"hirai"）をコピー
b = "hiroaki";        // b は別の文字列 "hiroaki" を参照するように変更
```

- **aとbは最初、同じオブジェクト `"hirai"` を参照**
- しかし `b = "hiroaki"` によって、**bだけが別の文字列を指す**
- **aには影響なし**
- `String` はイミュータブルなので、オブジェクトそのものの中身を変更するようなことはできない

出力：

```java
hirai
hiroaki
```

---

### 🔹 `StringBuilder` の場合（ミュータブル）

```java
StringBuilder c = new StringBuilder("hirai");
StringBuilder d = c;     // d は c の参照をコピー
d.append("hiroaki");     // d から内部を変更 → cにも影響
```

- **cとdは同じオブジェクトを参照し続けている**
- `.append()` はオブジェクトの内部状態を変更する操作
- **cとdの出力は両方変化しており、同じになる**

出力：

```java
hiraihiroaki
hiraihiroaki
```

---

## 🔁 これと拡張for文の本質的な共通点：

> 「拡張for文の変数も、元の参照のコピーでしかない」
> 

つまり、

- `for (String str : array)` の `str` も `array[i]` の参照を**コピー**しているだけ
- `str = "D"` は参照の付け替えなので、**元の配列には影響しない**

---

## 🧠 まとめ：今の理解を言い換えると…

| 種類 | 内容 | 結果 |
| --- | --- | --- |
| `String` | イミュータブル。再代入は**参照の切り替え** | 元の変数（`a`, `array[i]`）には影響なし |
| `StringBuilder` | ミュータブル。メソッドで**中身を変更** | 同じ参照を共有している変数にも影響が出る |

# Q,

となると、同じ参照なのに、代入の場合は代入先にのみ影響がでて、そのものの変更の場合は代入元にも影響が出ることとなります。
代入の方は理解できたと思いますが、今度はそのもの(同じ参照の値)を変更した場合について確認です。

同じ参照の値は、変数が異なっていても仮想的なメモリの場所は同一で値も同一。
よって同じ参照にある値そのものを変更すると、どちらの変数の値も、同一となる。

一方、代入は同じ参照の変数の一方を別の参照に置き換える動作なので、置き換えない方の変数は影響を受けない。

上記の認識で合っていますか？

はい、Hiroakiさんのこの認識は**完全に正確です。**

---

## ✅ 整理されたポイントごとの確認

### ① **同じ参照（同じオブジェクト）を2つの変数が保持している**

```java
StringBuilder a = new StringBuilder("abc");
StringBuilder b = a; // 同じオブジェクトへの参照をコピー
```

- `a` と `b` は同じオブジェクトを指しており
- メモリ上の**同じアドレス（参照先）**を共有しています

---

### ② **「そのものの変更」（＝オブジェクトの内部変更）を行うと両方に反映される**

```java
b.append("def"); // a にも影響が出る（同じ参照先）
```

- `b` を通じて変更しても、そのオブジェクトを `a` も参照しているため、**変更結果は両方に見える**

---

### ③ **「代入」は参照の付け替えなので、もう片方には影響がない**

```java
b = new StringBuilder("xyz"); // b は別のオブジェクトを参照
```

- `b` は新しい参照先（別のStringBuilder）を持つようになる
- `a` は引き続き `"abcdef"` のオブジェクトを参照しているため、**aには何の影響もない**

---

## 🎯 あらためて結論

| 操作 | 説明 | 結果 |
| --- | --- | --- |
| **オブジェクトの内部を変更（ミュータブルな場合）** | 同じメモリアドレスを参照しているので両方に反映 | ✅ 両方の変数に変化が見える |
| **参照の再代入（変数側を他に向ける）** | 変数が別の参照値（アドレス）を持つだけ | ✅ もう一方の変数には影響しない |

---

## 💡 応用的な視点

この性質はJavaでの**オブジェクト共有の設計**や、**副作用のある処理の管理**において非常に重要で、たとえば：

- コレクション内のオブジェクトが外部から書き換えられるリスクを避ける「**防御的コピー**」
- 参照共有による予期せぬバグを防ぐ「**不変オブジェクト設計**」

などにもつながります。