# 配列型、参照型 - 共変違い

# Q,

配列型の通常型の共変は、通常の参照型の共変と違いがありますか？

はい、Hiroakiさん。とても良い質問です。

**「配列の共変」と「通常の参照型の共変」には明確な違いがあります。**

共通して「共変が許容されている」点は同じですが、**型安全の観点と動作の仕組みに違い**があります。

---

## ✅ 配列と参照型における共変の比較表

| 比較項目 | 通常の参照型 | 配列型 |
| --- | --- | --- |
| 共変性の有無 | ✅ あり（`String` → `Object`） | ✅ あり（`String[]` → `Object[]`） |
| 型安全性 | コンパイル＋実行時で比較的安全 | 実行時に型チェックが入るため**例外の可能性あり** |
| 実行時型チェック | 特になし（キャスト時のみ） | **配列ストアチェック**が走る |
| 例外の有無 | 基本的になし（キャスト時除く） | **ArrayStoreException** の可能性あり |
| 型消去の影響 | 受けない | 受けない（配列は型情報を持っている） |

---

## 🔷 通常の参照型の共変：安全性が高い

```java
String str = "hello";
Object obj = str;  // OK（共変）
```

- `Object` 型の変数 `obj` に `String` を代入しても、実際のオブジェクトは `String` のままなので安全。
- 実行時も問題なく動作。

---

## 🔷 配列の共変：**危険をはらむ**

```java
String[] strings = new String[3];
Object[] objects = strings;  // ✅ 共変なのでOK

objects[0] = "hello";   // OK
objects[1] = 42;        // ☠️ ArrayStoreException（実行時例外）
```

### ✅ なぜこうなるのか？

- `objects` の型は `Object[]` に見えるが、実体は `String[]`
- 実行時に JVM は「これは `String[]` だ」と知っており、異なる型を格納しようとすると **`ArrayStoreException`** を投げます。

---

## ✅ Javaにおける型安全の違い

| 型 | 実行時型情報 | 型安全性の実現方法 |
| --- | --- | --- |
| **配列** | あり（配列の実体型は保持） | **実行時に型チェック**（ArrayStoreCheck） |
| **ジェネリクス** | なし（型消去される） | **コンパイル時に厳密な型チェック**（共変性不許可） |
| **参照型（非配列）** | あり（実体型を保持） | 共変許容。ただしキャストミスで`ClassCastException`の危険あり |

---

## ✅ まとめ：配列の共変と通常参照型の共変の違い

| 観点 | 通常参照型 | 配列 |
| --- | --- | --- |
| 共変性の意味 | サブ型を親型として扱える | 同様に配列も共変として扱える |
| 危険性 | 比較的安全 | **実行時に例外（ArrayStoreException）の危険あり** |
| JVMの保護 | なし（キャスト時のみチェック） | **実行時に型を保持してチェックされる** |
| 結論 | 安全だが注意 | 共変性があるが、**実行時例外を起こす可能性があるので慎重に扱うべき** |

---

ご希望があれば、`ArrayStoreException` の内部的な仕組み（`checkcast`命令や`astore`命令時の動作）についても解説できますよ。続けますか？

# Q,

```java
String[] strings = new String[3];
Object[] objects = strings;  // ✅ 共変なのでOK

objects[0] = "hello";   // OK
objects[1] = 42;        // ☠️ ArrayStoreException（実行時例外）
```

上記のような例外の危険性を避けるために、ジェネリクスの不変性がある理解は合っていますか？

はい、Hiroakiさん、その理解は**完全に正しいです**。

その `ArrayStoreException` のような**実行時の型不整合をコンパイル時に防ぐため**に、**Javaのジェネリクスは「不変（invariant）」として設計されています。**

---

## ✅ 結論：

> 「配列の共変によって起こりうる実行時の型不整合を、ジェネリクスでは最初から禁止することで防ごうとしている**」
> 
> 
> ➡ この考え方は、**Javaジェネリクス設計の中核**です。
> 

---

## 🔷 背景と比較整理

### 📌 配列の共変（unsafe）

```java
String[] strings = new String[3];
Object[] objects = strings;     // OK（共変）

objects[0] = 42;                // ☠️ 実体が String[] なので実行時例外
```

- **見かけの型：`Object[]`**
- **実体の型：`String[]`**
- JVMはこの不整合に気づいて `ArrayStoreException` を投げるが、それは**実行時**であり、**コンパイル時は通ってしまう**。

---

### 📌 ジェネリクスの不変（safe）

```java
List<String> list = new ArrayList<>();
List<Object> objList = list; // ❌ コンパイルエラー：不変だから代入できない
```

- **ジェネリクスでは `List<String>` ≠ `List<Object>`**
- よって、**異なる型の要素を追加できてしまうような構文が成立しない**
- 型の不整合による実行時例外を、**コンパイル時に未然にブロック**

---

## ✅ 目的は「型安全性」の最大化

| 機能 | 配列 | ジェネリクス |
| --- | --- | --- |
| 共変性 | 許容 | 不許容（不変） |
| 実行時型情報 | あり | **なし（型消去）** |
| 型安全の保証手段 | 実行時に型チェック（ArrayStoreCheck） | **コンパイル時に厳格な型チェック** |
| 例外の可能性 | ArrayStoreException | **基本的になし（安全）** |
| 設計哲学 | 柔軟性重視（古い仕様） | 安全性重視（後発設計） |

---

## 🔸 JVM的視点（補足）

- 配列型は実行時にも「具体的な型情報（`String[]` など）」を保持している
- ジェネリクスは**型消去（type erasure）**により、**実行時には型パラメータは存在しない**
- よって、**ジェネリクスでは「実行時に型エラーを防ぐ」ことができない**
- だからこそ、**コンパイル時に絶対に型安全性を確保する必要がある**
    
    → そのために不変性（invariance）という制限がある
    

---

## ✅ 結論まとめ

| 質問 | 回答 |
| --- | --- |
| 配列の共変による例外リスクを防ぐためにジェネリクスは不変性を採用しているのか？ | ✅ **その通りです** |
| ジェネリクスは実行時の型安全性をどのように実現しているか？ | 型消去により実行時の安全性は持たず、**コンパイル時に型安全を保証する設計**になっている |

---

この不変性の補完として使われるのが、**`? extends` や `? super` によるワイルドカードによる共変・反変の制御**です。

もしこのあたりの応用（リストの読み書き可否や代入可能性）を詳しく確認したい場合は、そのまま図解付きで整理します！