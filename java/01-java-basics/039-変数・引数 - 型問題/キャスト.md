# キャスト

# Q,

キャストが必要な場合にキャストしないケースで、コンパイルエラーになる場合とClassCastException になる場合がありますか？あればその場合分けをまとめてください。

はい、あります。ざっくり言うと――

- **キャストを付けないと「コンパイルエラー」になる**パターン
- **キャストを書けばコンパイルは通るが、実行時に ClassCastException** になるパターン
    
    の2系統に分かれます。代表例を用途別に整理します。
    

# 1) キャストしないと「コンパイルエラー」

### 1-1. 参照型の**ダウンキャストが必要**なのに未記載

```java
Object o = "abc";
// String s = o;           // コンパイルエラー（必ずしもStringとは限らない）
String s = (String) o;     // OK（ただし実体がStringでなければ実行時CCE）
```

**1-2. **数値の狭める変換（narrowing）**を省略**

```java
long L = 10L;
// int i = L;             // コンパイルエラー
int i = (int) L;           // OK（実行時CCEは起きない。オーバーフローの可能性はある）
```

1-3. **不変（invariant）なジェネリクス**での代入

```java
List<String> ls = new ArrayList<>();
// List<Object> lo = ls;  // コンパイルエラー（List<String>はList<Object>のサブタイプではない）
List<? extends Object> lo2 = ls; // OK（読み取り専用になる制約あり）
```

1-4. **オーバーロード解決**で曖昧（キャストで明示しないと不明）

```java
void f(int x) {}
void f(long x) {}
// f(1);                  // OKだがケースによっては曖昧になることがある
f((int)1);                 // 明示キャストで解決、など
```

# 2) キャストを書けば通るが、実行時に **ClassCastException**

### 2-1. 実体が目的型でない**ダウンキャスト**

```java
Object o = Integer.valueOf(42);
String s = (String) o;     // 実行時CCE（実体はInteger）
```

2-2. **配列のキャスト**（配列は実行時に型情報を保持）

```java
Object arr = new String[1];
Integer[] a = (Integer[]) arr; // ここで実行時CCE（実体はString[]）
```

### 2-3. **ジェネリクスの未検査キャスト → 後でCCE**

ジェネリクスは消去されるため、**キャスト時点では落ちず**、後続の読み出し時に落ちるのが典型。

```java
List<String> ls = new ArrayList<>();
ls.add("abc");

List raw = ls;                 // 原型に落とす
List<Integer> li = raw;        // 未検査キャスト（コンパイル警告だが通る）

Integer x = li.get(0);         // ここで実行時CCE（実体はString、Integerにキャストされる）
```

### 2-4. **Object 経由の“二段階”キャスト**

直接は「型変換不能」で弾かれるが、Object を挟むと**コンパイルは通る** → 実行時CCE。

```java
// String s = (String) Integer.valueOf(1); // コンパイルエラー（inconvertible types）
Object ob = Integer.valueOf(1);
String s = (String) ob;                 // コンパイルOK → 実行時CCE
```

# 3) 類似だが別例外・注意点

- **ArrayStoreException**：配列共変性で「格納時」に落ちる例外（CCEではない）

```java
Object[] oa = new String[1];
oa[0] = Integer.valueOf(1);  // ArrayStoreException
```

- **プリミティブのキャスト**は CCE にならない（オーバーフローや丸めは起きうるがCCEは発生しない）
- **null のキャスト**は常に成功し、結果は null（CCEにならない）

```java
Object o = null;
String s = (String) o; // OK（s は null）
```

- **オートボクシング/アンボクシング**は CCE ではなく、null で **NullPointerException** が起きうる

```java
Integer n = null;
int i = n; // NullPointerException
```

# 4) 早見表

| 状況 | キャスト省略時 | キャスト記載時 | 実行時挙動 |
| --- | --- | --- | --- |
| 参照のダウンキャスト（実体が適合） | コンパイルエラー | コンパイルOK | 正常 |
| 参照のダウンキャスト（実体が不適合） | コンパイルエラー | コンパイルOK | **ClassCastException** |
| 配列参照を別の要素型配列にキャスト | ― | コンパイルOK | **ClassCastException**（キャスト時） |
| 配列に不適合要素を代入 | ― | ― | **ArrayStoreException**（代入時） |
| 数値の狭い型へ代入（long→int等） | **コンパイルエラー** | コンパイルOK | 正常（ただし値は切り捨て/飽和なし） |
| ジェネリクスの不変性（List<String>→List<Object>） | **コンパイルエラー** | ワイルドカードならOK / 未検査キャストは警告でOK | 後続の読み出しで **ClassCastException** になり得る |
| Object 経由の二段階キャスト（不適合） | 直接は**コンパイルエラー** | Object を挟めばコンパイルOK | **ClassCastException** |
| null のキャスト | 省略/記載いずれもOK | OK | 常に成功（nullのまま） |
| オートアンボクシング（値がnull） | ― | ― | **NullPointerException** |

---

**実務の指針**

- 可能な限り `instanceof`（パターンマッチ含む）で実体を確認してからダウンキャストする。
- ジェネリクスは未検査キャストを避け、**ワイルドカード**（`? extends` / `? super`）や**型引数**で表現する。
- 配列の共変性は落とし穴。**配列よりジェネリックコレクション**を優先。
- プリミティブの狭める変換は**明示キャスト必須**。CCEは起きないが、**値の損失**に注意。

# Q,

```java
short s1 =10; 
Integer s2 = 20; 
String s3 = (String) (s1 + s2);
```

上記コードの場合は、どうなりますか？

いい例を挙げられました 👍

順に処理を追ってみましょう。

```java
short s1 = 10;
Integer s2 = 20;
String s3 = (String) (s1 + s2);
```

---

## ① `s1 + s2` の型

- `s1` は `short`。
- `s2` は `Integer`（ラッパークラス）。
    
    → 算術演算子 `+` を使うときに **アンボクシング** が行われて `int` になります。
    

なので実際の演算は

```java
short + int
```

となり、**数値型の二項演算は「int以上」に拡張」されるので**、結果は `int` 型です。

👉 `s1 + s2` の結果は **int**。

---

## ② `(String) (s1 + s2)` の部分

- 左辺は `String` にキャストしようとしています。
- 右辺は `int`。

この時点で **コンパイルエラー** です。

Java のルールでは、

- プリミティブ型（`int` など）と参照型（`String` など）の間に**直接キャストはできない**。
- コンパイラが「不適合な型変換」として弾きます。

エラーメッセージ例:

```java
inconvertible types: int cannot be converted to String
```

---

## ③ 補足

- もしどうしても `"30"` という文字列が欲しいなら、明示的に **文字列変換メソッド** を使います。

```java
String s3 = String.valueOf(s1 + s2);
```

または

```java
String s3 = "" + (s1 + s2);
```

---

✅ 結論：

このコードは **コンパイルエラー**（`int` を `String` にキャストできないため）になります。

---

Hiroakiさん、こういう「プリミティブと参照型のキャスト」をまとめて「どれはコンパイルエラー」「どれは実行時ClassCastException」と整理した表を追加でお作りしましょうか？

# Q,

提案通り、「プリミティブと参照型のキャスト」をまとめて「どれはコンパイルエラー」「どれは実行時ClassCastException」と整理した表を追加で作成してください。

了解です 👍

では **「プリミティブ ↔ 参照型」キャスト**に限定して、**コンパイルエラー**になる場合と、**実行時 ClassCastException (CCE)** になる場合を表で整理しました。

---

# 🔹 プリミティブ ↔ 参照型キャスト早見表

| ケース | 例 | コンパイル結果 | 実行時結果 |
| --- | --- | --- | --- |
| **プリミティブ → 不関連な参照型** | `(String) 10` | **コンパイルエラー**（inconvertible types） | ― |
| **参照型 → 不関連なプリミティブ** | `(int) "10"` | **コンパイルエラー**（inconvertible types） | ― |
| **ラッパークラス → 対応プリミティブ（アンボクシング）** | `Integer i = 10; int x = (int) i;` | コンパイルOK | 実体が `null` の場合 **NullPointerException** |
| **プリミティブ → 対応ラッパークラス**（オートボクシング／キャスト不要） | `Integer i = (Integer) 10;` | コンパイルOK（ただしキャストは冗長） | 正常動作 |
| **対応しないラッパークラス → プリミティブ** | `Double d = 1.2; int x = (int) d;` | コンパイルOK（`int` ← `double` の数値変換として扱う） | 正常（小数部切り捨て） |
| **対応しないラッパークラス → 別の参照型**（Object経由せず） | `String s = (String) Integer.valueOf(1);` | **コンパイルエラー**（inconvertible types） | ― |
| **対応しないラッパークラス → 別の参照型**（Object経由） | `Object o = Integer.valueOf(1); String s = (String) o;` | コンパイルOK | **ClassCastException** |
| **プリミティブ配列 → 参照型** | `Object o = (String[]) new int[5];` | **コンパイルエラー**（inconvertible types） | ― |
| **ラッパークラス配列 → Object配列にキャスト** | `Object[] arr = (Object[]) new Integer[5];` | コンパイルOK | 実体が `Integer[]` なので正常。ただし代入時に ArrayStoreException の可能性 |

---

# 🔹 ポイントまとめ

1. **プリミティブ ↔ 参照型の直接キャストはすべてコンパイルエラー**
    
    （例: `(String) 10`, `(int) "abc"`）
    
2. **ラッパークラス ↔ プリミティブ** は OK
    - アンボクシング／ボクシングの仕組みで扱える。
    - ただし `null` のアンボクシングは **NullPointerException**。
3. **Object を挟んだ場合**
    - コンパイラは一旦許す（`Object` は万能受け皿）。
    - 実行時に実体が違えば **ClassCastException**。
4. **配列**
    - プリミティブ配列は参照型だが、他の参照型配列には互換性がない → コンパイルエラー。
    - 参照型配列は共変（`Integer[]` → `Object[]` はOK）だが、代入時に要素型が不一致なら **ArrayStoreException**。

---

✅ まとめると：

- **「プリミティブ ↔ 参照型」は全部コンパイルエラー**
- **「Object 経由」はコンパイルOKだが実行時CCE**
- **ラッパー ↔ プリミティブ」はOKだが `null` でNPE**

---

Hiroakiさん、もしこの表を **「Java Silver/Gold 試験で問われやすいトリック集」** として試験対策用にアレンジしたバージョンも欲しいですか？