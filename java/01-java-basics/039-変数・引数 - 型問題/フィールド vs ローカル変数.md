# フィールド vs ローカル変数

# Q,

インスタンスメソッド内では this が暗黙に存在し、同名ローカルが無ければフィールド参照として解決される。
フィールドは自動初期化（intなら0）なので num++ もOK。
上記解説中の、フィールドとローカル変数、暗黙的にthisとして扱うなどの観点をまとめてください。

では「フィールドとローカル変数」「this の暗黙利用」まわりを整理した表＋要点まとめを作ります。

---

# 📌 フィールド vs ローカル変数 の整理

| 観点 | フィールド（インスタンス変数） | ローカル変数（メソッド内） |
| --- | --- | --- |
| 宣言位置 | クラス本体（メソッド外） | メソッド内のブロック |
| 所属 | **インスタンス**（オブジェクトごとに存在） | **スタックフレーム**（メソッド呼出ごとに生成・破棄） |
| 初期化 | 自動初期化あり（int=0, boolean=false, 参照型=null） | 自動初期化なし。**必ず明示的初期化が必要** |
| スコープ | クラス全体（ただしアクセス修飾子に従う） | 宣言したブロック内 |
| 名前解決の優先度 | **ローカル変数が優先**（同名があるとフィールドは隠れる＝シャドーイング） | 該当するローカルがなければ、フィールド参照として解決 |
| 暗黙の this | インスタンスメソッド内では `this.field` と同義 | `this` とは無関係。値はそのスコープでしか使えない |
| static 文脈からのアクセス | インスタンスがなければアクセス不可 (`Sample.num` または `new Sample().num`) | static でも宣言すれば利用可能（そのメソッドの中だけ） |

---

# 📌 名前解決と this の暗黙利用

1. **インスタンスメソッド内**
    - `num` と書くと、まずローカル変数を探す
    - 見つからなければ `this.num` としてフィールドを探す
    - だから以下の2つは同じ意味になる：

```java
void m() {
    num++;       // this.num++ と同じ
    this.num++;  // 明示的に書いた場合
}
```

**ローカルが同名の場合（シャドーイング）**

- ローカル変数が優先されるので、フィールドにアクセスしたいときは `this.num` を明示する必要がある

```java
int num = 10; // フィールド
void m() {
    int num = 5;       // ローカル
    System.out.println(num);      // → 5 (ローカル)
    System.out.println(this.num); // → 10 (フィールド)
}
```

**static コンテキスト**

- `this` が存在しないため、フィールドには直接アクセスできない

```java
int num = 10;
static void m() {
    System.out.println(num);     // ✖ コンパイルエラー
    System.out.println(new Sample().num); // 〇
}
```

---

# 📌 まとめ（ポイント）

- **フィールドは this の一部** → インスタンスメソッド内では `this` が暗黙に補われる
- **ローカルはスタック変数** → 自動初期化されず、必ず代入が必要
- **同名ならローカルが勝つ（シャドーイング）** → フィールドを参照したければ `this.field` と明示
- **static には this が無い** → インスタンスフィールドに直接アクセスできない

---

👉 Hiroakiさん、次に整理するとしたら

- 「**シャドーイング／隠蔽の例**（ローカル vs フィールド vs 親クラス）」に広げてまとめますか？
    
    それとも「**メモリ配置（ヒープ vs スタック）観点の違い**」に掘り下げたほうが良いですか？