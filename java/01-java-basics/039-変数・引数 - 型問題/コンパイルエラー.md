# コンパイルエラー

# Q,

変数周りでコンパイルエラーになるケースをまとめられますか？

いいですね！「変数まわり」で**コンパイルエラー**になりやすい代表パターンを、要点＋最小コード例でサクッとまとめます。

（JDK 17 前提。コメント右側に“典型エラー文”も添えています）

---

# 1) 確定的代入（Definite Assignment）違反

**1-1. 自己代入／未初期化の参照**

```java
void f() {
    int x = x; // ✖ variable x might not have been initialized
}
```

1-2. 分岐で必ず代入されない

```java
void f(boolean b) {
    int v;
    if (b) v = 1;
    System.out.println(v); // ✖ variable v might not have been initialized
}
```

1-3. 例外・return で代入パスが欠ける

```java
int g(boolean b) {
    int r;
    if (b) return 1;
    // 他の分岐で r を設定していない
    return r; // ✖ variable r might not have been initialized
}
```

---

# **2) static コンテキストからインスタンスメンバへ**

```java
class C {
    int n = 10;
    static void m() {
        System.out.println(n); // ✖ non-static variable n cannot be referenced from a static context
    }
}
```

---

# 3) 変数の重複定義・スコープ衝突

**3-1. 同一スコープ内での二重宣言**

```java
void f() {
    int a = 1;
    int a = 2; // ✖ variable a is already defined in method f()
}
```

3-2. パラメータ名との衝突

```java
void f(int a) {
    int a = 3; // ✖ variable a is already defined
}
```

3-3. catch 変数・ラムダ引数の名前衝突

```java
void f() {
    int x = 0;
    Runnable r = (x) -> {}; // ✖ lambda parameter x is already defined
}
```

---

# 4) final／effectively final 関連

**4-1. final ローカルの再代入**

```java
void f() {
    final int a = 1;
    a = 2; // ✖ cannot assign a value to final variable a
}
```

4-2. ラムダ／匿名クラスがキャプチャする変数は effectively final 必須

```java
void f() {
    int k = 0;
    Runnable r = () -> System.out.println(k);
    k++; // ✖ local variables referenced from a lambda expression must be final or effectively final
}
```

4-3. “空の final フィールド（blank final）”を全コンストラクタで必ず代入

```java
class C {
    private final int id;        // blank final
    C(boolean ok) {
        if (ok) id = 1;
        // ここで終わると、ok=false のとき未代入の可能性
    } // ✖ variable id might not have been initialized
}
```

---

# 5) フィールドの “前方参照” 禁止（illegal forward reference）

**初期化子／初期化ブロック内で、後で宣言されるフィールドを参照するとNG**

```java
class C {
    int a = b;   // ✖ illegal forward reference
    int b = 1;
}
```

---

# 6) var（ローカル変数型推論）の制約

**6-1. 必ず初期化が必要**

```java
void f() {
    var x; // ✖ cannot use 'var' on variable without initializer
}
```

6-2. null 単独や配列リテラルでは型が決まらない

```java
void f() {
    var x = null;     // ✖ cannot infer type for local variable x
    var a = {1, 2, 3}; // ✖ array initializer is not allowed here
}
```

6-3. フィールド・メソッド引数・戻り値には使えない（使えるのは“ローカル変数”だけ）

```java
class C {
    var f = 1;        // ✖ 'var' is not allowed here
    void m(var p) {}  // ✖ 'var' is not allowed here
    var g() { return 1; } // ✖ 'var' is not allowed here
}
```

---

# 7) 参照できない文脈（到達不能コードではなく“変数”由来のもの）

**7-1. シャドーイングの誤解で “意図せずローカル参照”**

```java
class C {
    int v = 10;
    void m() {
        int v = v; // ✖ variable v might not have been initialized
        // （this.v を使うなら int v = this.v;）
    }
}
```

---

# 8) ループ・switch と確定的代入（代表例）

**8-1. while(false) の中だけで初期化**

```java
void f() {
    int x;
    if (false) { x = 1; }
    System.out.println(x); // ✖ might not have been initialized
}
```

8-2. switch の全パスで代入しない

```java
int g(int n) {
    int r;
    switch (n) {
        case 0 -> r = 0;
        // 他のケースで r を設定していない
    }
    return r; // ✖ might not have been initialized
}
```

---

# 9) 参照先の“種類”ミスマッチ（補足）

**インスタンス・フィールドを this 指定なしでローカルと取り違え**

```java
class C {
    int a = 1;
    void m() {
        int a = a;      // ✖ (未初期化の自己参照)
        int b = this.a; // 〇 明示するとOK
    }
}
```

---

## まとめ（早見表）

- 未初期化ローカル使用：**NG**
- static からインスタンスメンバ直接参照：**NG**
- 変数名の二重定義／衝突：**NG**
- final 再代入／blank final 未代入：**NG**
- ラムダが捕捉するローカルは effectively final 必須：**NG**
- フィールドの前方参照（初期化子内）：**NG**
- `var`：初期化必須／null単独不可／ローカル以外不可：**NG**
- 分岐・switch で「全経路で代入されない」：**NG**

---

必要なら、この一覧を**「OK になる修正版コード」**付きで各ケース展開します。どれから深掘りますか？

# Q,

```java
    int num;
    private void test() {
        num++;
        System.out.println(num);
    }
```

上記コード例①にて、num++; は、データ型の記載がないので、前で宣言されているフィールドと言う認識です。

```java
class C {
    int v = 10;
    void m() {
        int v = this.v;
    }
}
```

上記コード例②では、v にデータ型の記載があるのでローカル変数なので、先で宣言されているフィールドを代入できる。
コード例①のように、メソッド内にてデータ型の記載がない場合にコンパイルエラーになるケースをまとめられますか？

いい質問！「メソッド内で型を書かずに `v++` や `System.out.println(v)` のように **“変数名だけ”** を使ったとき、**どんな時にコンパイルエラーになるか** をケース別にまとめます。

（例①はインスタンスメソッド内で `num` がフィールドなので OK、という前提）

---

# メソッド内「型なし参照」でエラーになる代表パターン

## 1) そもそも見つからない（宣言もフィールドも無い）

```java
void m() {
    System.out.println(v); // ✖ cannot find symbol: variable v
}
```

- そのスコープ階層（ローカル → thisのフィールド → 継承分）に該当名が無い。

---

## 2) static コンテキストからインスタンス・フィールドを参照

```java
int v = 10;
static void m() {
    System.out.println(v); // ✖ non-static variable v cannot be referenced from a static context
}
```

- `static` メソッド/初期化子では、インスタンス（`this`）前提のメンバは直接参照不可。
- `new クラス名().v` のようにインスタンス経由にするか、`v` を `static` に。

---

## 3) 継承元の private フィールドを参照しようとしている

```java
class P { private int v = 10; }
class C extends P {
    void m() {
        System.out.println(v); // ✖ cannot find symbol (Cからは見えない／継承されない)
    }
}
```

- `private` は**継承されない**扱い。サブクラスからは **存在しないのと同じ**。

---

## 4) 同名のメソッドがあるだけで “変数” が無い

```java
int size() { return 0; }

void m() {
    size++; // ✖ bad operand type for unary operator '++'（識別子はメソッド）
}
```

- 名前解決で“変数”が見つからず“メソッド”だけある → `++` などは適用不可。
- `System.out.println(size());` のように**呼び出し**が必要。

---

## 5) 型名と同名（クラス名等）を変数と誤用

```java
void m() {
    String++; // ✖ not a statement / cannot find symbol（型は変数ではない）
}
```

- 型名を変数のように使うと当然エラー。

---

## 6) static ネストクラス内から外側インスタンス・フィールド参照

```java
int v = 10;
static class N {
    void m() { System.out.println(v); } // ✖ non-static variable v ...（外側thisが無い）
}
```

- `static` ネストクラスには外側インスタンスの `this` が無い。

---

## 7) “同名のローカル” が未初期化でフィールドを隠している

```java
int v = 10;
void m() {
    int v;            // ローカル宣言（未初期化）→ フィールド v をシャドーイング
    System.out.println(v); // ✖ variable v might not have been initialized
}
```

- **最も近いスコープ**（ローカル）が優先され、**未初期化ローカル**を参照してしまう。
- フィールドを使いたいなら `System.out.println(this.v);`

---

## 8) import/static import を当てにしたが識別子が解決できない

```java
void m() {
    out.println("x"); // ✖ cannot find symbol: variable out
}
```

- `import static java.lang.System.out;` が無ければ `System.out.println(...)` と書く。

---

# 補足：**エラーにならない**典型（例①のようなケース）

```java
class C {
    int num;
    void m() {
        num++;              // ← インスタンスメソッド内で“this.num”として解決 → OK
        System.out.println(num);
    }
}
```

- **インスタンスメソッド**内では `this` が暗黙に存在し、同名ローカルが無ければ**フィールド参照**として解決される。
- フィールドは**自動初期化**（`int`なら0）なので `num++` もOK。

---

# 迷ったときのチェック順（メソッド内の単独識別子）

1. **同名ローカル/パラメータ**はあるか？（あればそれが最優先）
2. なければ **`this` のフィールド**か？（インスタンスメソッドなら可）
3. それも無ければ **継承チェーン**に可視なメンバがあるか？（`private` は不可）
4. **static 文脈**ではインスタンスメンバは不可
5. それでも無ければ **未解決 → cannot find symbol**

---

必要なら、この各パターンを **“OKになる修正版”** も並記したチートシート化します。どれを深掘りしますか？