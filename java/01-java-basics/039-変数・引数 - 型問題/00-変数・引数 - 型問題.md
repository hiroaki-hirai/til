# 変数・引数 - 型問題

# Q,

int型のデータをlong型へ代入する場合、黙字的な型変換が行われる認識はあっていますか？

はい、Hiroakiさんの認識は**正確**です。

`int`型の値を`long`型へ代入する場合、**暗黙的な型変換（widening primitive conversion）**が行われます。これはJavaの仕様で、安全な変換（情報の損失がない）とみなされているため、明示的なキャストは不要です。

---

### 🔸 具体例：

```java
int i = 100;
long l = i;  // ← 暗黙の型変換（int → long）
```

---

### 🔍 補足：なぜ暗黙に変換できるのか？

- `int` は 32ビット
- `long` は 64ビット
    
    → `long` は `int` より広い範囲の値を表現できるため、**情報の欠落がない**とコンパイラが保証できます。
    

---

### ✅ 対応表：暗黙の型変換が可能なペア（昇順）

| 元の型 | 暗黙変換可能な型 |
| --- | --- |
| byte | short, int, long, float, double |
| short | int, long, float, double |
| char | int, long, float, double |
| int | long, float, double |
| long | float, double |
| float | double |

---

何か別の型変換（例えば、`long` → `int` など）についても確認したい場合は、お気軽に聞いてください。

# Q,

では、メソッドの引数としてint型のデータをlong型の引数へいれることはできますか？

はい、**できます**。

`int`型のデータを、`long`型の引数を受け取るメソッドに渡す場合も、**暗黙的な型変換**が行われるため、問題なく動作します。

---

### 🔸 具体例：

```java
public class Sample {
    public static void main(String[] args) {
        int num = 100;
        printLong(num);  // int → long に自動変換されて渡される
    }

    public static void printLong(long value) {
        System.out.println("受け取った値: " + value);
    }
}
```

### ✅ 実行結果：

```java
受け取った値: 100
```

---

### 🔍 解説：

- `printLong(long value)` は `long` を受け取るメソッド。
- `num` は `int` だが、`long` に安全に変換できるため、**自動的に変換**されて渡される。

---

### ❌ 逆はNG：

```java
public static void printInt(int value) {
    // ...
}

long l = 100L;
printInt(l);  // コンパイルエラー（long → int は暗黙変換されない）
```

`long` → `int` は **情報の損失の可能性**があるため、**明示的なキャスト**が必要です。

---

気になる別のケース（例：`float` → `double`、`char` → `int`など）もあれば、お知らせください。

# Q、

int[]の場合は、long[] 型の変数や引数としていれることはできますか？

とてもよい質問です。

結論から言うと：

> int[] を long[] に代入したり、long[] を引数にとるメソッドに渡すことはできません。
> 

---

### 🔴 なぜできないのか？

Javaでは、**配列の型は要素の型も含めて厳密にチェック**されます。

つまり：

- `int` → `long` は**個々の値**なら暗黙変換できる
- でも `int[]` → `long[]` は**別の型**なので互換性がない

---

### 🔸 例（コンパイルエラーになります）：

```java
public class Sample {
    public static void main(String[] args) {
        int[] intArray = {1, 2, 3};
        long[] longArray = intArray;  // ❌ エラー
    }
}
```

---

### 🔸 引数でもNG：

```java
public static void printLongArray(long[] array) {
    for (long l : array) {
        System.out.println(l);
    }
}

int[] intArray = {1, 2, 3};
printLongArray(intArray);  // ❌ コンパイルエラー
```

---

### ✅ どうすればよいか？

**手動で変換**する必要があります。

```java
int[] intArray = {1, 2, 3};
long[] longArray = new long[intArray.length];
for (int i = 0; i < intArray.length; i++) {
    longArray[i] = intArray[i];  // 暗黙変換される
}
```

---

### 🧠 補足：参照型の配列と異なる点

参照型ではサブクラスの配列をスーパークラスの配列に代入できます（例：`String[]` → `Object[]` は可能）。

しかし、**プリミティブ型配列**（`int[]`, `long[]` など）は**それぞれ完全に異なる型**として扱われます。

---

不明な点があればさらに深掘りもできますよ！

# Q,

プリミティブ型配列は、１次的には参照なのでObject型の変数や引数へいれることができる認識はあっていますか？

はい、Hiroakiさんの認識は**完全に正しい**です！

---

### ✅ 結論：

> プリミティブ型の配列（例：int[] や double[] など）は、Javaでは参照型なので、Object 型の変数や引数に代入できます。
> 

---

### 🔸 例1：変数に代入

```java
int[] nums = {1, 2, 3};
Object obj = nums;  // OK：int[] は Object のインスタンス
```

---

### 🔸 例2：引数に渡す

```java
public static void printObject(Object o) {
    System.out.println("Class: " + o.getClass().getName());
}

int[] arr = {10, 20, 30};
printObject(arr);  // OK
```

✅ 出力結果：

```java
Class: [I
```

`[I` は「int型の1次元配列」を意味する内部表現（JVM仕様）です。

---

### 🔍 補足情報

- `int[]`, `double[]`, `boolean[]` などの**すべての配列**は **`Object` のサブタイプ**です。
- ただし、`Object` 型にした場合、**そのままでは配列の要素にアクセスできません**。

```java
Object obj = new int[]{1, 2, 3};
int[] arr = (int[]) obj;  // キャストすれば使える
```

---

### 🔸 instanceof も使えます：

```java
Object obj = new int[]{1, 2, 3};
System.out.println(obj instanceof int[]);  // → true
```

---

他にも「配列のリフレクション」や「多次元配列の正体（Object[] vs int[][]）」など興味あれば、深掘りもできますよ！

# Q,

プリミティブ型の配列を、Object[] 型の変数や引数へいれることは可能ですか？

とても良い質問です。

結論から言うと：

> 🔴 いいえ、プリミティブ型の配列（例：int[]）を Object[] 型に代入することはできません。
> 

---

### ❌ NG 例：

```java
int[] intArray = {1, 2, 3};
Object[] objArray = intArray;  // コンパイルエラー
```

---

### 🔍 理由：

- `int[]` は `Object` 型の **インスタンス**であるため、`Object` 型の**変数や引数**に渡すことはできます（←これはOK）
- しかし、`int[]` は **`Object[]` のサブクラスではない**ため、`Object[]` には代入できません

---

### ✅ 正しい代入パターンまとめ：

| 配列の型 | `Object` に代入 | `Object[]` に代入 |
| --- | --- | --- |
| `int[]` | ✅ OK | ❌ NG |
| `String[]` | ✅ OK | ✅ OK |
| `Integer[]` | ✅ OK | ✅ OK |

---

### 🔧 回避策（例：`int[]` を `Integer[]` に変換）

プリミティブ型をラッパークラスの配列に変換することで `Object[]` に入れることは可能です：

```java
int[] intArray = {1, 2, 3};
Integer[] boxedArray = Arrays.stream(intArray).boxed().toArray(Integer[]::new);
Object[] objArray = boxedArray;  // ✅ OK
```

---

### ✅ 補足ポイント

- `int[]` は「プリミティブ型の配列」であり、`Object` ではあるが `Object[]` ではない
- `String[]` や `Integer[]` のような**参照型の配列**は `Object[]` に代入可能

---

必要であれば、配列の型階層図や、リフレクションを使った配列操作の例もご紹介できます！

# Q,

上記の変数や引数として代入可能不可のケースをまとめてください。

もちろんです、Hiroakiさん。

以下に、**プリミティブ型配列**と**参照型配列**について、

`Object`型・`Object[]`型の**変数**または**引数**に代入できるかを一覧でまとめました。

---

### ✅ 配列の代入可否まとめ表

| 配列の型 | `Object` に代入 | `Object[]` に代入 | 備考 |
| --- | --- | --- | --- |
| `int[]` | ✅ 可能 | ❌ 不可 | プリミティブ型の配列は `Object[]` のサブタイプではない |
| `double[]` | ✅ 可能 | ❌ 不可 | 同上 |
| `boolean[]` | ✅ 可能 | ❌ 不可 | 同上 |
| `char[]` | ✅ 可能 | ❌ 不可 | 同上 |
| `Integer[]` | ✅ 可能 | ✅ 可能 | ラッパークラスの配列は `Object[]` にも代入可能 |
| `String[]` | ✅ 可能 | ✅ 可能 | 参照型の配列は `Object[]` に代入可能 |
| `Object[]` | ✅ 可能 | ✅ 可能 | 同一型なので当然可能 |
| `List<?>[]` | ✅ 可能 | ✅ 可能 | 参照型配列なのでOK |
| `Object` | - | - | 単一オブジェクトであり配列ではない |

---

### 🔍 具体例（コード）

### ✅ `int[]` を `Object` に渡す（OK）：

```java
int[] arr = {1, 2, 3};
Object o = arr;  // OK
```

❌ `int[]` を `Object[]` に渡す（NG）：

```java
int[] arr = {1, 2, 3};
Object[] oArr = arr;  // コンパイルエラー
```

✅ `Integer[]` を `Object[]` に渡す（OK）：

```java
Integer[] arr = {1, 2, 3};
Object[] oArr = arr;  // OK
```

---

### 💡 補足

- `Object[]` は「**オブジェクトの配列**」であり、「**オブジェクトそのもの（配列含む）**」ではありません。
- `int[]` は `Object` ではあるが、**`Object[]` の要素型要件を満たしていない**ため代入できません。

---

ご希望があれば、この表をPDFやMarkdown形式にもできますし、`List<Integer>` との比較なども対応可能です！

[可変長引数](%E5%A4%89%E6%95%B0%E3%83%BB%E5%BC%95%E6%95%B0%20-%20%E5%9E%8B%E5%95%8F%E9%A1%8C%2023462cef73508016baa7d1706492cd57/%E5%8F%AF%E5%A4%89%E9%95%B7%E5%BC%95%E6%95%B0%2023662cef735080c39a96fa54ef58025a.md)

[コンパイルエラー](%E5%A4%89%E6%95%B0%E3%83%BB%E5%BC%95%E6%95%B0%20-%20%E5%9E%8B%E5%95%8F%E9%A1%8C%2023462cef73508016baa7d1706492cd57/%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%82%A8%E3%83%A9%E3%83%BC%2025a62cef735080ad80e7d965cc9c01bc.md)

[フィールド vs ローカル変数](%E5%A4%89%E6%95%B0%E3%83%BB%E5%BC%95%E6%95%B0%20-%20%E5%9E%8B%E5%95%8F%E9%A1%8C%2023462cef73508016baa7d1706492cd57/%E3%83%95%E3%82%A3%E3%83%BC%E3%83%AB%E3%83%89%20vs%20%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E5%A4%89%E6%95%B0%2025a62cef735080c386edd65c49c06c00.md)

[キャスト](%E5%A4%89%E6%95%B0%E3%83%BB%E5%BC%95%E6%95%B0%20-%20%E5%9E%8B%E5%95%8F%E9%A1%8C%2023462cef73508016baa7d1706492cd57/%E3%82%AD%E3%83%A3%E3%82%B9%E3%83%88%2025e62cef735080c2951af449779938af.md)