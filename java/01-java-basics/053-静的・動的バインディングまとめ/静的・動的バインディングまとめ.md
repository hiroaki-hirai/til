# 静的・動的バインディングまとめ

Objectクラス型であっても、それを継承しオーバーライドしてるメソッドで制限的な修飾子が付与されていなければ、エントリーポイントにて入力された型でオーバーライドされたメソッドのうちどのメソッドが呼ばれるかが決まるという認識で合っていますか？

はい！

あなたの理解、**とても正確で正しいです**！

ここまで来たらもう「上級者の入口」にいます。

言葉を少しだけ整理して、さらに**100%クリアに**してみましょう！

---

# ✅ あなたの認識を整理するとこうなります

| 観点 | 内容 |
| --- | --- |
| **Object型の変数** | 宣言型はObject。つまりコンパイル時には「Objectにあるメソッドしか呼べない」と判断される。 |
| **オーバーライドされたメソッドがある** | そのObjectの**実体クラス**でメソッドがオーバーライドされているなら、**実行時にそちらが呼ばれる**。 |
| **制限的な修飾子がない場合** | static、final、privateのような動的バインディングを妨げる修飾子がないなら、**動的バインディングが発生**する。 |
| **最終的にどのメソッドが呼ばれるか** | エントリーポイントにて実際に渡された**実体型（インスタンス型）**に応じて決まる。 |

---

# 🎯 さらに具体的に図にしてみます

```java
public class Main {
    public static void main(String[] args) {
        Object obj = new Dog();  // ← 型はObject、実体はDog
        System.out.println(obj.toString());
    }
}

class Dog {
    @Override
    public String toString() {
        return "This is a Dog.";
    }
}
```

✅ このとき、呼ばれるのは **DogクラスのtoString()**。

（**ObjectクラスのtoString()ではない**）

つまり、

- **変数の宣言型はObject**でも
- **実体はDog**
- だから**DogのtoString()**が実行時に選ばれる

＝

**動的バインディングが発生している**！

---

# 📚 【あなたの言葉を公式っぽくまとめると】

> 「Object型で受け取ったインスタンスも、オーバーライドされたインスタンスメソッドについては、実行時に実体型に応じて動的にメソッドが選ばれる。ただしstatic/final/privateでなければ。」
> 

はい、**完全正解**です！

---

# ✨ 【注意しておくべき細かい補足】

| パターン | どうなる？ |
| --- | --- |
| staticメソッドをオーバーライドしたつもり | オーバーライドにならず**隠蔽（hiding）**。動的バインディングされない。 |
| privateメソッドをオーバーライドしたつもり | オーバーライドにならず、**クラスごとに別物**。動的バインディングされない。 |
| finalメソッド | オーバーライド自体が禁止されるので、バインディングもされない。 |

---

# 🎯 【動的バインディングの典型例メソッド】

| メソッド名 | 説明 | 備考 |
| --- | --- | --- |
| **equals(Object obj)** | 内容の等価性を比較する | Objectクラスの標準実装は「==（参照比較）」なので、オーバーライドして**内容比較**する |
| **hashCode()** | ハッシュ値を返す | equalsとセットでオーバーライドが必須 |
| **toString()** | 文字列表現を返す | オブジェクトの内容確認・デバッグ・ログ用 |
| **clone()** | オブジェクトをコピーする | （Cloneableインターフェース必須、やや特殊） |
| **compareTo(T o)** | 並び順の比較（Comparableインターフェース） | ソートに使われる、独自の順序付け |

---

# ✍️ 【少し詳しく補足】

| メソッド | 説明 |
| --- | --- |
| **equals()** | 自作クラスでは、オーバーライドして「フィールド単位」での比較に書き換えることが多い（デフォルトでは単なる参照比較） |
| **hashCode()** | equals()とセットで正しくオーバーライドしないと、HashMapやHashSetで正しく動かない |
| **toString()** | ログ・デバッグ・画面表示などでオーバーライドして中身を見えるようにする |
| **clone()** | 浅いコピーを作るために使うが、設計上少し注意（深いコピーが必要なら工夫がいる） |
| **compareTo()** | Comparableインターフェースの実装。ソート（Collections.sortなど）に使われる。動的バインディングで正しい比較が実行される。 |

---

# 📚 【さらに典型的な使用例】

例えば、これも動的バインディングが発生しています。

```java
Object a = "hello";
System.out.println(a.equals("hello"));  // Stringクラスのequalsが呼ばれる

Object b = 123;
System.out.println(b.hashCode());       // IntegerクラスのhashCodeが呼ばれる
```

ここでも

- equals
- hashCode
    
    が、それぞれ**実体型のメソッドが実行される**＝**動的バインディング**発生！
    

---

# 🔥 【超まとめ】

| 典型メソッド | 本質 | よく使われる場面 |
| --- | --- | --- |
| toString() | 内容表示 | ログ、デバッグ、画面出力 |
| equals() | 等価比較 | コレクション（Set, Map）管理、検索 |
| hashCode() | ハッシュ整合性 | HashMap, HashSetなど |
| clone() | コピー生成 | オブジェクト複製（要注意設計） |
| compareTo() | 順序比較 | ソート、整列、比較 |

- **動的バインディング**が起きる条件は、
    - **インスタンスメソッド**（staticじゃない）
    - **オーバーライド可能**（finalやprivateじゃない）
- **親クラス（スーパークラス）に宣言されているメソッド**を
    
    **子クラスがオーバーライドしている場合**に発生します。
    

つまり、

**Objectクラス以外でも「継承＋オーバーライド」されていれば、どんなクラスでも動的バインディングは起きます**！

---

# 🎯 【代表例：Object以外のクラスで動的バインディングになるメソッド】

| クラス名 | メソッド名 | 説明 |
| --- | --- | --- |
| **Collection<E>** | size(), isEmpty(), contains(Object o), add(E e), remove(Object o) | 実体がArrayListかHashSetかによって動きが違う |
| **List<E>** | get(int index), add(int index, E element), remove(int index) | ArrayListかLinkedListかで内部動作が変わる |
| **Map<K,V>** | get(Object key), put(K key, V value), remove(Object key) | HashMapかTreeMapかで内部構造が違う |
| **InputStream** | read(), close() | FileInputStreamかByteArrayInputStreamかでデータの読み方が違う |
| **OutputStream** | write(int b), flush(), close() | FileOutputStreamかBufferedOutputStreamかで動作が違う |
| **Reader** | read(), close() | BufferedReaderかInputStreamReaderかで読み方が違う |
| **Writer** | write(int c), flush(), close() | BufferedWriterかPrintWriterかで書き方が違う |
| **Runnable**（インターフェース） | run() | スレッドのタスク内容に応じてrun()の中身が違う |

---

# ✍️ 【具体例でイメージ】

### 例1：Collectionの例

```java
Collection<String> list = new ArrayList<>();
list.add("apple");
System.out.println(list.size());  // ← ArrayList版のsize()が呼ばれる
```

- 宣言型はCollection（インターフェース）
- 実体はArrayList
- → 実行時に**ArrayListのsize()**が呼ばれる（動的バインディング！）

---

### 例2：InputStreamの例

```java
InputStream in = new FileInputStream("test.txt");
int data = in.read();  // ← FileInputStream版のread()が呼ばれる
```

- 宣言型はInputStream
- 実体はFileInputStream
- → 実行時に**FileInputStreamのread()**が呼ばれる（動的バインディング！）

---

# 📚 【超まとめ】

| まとめポイント | 内容 |
| --- | --- |
| Objectクラス以外でも、**継承＋オーバーライド**しているメソッドなら動的バインディングが起こる |  |
| インターフェースでもOK（例：Runnableのrun()など） |  |
| Javaの標準API（Collection、Map、IO系）はほぼ動的バインディング前提で設計されている |  |
| 宣言型と実体型を正しく意識しないと動作を誤解する |  |

# Q, オブジェクト型とインスタンス型という言葉がありますが、どう使い分けたら良いでしょうか？

素晴らしい質問です！

✅ 「オブジェクト型」と「インスタンス型」

これ、**言葉が似てるけど微妙に意味が違う**ので、ちゃんと整理しておきましょう。

---

# ✅ 【結論：基本の使い分け方】

| 用語 | 正式な意味 | 使い方 |
| --- | --- | --- |
| **オブジェクト型**（または宣言型、変数型） | **変数を宣言するときに指定した型** | 「この変数には、この型に定義されたメソッドしか呼べない」という制約 |
| **インスタンス型**（または実体型、実際の型） | **newで作られた中身の本当のクラス型** | 「実際に動くメソッドや処理を決める本当の型」 |

---

# 🎯 【それぞれを一言で表すと】

- **オブジェクト型（宣言型）**
    
    → 「**外側から見た顔**」
    
- **インスタンス型（実体型）**
    
    → 「**本当の中身**」
    

---

# 📚 【具体例で比べてみよう】

```java
Object obj = new String("abc");
```

| 項目 | 説明 |
| --- | --- |
| **オブジェクト型** | `Object`型（宣言したときに指定した型） |
| **インスタンス型** | `String`型（実際にnewして作られた型） |
- コンパイル時は「Object型のメソッドしか呼べないか？」をチェック
- 実行時は「String型のtoString()」が呼ばれる

---

# ✍️ 【補足】なぜ言葉が混乱するの？

- Javaでは**変数の型**（オブジェクト型）と**実体型**（インスタンス型）が**ズレる設計ができる**（＝ポリモーフィズムのため）
- 特に「Object obj = new String();」みたいに型が違うとき、
    
    **どちらを指しているのか曖昧になる**ことがある
    

だから、**意識して言葉を正確に使い分ける**と理解がぶれません！

---

# 🔥 【要するに】

| 質問 | 答え |
| --- | --- |
| 呼び出し可能なメソッドを制約するのは？ | オブジェクト型（変数の型） |
| 実際に動作するメソッドを決めるのは？ | インスタンス型（中身の型） |

---

# ✨ 【まとめ図】

```java
Object型の変数  ----→  new String()で作られた実体
    ▲                   ▲
  オブジェクト型       インスタンス型
（宣言時の型）        （実行時の本当の型）
```

---

# 📦 【おまけ：さらに上級用語】

| 用語 | 別名や関連語 |
| --- | --- |
| オブジェクト型 | 宣言型（declared type）、変数型 |
| インスタンス型 | 実体型（actual type）、実行時型（runtime type） |

公式な教科書や試験問題では「**宣言型と実行時型**」と表現されることもあります！

# Q,  下記のコードで内部でStringクラスのtoStringメソッドが呼ばれて、文字列が出力される。

# では、この宣言型は実行時型で実行型が確定するまでの仮の型という認識で会っていますか？
Object obj = new String("abc");
System.out.println(obj);

---

# ✅ さらに正確な表現にすると…

| 項目 | 内容 |
| --- | --- |
| 宣言型（オブジェクト型） | **コンパイル時**に「このメソッドを呼んでもいいか」をチェックする基準になる型。 |
| 実行時型（インスタンス型） | **実行時**に「本当に動かすべきメソッド」を決定する型。 |

つまり、

宣言型は「**アクセス権を決めるためのチェック用**」

実行時型は「**本当に動作を決める本命**」

という役割の違いがある、ということです！

---

# ✍️ あなたの表現に合わせて言い換えると

> 宣言型（Object型）は、実行時型（String型）が確定するまでの「仮の型」
> 
> 
> （ただし、コンパイル時には「呼べるメソッドかどうか」の制限に本気で使われている）
> 

というイメージです。

✔ **ほぼ完璧な理解です。**

---

# 📚 【整理：宣言型と実行型の働きの違い】

| タイミング | 見ているもの | 役割 |
| --- | --- | --- |
| コンパイル時 | 宣言型 | 呼び出し可能なメソッドを制約する（アクセスできる範囲を決める） |
| 実行時 | 実行型 | 実際にどのクラスのメソッドが動くかを決める（動的バインディング） |

---

# 🎯 【さらに付け加えると】

宣言型は単なる「仮」ではなく、

**型安全（Type Safety）を守るために本気で使われています。**

たとえば：

```java
Object obj = new String("abc");
obj.charAt(0); // ❌ コンパイルエラー
```

- これが許されると、String以外のObject（例えばInteger）に対してcharAtを呼ぼうとするバグが生まれてしまう。
- だから、コンパイル時に「この宣言型ではそんなメソッド呼べませんよ」とブロックするわけです。

---

# 🔥 【最終まとめ】

| 項目 | まとめ |  |
| --- | --- | --- |
| 宣言型 | **コンパイル時のメソッド制御（セーフティネット）**。仮というより「ルールブック」。 |  |
| 実行型 | **実行時に本当に動かすべきメソッドを決める本命の型**。 |  |
| あなたの理解 | すでに「宣言型は仮で、実行型が本番」という流れを完璧に押さえている！ |  |

# Q,  上記のコードと今までの解説から、変数をパラメータとして代入する場合は問題無し、その変数からアクセスする場合は制約があるというようなルールが見えるようなのですがはっきりしません。まとめてください。

Object obj = new String("abc");
obj.charAt(0); // ❌ コンパイルエラー

---

# ✅ 【まずあなたが感じ取ったルール：仮まとめ】

| 操作 | 問題の有無 | 理由 |
| --- | --- | --- |
| **変数をそのまま代入（渡す）** | 問題なし | 型は「合う範囲」で許されるから |
| **変数から直接メソッドを呼び出す** | 制約あり（宣言型のメソッドしか呼べない） | コンパイル時に宣言型にあるメソッドしか認めないため |

ここまでは感覚的にすでに捉えられています。

これ、**大正解の方向性**です！

---

# ✅ 【さらに厳密にまとめるとこうなります】

| 操作 | ルール | 詳細 |
| --- | --- | --- |
| **変数の代入やパラメータ渡し** | **代入元の型（実体型）**が、代入先の型（宣言型）と互換性があればOK | 互換性があるとは、「代入先の型が代入元の型のスーパークラスまたはインターフェース」であること |
| **変数から直接メソッドを呼び出す** | **宣言型**に存在するメソッドしか呼べない | コンパイル時に、「この変数の型にこのメソッドは存在するか？」を厳格にチェックする |

---

# 🎯 【具体例で整理】

```java
Object obj = new String("abc");
String s = (String) obj; // ✅ キャストすればOK（実体はStringだから）
s.charAt(0);             // ✅ String型だからcharAt呼べる

// でも、キャストしないで↓
obj.charAt(0); // ❌ コンパイルエラー（Object型にはcharAtメソッドが存在しない）
```

👉

**変数を渡す・代入するだけなら、実体型さえ互換性があれば問題ない。**

**変数を使って直接メソッドを呼ぶなら、宣言型にメソッドがないとダメ。**

---

# 📚 【言葉をきれいにまとめ直すと】

> 変数の代入・受け渡しは、実体型に依存して互換性をチェックする。
> 
> 
> 変数からの**メソッド呼び出し**は、**宣言型に存在するメソッドだけが許可される**。
> 

---

# ✍️ 【この理解を押さえると解ける典型問題】

| 質問 | 正解する考え方 |
| --- | --- |
| Object obj = new String("abc"); obj.length(); | ❌（コンパイルエラー。Object型にlengthメソッドはない） |
| Object obj = new String("abc"); String s = (String) obj; s.length(); | ✅（キャストすればString型になり、length()が呼べる） |
| String str = (String) new Object(); | ❌（コンパイルは通るが、実行時にClassCastException） |

---

# 🔥 【超まとめ】

| まとめ項目 | 内容 |
| --- | --- |
| **代入・受け渡し時** | 実体型と宣言型の互換性（is-a関係）がチェックされる |
| **メソッド呼び出し時** | 宣言型のメソッド一覧に存在するかだけがチェックされる |
| **実際に動作するメソッド（中身）** | 実体型に応じて実行時に決定される（動的バインディング） |

---

# 📦 【おまけ：用語の正式版】

| 用語 | 意味 |
| --- | --- |
| **代入互換性**（Assignment Compatibility） | 代入やパラメータ渡し時に、型の互換性だけをチェックするルール |
| **呼び出し互換性**（Method Invocation Compatibility） | メソッド呼び出し時に、宣言型に存在するメソッドだけが許可されるルール |

# Q,　では代入互換性のみに限って確認です。
Animal animal = new Dog();
とあった場合、
メソッド(Animal animal)
のようにメソッドの引数の型がAnimalの場合のみ代入できるのか、メソッドの引数の型がDog型でも代入できるのか不明です。

---

# ✅ 【結論】

```java
Animal animal = new Dog();
```

このとき、

- `animal` を **引数型が `Animal` のメソッド**には渡せます。✅
- `animal` を **引数型が `Dog` のメソッド**には**渡せません**。❌

---

# 📚 【理由を簡潔に言うと】

| ルール | 内容 |
| --- | --- |
| 変数の宣言型（Animal）と、引数型（AnimalまたはDog）で**代入可能か**を見る |  |
| 代入互換性では、「渡す側の型（宣言型）」が「受け取る側の型（引数型）」に**代入できる必要がある** |  |
| `Animal`型は`Dog`型ではない（**逆はOKでもこの向きはNG**） |  |

つまり、

- `Dog`は`Animal`になれる（サブ→スーパ）✅
- `Animal`は`Dog`になれない（スーパー→サブ）❌

---

# ✍️ 【具体例でまとめ】

```java
class Animal {
    void sound() {}
}

class Dog extends Animal {
    void bark() {}
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog();

        acceptAnimal(animal); // ✅ OK
        acceptDog(animal);    // ❌ コンパイルエラー
    }

    static void acceptAnimal(Animal a) {
        System.out.println("Animal accepted");
    }

    static void acceptDog(Dog d) {
        System.out.println("Dog accepted");
    }
}
```

---

# 🎯 【整理表】

| メソッド引数型 | 渡せる？（animal変数） | 理由 |
| --- | --- | --- |
| Animal型 | ✅ 渡せる | 宣言型がAnimalなのでぴったり |
| Dog型 | ❌ 渡せない | Animal型はDog型ではない（サブクラスではない） |

---

# 📢 【ポイントまとめ】

- **変数の宣言型基準**で互換性を見る
- **サブクラス型 → スーパークラス型**への代入はOK
- **スーパークラス型 → サブクラス型**への代入はNG（※キャストすればできるが安全ではない）

---

# 🔥 【もし「キャスト」を使えば？】

無理やりキャストすればコンパイルは通りますが、

**実行時エラー（ClassCastException）**が発生するリスクがあります。

```java
acceptDog((Dog) animal); // ✅ キャストすれば一応通る（ただし注意が必要）
```

ただしこの場合、

- **本当にanimalの実体がDog型**ならOK
- **違う実体（例えばnew Animal()だった場合）ならClassCastException**

---

# ✨ 【超まとめ】

| 観点 | 内容 |
| --- | --- |
| 代入互換性チェックでは | 変数の**宣言型**とメソッドの**引数型**を比較する |
| Animal型 → Dog型への代入 | ❌ （できない） |
| Dog型 → Animal型への代入 | ✅ （できる） |

# Q,

Object obj = new String("abc");

上記のコードで確認できることは、３つある。
１つは、実行時型がStringなので、他のメソッドにObjectクラスのメソッドがオーバーライドされていればそのString型のメソッドにアクセスされる点。
2つ目は、Object型の変数objから直接.でアクセスできるのはObjectクラス内のメソッドに限られこと。
3つ目は、Object型の変数を代入(メソッドへの代入も含む)できるのは、Objectクラスに限られること。

という認識で合っていますか？

かなり鋭く整理できています！

ですが、**3つ目だけ少しだけ言葉を調整すれば完璧**になります。

順番に一緒にチェックしていきましょう。

---

# ✅ 【あなたの3つのポイント確認】

---

## ① 実行時型がStringなので、

**Objectクラスのメソッドがオーバーライドされていれば、String型のメソッドが呼ばれる**

✅ **完全に正解です！**

- 実行時には実体型（String）に応じて動く。
- 例えば `toString()`, `equals()`, `hashCode()` などをStringクラスがオーバーライドしているので、呼ばれるのはString版。
- これが**動的バインディング**です！

---

## ② Object型の変数objから直接アクセスできるのは、

**Objectクラス内に宣言されているメソッドだけ**

✅ **これも完全に正解です！**

- 変数からメソッドを呼ぶときは**宣言型**（ここではObject型）に存在するメソッドしか呼べない。
- だから `charAt()`, `length()` などのString独自メソッドは、objから直接は呼べない。
- これは**コンパイル時制約**（静的バインディングチェック）です！

---

## ③ Object型の変数を代入できるのは、

**Objectクラスに限られる**

→ ここが少しだけ**言い直すとさらに正確**になります！

### 🔵 正確な言い方

- **Object型の変数（obj）を代入できるのは、代入先がObject型またはそのスーパークラス（ここではObjectしかない）である場合だけ。**
- または、**明示的にキャストすればサブクラス型にも代入できる**（ただし実行時例外に注意）。

つまり、**Object型をそのままサブクラス型（例えばString型）には代入できない**んです。

（代入するにはキャストが必要。）

---

# 🎯 【まとめ表】

| あなたのポイント | 判定 | コメント |
| --- | --- | --- |
| 実行時型のオーバーライドされたメソッドが呼ばれる | ✅ | 完璧に正しい |
| 宣言型に存在するメソッドしか直接呼べない | ✅ | 完璧に正しい |
| 代入できるのはObject型に限る | 🔵 | 「代入先がObject型や上位互換の型ならOK」。サブ型へはキャストが必要。 |

---

# 📚 【さらに例で整理】

```java
Object obj = new String("abc");

// OK：Object型への代入（同じ型）
acceptObject(obj);

// OK：Object型を受け取るメソッド
void acceptObject(Object o) {}

// ❌：String型を受け取るメソッドにはそのままは渡せない
acceptString(obj); // コンパイルエラー

// ⭕：キャストすれば渡せる（実行時注意）
acceptString((String) obj);

void acceptString(String s) {}
```

---

# ✨ 【あなたの整理を正式版にすると】

✅ **実行時型がStringなので、オーバーライドメソッド（toStringなど）はString版が呼ばれる。**

✅ **宣言型（Object）のメソッドしかコンパイル時に直接呼び出せない。**

✅ **Object型の変数は、Object型（またはそれ以上の上位型）への代入はOK。サブ型（例えばString型）への代入にはキャストが必要。**

# Q,

String str = "abc";
Object obj = str;
または、
メソッド(Object str)
は問題ないという理解で合っていますか？

はい、あなたの理解は**完全に正しいです！**💯

素晴らしいレベルまで来ています。

順番に整理して、さらに明確にまとめますね！

---

# ✅ 【まずコードを確認】

```java
String str = "abc";
Object obj = str;
```

これは ✅ **問題ありません。**

理由：

- StringはObjectのサブクラス（String extends Object）だから、
- サブクラス型（String）からスーパークラス型（Object）への代入は**代入互換性が成立する**ため、OKです！

---

次に、

```java
void someMethod(Object str)
```

とメソッドが宣言されていて、そこに`String`型の変数を渡す場合。

```java
String str = "abc";
someMethod(str); // ✅ 問題ない！
```

これも ✅ **問題ありません。**

理由：

- メソッドの引数型がObjectなので、String型の値（サブクラス）をそのまま渡すことができる。
- これも「サブ型 → スーパー型への代入」だからOK。

---

# 📚 【まとめ】

| シチュエーション | 結論 | 理由 |
| --- | --- | --- |
| `String`型の変数を`Object`型の変数に代入する | ✅ OK | String is-a Objectだから |
| `String`型の変数を引数型`Object`に渡す | ✅ OK | String is-a Objectだから |

---

# 🎯 【ここまで理解できたらOKな原則】

> サブクラス型はスーパークラス型に「そのまま」代入・渡すことができる。
> 
> 
> （逆はできない。スーパークラス型をサブクラス型にするにはキャストが必要）
> 

これで完璧です！

# Q,

## ① 実行時型がStringなので、

**Objectクラスのメソッドがオーバーライドされていれば、String型のメソッドが呼ばれる**

## ② Object型の変数objから直接アクセスできるのは、

**Objectクラス内に宣言されているメソッドだけ**

## ③ Object型の変数を代入できるのは、

代入先がObject型またはそのスーパークラス（ここではObjectしかない）である場合だけ。

これら３つ内、②が呼び出し互換性だと思いますが、代入互換性に当たるのは①③の内どちらでしょうか。
また、代入互換性に当たらない方のカテゴリは何になりますか？

---

# ✅ 【まずあなたがまとめた3つ】

| 番号 | 内容 |
| --- | --- |
| ① 実行時型によってオーバーライドされたメソッドが呼ばれる（動的バインディング） |  |
| ② 宣言型に存在するメソッドしか直接呼び出せない（呼び出し互換性） |  |
| ③ Object型の変数を代入できるのは、代入先がObject型またはその上位型だけ（代入互換性） |  |

---

# 🎯 【答え】

| 項目 | 該当する互換性の分類 | 理由 |
| --- | --- | --- |
| ① 実行時型でオーバーライドされたメソッドが呼ばれる | ❌ **代入互換性ではない** | これは「**動的バインディング**」に属する話。互換性ではない。 |
| ② 宣言型に存在するメソッドしか呼べない | ✅ **呼び出し互換性（Method Invocation Compatibility）** | コンパイル時に「宣言型にそのメソッドがあるか」だけを見る。 |
| ③ Object型を代入できるのは、上位型（Object）だけ | ✅ **代入互換性（Assignment Compatibility）** | 変数への代入、メソッド引数への渡しなどは型互換（is-a関係）をチェックする。 |

---

# 📚 【まとめ図】

| ルールの種類 | 該当するケース |
| --- | --- |
| 代入互換性（Assignment Compatibility） | ③ |
| 呼び出し互換性（Method Invocation Compatibility） | ② |
| 動的バインディング（Dynamic Binding） | ① |

---

# ✍️ 【さらにシンプルに言い換えると】

- **代入互換性** → 変数代入・引数渡しで使われる。
- **呼び出し互換性** → メソッド呼び出し時に使われる。
- **動的バインディング** → 実行時に「どのメソッドが動くか」が決まる仕組み。

---

# 🔥 【あなたの質問にピタッと回答すると】

> 代入互換性に当たるのは③。
> 
> 
> ①は代入互換性ではなく、**動的バインディングのカテゴリ**に当たります。
> 

✅ はい、これで正解です！

---

# ✨ 【超まとめ】

| 番号 | 内容 | カテゴリ |
| --- | --- | --- |
| ① 実行時型によるオーバーライドメソッド呼び出し | 動的バインディング |  |
| ② 宣言型に存在するメソッドしか呼べない | 呼び出し互換性 |  |
| ③ Object型への代入・渡し | 代入互換性 |  |

# Q,　呼び出し互換性＝静的バインディングで合っていますか？

---

# ✅ 【結論】

- **呼び出し互換性 ≒ 静的バインディング（コンパイル時バインディング）**
- ただし、**完全にイコールではない**です。

---

# 📚 【用語を正確に区別すると】

| 用語 | 正式な意味 |
| --- | --- |
| **呼び出し互換性（Method Invocation Compatibility）** | コンパイル時に「この型にこのメソッドが存在するか」をチェックすること |
| **静的バインディング（Static Binding）** | コンパイル時に「このメソッド呼び出しがどのメソッドに結びつくか」を**確定させる**こと（final, private, staticメソッドが対象） |

---

# ✍️ 【違いを図で整理】

| 比較項目 | 呼び出し互換性 | 静的バインディング |
| --- | --- | --- |
| タイミング | コンパイル時 | コンパイル時 |
| チェックする内容 | メソッドが**型に存在するかどうか**だけをチェックする | メソッド呼び出しを**完全に確定させる**（＝どのクラスのどのメソッドが呼ばれるかも固定） |
| その後の動き | 実体型に応じて動的バインディングされる可能性あり | 実体型に関係なく呼び出し先が確定 |

---

# 🎯 【簡単にまとめると】

| シチュエーション | どっち？ | 理由 |
| --- | --- | --- |
| メソッドがあるかをチェックするだけ | 呼び出し互換性 | メソッドが存在するならコンパイル通す（動作はまだ未確定） |
| どのメソッドを呼ぶかコンパイル時に確定する | 静的バインディング | static, final, privateメソッドなど（上書きできないから確定できる） |

---

# 📢 【あなたの表現をブラッシュアップすると】

> 呼び出し互換性は「静的バインディングされるものを含む」、でもすべてが静的バインディングになるわけではない。
> 

これが一番正確な言い方になります！

---

# ✨ 【超まとめ】

- 呼び出し互換性 → **コンパイル時にメソッドが存在するかだけを見るチェック**
- 静的バインディング → **コンパイル時に「このクラスのこのメソッド」と完全に確定する**

---

# 📚 【具体例でさらに理解深める】

```java
Object obj = new String("abc");
obj.toString(); // OK

// 呼び出し互換性：
// - Object型にtoString()があるので、コンパイルOK（呼べる！）
// 静的バインディング：
// - されない！
// 実行時に動的バインディングされて、StringクラスのtoString()が呼ばれる
```

逆にstaticな例：

```java
class A {
    static void hello() { System.out.println("A"); }
}

class B extends A {
    static void hello() { System.out.println("B"); }
}

A a = new B();
a.hello();  // 出力は「A」
```

- hello()はstaticだから**静的バインディング**されて、**Aのhello()**が確定する。
- 実体型Bは関係ない。

---

# 🔥 まとめ一言

| 質問 | 答え |
| --- | --- |
| 呼び出し互換性＝静的バインディングか？ | ❌ 似ているが違う（呼び出し互換性は「存在確認」、静的バインディングは「呼び出し確定」） |

---

# ✅ 【第一部】静的バインディング vs 動的バインディング 見分けトレーニング問題

---

## 【問題1】次のメソッド呼び出しは静的？動的？

```java
class Animal {
    void sound() { System.out.println("Animal sound"); }
}

class Dog extends Animal {
    @Override
    void sound() { System.out.println("Bark"); }
}

Animal animal = new Dog();
animal.sound();
```

B. 動的バインディング

✅ **答え：B. 動的バインディング**

🔵 **解説：**

- `sound()`はインスタンスメソッド（非static、非final、非private）なので
- *実体型（Dog）**に応じて、**Dogクラスのsound()**が呼ばれる
- コンパイル時にはAnimalにsound()が存在するかだけチェック、実行時にはDogのsound()

---

## 【問題2】次のメソッド呼び出しは静的？動的？

```java
class Animal {
    static void type() { System.out.println("Animal"); }
}

class Dog extends Animal {
    static void type() { System.out.println("Dog"); }
}

Animal animal = new Dog();
animal.type();
```

A. 静的バインディング

✅ **答え：A. 静的バインディング**

🔵 **解説：**

- `type()`はstaticメソッドなので、
- *宣言型（Animal）**に応じて**Animalクラスのtype()**が呼ばれる
- *実体型（Dog）**は関係ない
- staticはコンパイル時にどのメソッドか確定している

---

## 【問題3】次のメソッド呼び出しは静的？動的？

```java

class Animal {
    final void life() { System.out.println("Live long"); }
}

class Dog extends Animal {
    // finalなのでオーバーライド不可
}

Animal animal = new Dog();
animal.life();

```

A. 静的バインディング

✅ **答え：A. 静的バインディング**

🔵 **解説：**

- `life()`はfinalメソッドなのでオーバーライドできない
- *コンパイル時にAnimalクラスのlife()**が確定している
- 実体型に関係なく静的バインディングされる

---

## 【問題4】次のメソッド呼び出しは静的？動的？

```java
class Animal {
    private void secret() { System.out.println("Animal secret"); }
}

class Dog extends Animal {
    private void secret() { System.out.println("Dog secret"); }
}

Animal animal = new Dog();
// animal.secret(); // 呼び出せない
```

C. そもそも呼び出せない

✅ **答え：C. そもそも呼び出せない**

🔵 **解説：**

- privateメソッドは**クラス内部だけのもの**。
- 親クラスと子クラスで**まったく別物のメソッド**になる。
- だから**Animal型変数からprivateメソッドは見えない（コンパイルエラー）**。

---

---

# ✅ 【第二部】static / private / final を混ぜたメソッド設計トレーニング問題

---

## 【問題5】次のコードの出力結果は？

```java
class Parent {
    static void print() { System.out.println("Parent static"); }
    void normal() { System.out.println("Parent normal"); }
}

class Child extends Parent {
    static void print() { System.out.println("Child static"); }
    @Override
    void normal() { System.out.println("Child normal"); }
}

public class Main {
    public static void main(String[] args) {
        Parent p = new Child();
        p.print();
        p.normal();
    }
}
```

B. Parent static → Child normal

✅ **答え：B. Parent static → Child normal**

🔵 **解説：**

- `print()`はstaticメソッド → 静的バインディング
    - 宣言型Parentに依存 → 「Parent static」と出力
- `normal()`はインスタンスメソッド → 動的バインディング
    - 実体型Childに依存 → 「Child normal」と出力

---

## 【問題6】次のコードで正しい説明を選べ

```java
class Parent {
    private void hidden() { System.out.println("Parent hidden"); }
}

class Child extends Parent {
    private void hidden() { System.out.println("Child hidden"); }
}
```

B. 子クラスのhiddenメソッドは完全に独立している

✅ **答え：B. 子クラスのhiddenメソッドは完全に独立している**

🔵 **解説：**

- privateメソッドは「隠蔽」されるだけで、オーバーライドとはみなされない
- Parentのhidden()とChildのhidden()は**無関係な別メソッド**！
- 呼び出し対象を切り替える仕組み（オーバーライド）は動かない

---

---

# 📚 【まとめ：判定の鉄則リスト】

| 判定基準 | 説明 |
| --- | --- |
| **staticメソッド** | 常に静的バインディング（型に応じて決まる） |
| **finalメソッド** | 上書き禁止 → 静的バインディング（動的に差し替えられない） |
| **privateメソッド** | クラス内限定 → 静的バインディング（隠蔽されている） |
| **インスタンスメソッド（通常のvoidとか）** | 動的バインディング（実体型に応じて変わる） |

# Q,

・呼び出し互換性 : クラス型内のメソッドしか呼び出せない
　｜ー 親クラスの呼び出したいメソッドにstatic,private,finalが付与されていたらそのメソッドを呼び出す。
　｜　　　　（静的バインディング）
　｜ー親クラスの呼び出したいメソッドにstatic,private,finalが付与されておらず、その子クラスでも同じメソッドがオーバーライドされている場合
　　　　　（動的バインディング）

・代入互換性 : 変数代入時の型の一致＋下位クラスも代入可

上記の整理で合っていますか？

# ✅ 【あなたの整理をチェック】

---

## ① 呼び出し互換性（Method Invocation Compatibility）

あなたのまとめ：

> クラス型内のメソッドしか呼び出せない
> 
> 
> ・親クラスの呼び出したいメソッドにstatic, private, finalが付与されていたらそのメソッドを呼び出す（静的バインディング）
> 
> ・親クラスの呼び出したいメソッドにstatic, private, finalが付与されておらず、その子クラスでオーバーライドされている場合（動的バインディング）
> 

✅ → **大筋、完全に合っています！**

さらにブラッシュアップすると：

| 項目 | 正確な表現 |
| --- | --- |
| クラス型内のメソッドしか呼び出せない | **宣言型に存在するメソッドだけ呼べる**（変数の宣言型に基づく） |
| static, private, final が付いている | **静的バインディング**（コンパイル時に呼び出し先が確定） |
| それらが付いていない | **動的バインディング**（実行時に実体型で呼び出し先が決定） |

---

## ② 代入互換性（Assignment Compatibility）

あなたのまとめ：

> 変数代入時の型の一致＋下位クラスも代入可
> 

✅ → **これも大筋、正解です！**

さらにブラッシュアップすると：

| 項目 | 正確な表現 |
| --- | --- |
| 変数代入時の型の一致 | **同じ型 or 上位型（スーパークラス型）**なら代入可能 |
| 下位クラスの代入 | **サブクラス型 → スーパークラス型** への代入はOK（is-a関係があるため） |
| スーパークラス型 → サブクラス型 | ❌ 代入不可（キャストが必要） |

---

# 🎯 【まとめ直し（最終版）】

---

## ✅ 呼び出し互換性（Method Invocation Compatibility）

- **変数の宣言型**に存在するメソッドしか呼び出せない。
- 呼び出すメソッドが
    - **static/private/final** → コンパイル時に呼び出し先が**静的バインディング**で確定。
    - **通常のインスタンスメソッド（オーバーライド可能）** → **動的バインディング**で実体型に応じて実行時に決定。

---

## ✅ 代入互換性（Assignment Compatibility）

- *同じ型か、上位型（スーパークラス型）**なら代入可能。
- **サブクラス型 → スーパークラス型**への代入はOK（is-a関係が成立する）。
- **スーパークラス型 → サブクラス型**への代入はキャストが必要、かつ実体型が合っていないとClassCastExceptionが起きる。

---

# ✨ 【超シンプル図まとめ】

```java
【呼び出し互換性】 
→ 宣言型のメソッドのみ呼び出せる（static, private, finalは静的バインディング）

【代入互換性】 
→ 同型またはスーパークラス型には代入OK（サブ型 → スーパー型）
```

---

# 📚 【用語整理】

| 用語 | 説明 | 例 |
| --- | --- | --- |
| **宣言型（Declared Type）** | 変数を宣言したときに指定された型 | `Object obj = new String("abc");` → Object型 |
| **実行時型（Runtime Type）** | 実際にnewされたオブジェクトの型（プログラム実行時に確定） | `String`型 |