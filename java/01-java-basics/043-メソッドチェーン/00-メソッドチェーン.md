# メソッドチェーン

[**自己返却（this）型チェーン**](%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%83%81%E3%82%A7%E3%83%BC%E3%83%B3%2021e62cef73508038b513db62b954e184/%E8%87%AA%E5%B7%B1%E8%BF%94%E5%8D%B4%EF%BC%88this%EF%BC%89%E5%9E%8B%E3%83%81%E3%82%A7%E3%83%BC%E3%83%B3%2023c62cef7350806384e4fcff8eed7160.md)

# Q,

メソッドチェーンができるパターンがいくつかあると思いますが、それをまとめてください。

はい、Hiroakiさんのこれまでのご質問の流れから察するに、**Javaでメソッドチェーンが可能な代表的パターンと、その仕組みの違いを整理したい**ということですね。

---

## ✅ Javaにおけるメソッドチェーンの主なパターン一覧

| パターン名 | 概要 | 戻り値 | 主な使用例 |
| --- | --- | --- | --- |
| ① **自己返却（this）型チェーン** | 自身を返すことで連鎖を可能にする | `this` | Builderパターン, StringBuilder |
| ② **新インスタンス返却チェーン** | 毎回新しいオブジェクトを返す | 新オブジェクト | Stream, Optional, String |
| ③ **インタフェース型チェーン** | 同じインタフェースを返す | 同インタフェース型 | Stream API, JDBC (ResultSet) |
| ④ **関数合成型チェーン** | 関数インタフェースの `andThen` などで関数を連結 | 合成関数 | `Function`, `Consumer` |
| ⑤ **ビルダー引数 Consumer チェーン** | `Consumer<T>` を受け取り、外部から状態をセット | 処理後のオブジェクト | Builder + Consumer |

---

## 🔹 各パターンの例と解説

---

### ① 自己返却型（this チェーン）

```java
public class PersonBuilder {
    private String name;
    public PersonBuilder setName(String name) {
        this.name = name;
        return this; // 自分自身を返す
    }
}
```

**使用例**:

```java
PersonBuilder builder = new PersonBuilder()
    .setName("Hiroaki");
```

---

### ② 新インスタンス返却チェーン（immutable）

```java
String result = " hello "
    .trim()
    .toUpperCase()
    .substring(0, 3);
```

- 各メソッドは「**新しいインスタンスを返す**」。
- 元のオブジェクト（例: `" hello "`）は不変（immutable）で変化しない。

---

### ③ インタフェース型チェーン（Streamなど）

```java
Stream.of("a", "b", "c")
    .map(String::toUpperCase)
    .filter(s -> s.startsWith("A"))
    .forEach(System.out::println);
```

- `Stream<T>` を返す中間操作が連鎖可能にしている。
- 実装クラスは `ReferencePipeline`, `StatelessOp` などが内部で生成されている。

---

### ④ 関数合成チェーン（関数型インタフェース）

```java
Function<String, String> trim = String::trim;
Function<String, String> upper = String::toUpperCase;

Function<String, String> composed = trim.andThen(upper);
String result = composed.apply(" hello ");
```

- `andThen()`, `compose()` により関数を連結。
- 実務ではバリデーションやマッピング処理などに使われる。

---

### ⑤ Consumer引数型（Builder with Consumer）

```java
public class Config {
    private int size;
    public void setSize(int size) { this.size = size; }

    public static Config of(Consumer<Config> consumer) {
        Config config = new Config();
        consumer.accept(config);
        return config;
    }
}

// 使用側
Config config = Config.of(c -> c.setSize(10));
```

- 引数に渡された `Consumer` が `Config` の内部状態を設定。
- メソッドチェーンではないが、**外部からの一括設定**として使用されるパターン。

---

## ✅ 各パターンの使いどころと特徴

| パターン | 不変性 | 主な目的 | 備考 |
| --- | --- | --- | --- |
| 自己返却型 | 可変 | 状態構築 | 設定値保持に最適 |
| 新インスタンス返却型 | 不変 | 値変換 | 副作用なし、安全 |
| インタフェース型 | 不変（内部的に） | パイプライン処理 | Streamなどで使用 |
| 関数合成型 | 不変 | ロジックの合成 | 関数型プログラミング風 |
| Consumer引数型 | 可変 | DSL風構築 | 記述簡素・再利用性向上 |

---

## ✅ 補足：メソッドチェーンができる条件

- **戻り値がチェーン可能な型（自身、同型、サブ型など）**
- **副作用を許容するか（可変 or 不変）**
- **途中で例外や null が出ない（Optional などで補完可能）**

---

## ✅ まとめ図

```java
【自己返却型】
   obj.method1() → this → method2() → this …

【新インスタンス返却型】
   str.trim() → String → toUpperCase() → String …

【インタフェース型】
   stream.map() → Stream → filter() → Stream …

【関数合成型】
   f1.andThen(f2).andThen(f3) → composedFunction

【Consumer 引数型】
   Config.of(config -> config.setX().setY()) → Config
```

---

ご希望あれば、各パターンの「共通インタフェース設計」や「テストの書き方」なども整理できます！

# Q,

メソッドチェーンの表記の一歩手前の表記、共通の変数宣言などは、上記のメソッドチェーンのパターンで一緒ですか？

とても鋭いご質問です。

結論からいうと、**メソッドチェーンの“一歩手前”の表記（＝共通の変数宣言・戻り値の受け方）は、パターンごとにやや異なります**。

以下、それぞれのパターンで「メソッドチェーンに進む前の典型的なコードスタイル・変数扱いの違い」を整理します。

---

## ✅ パターン別：メソッドチェーン前の共通変数の扱い比較

| パターン | 初期変数の型 | 初期化の方法 | チェーン前の状態 | 変数の再利用 | 備考 |
| --- | --- | --- | --- | --- | --- |
| ① 自己返却型 | 具象型 or ビルダ型 | `new`などで生成 | 可変インスタンス | 同一インスタンスに対してチェーン | `this`を返す |
| ② 新インスタンス返却型 | 不変クラス | リテラル or メソッド | 不変インスタンス | 新しい値で変数再代入 | String, LocalDateなど |
| ③ インタフェース型 | Streamなどの抽象型 | `.stream()` 等の呼び出し | ソースを元に作成 | 再利用不可（一方向） | 終端操作後は使えない |
| ④ 関数合成型 | 関数型インタフェース | `Function.of(...)` 等 | 関数オブジェクト | 関数の組み合わせで再定義 | 合成は新オブジェクト |
| ⑤ Consumer引数型 | 具象型 | `.of(Consumer)` など | 構成用のオブジェクト生成 | 最後に確定して返す | 設定だけ外部から渡す |

---

## 🔹 各パターンの具体例で確認

---

### ① 自己返却型（Builderなど）

```java
PersonBuilder builder = new PersonBuilder();
builder.setName("Hiroaki")
       .setAge(30);  // thisを返すことで続く

// builderはずっと同じインスタンス
```

- `builder` 変数は1つで済む
- **可変のインスタンス**であることが前提

---

### ② 新インスタンス返却型（Stringなど）

```java
String str = " hello ";
str = str.trim();
str = str.toUpperCase();

// str変数は同じだが、中身は都度新インスタンス
```

- **変数自体を再代入する**必要がある（不変オブジェクトのため）

---

### ③ インタフェース型チェーン（Stream）

```java
Stream<String> stream = list.stream();  // Stream生成
stream = stream.map(String::toUpperCase);
stream = stream.filter(s -> s.startsWith("A"));

// 最後に終端操作
stream.forEach(System.out::println);
```

- Streamは一方向なので再利用不可
- **中間操作でも変数の再代入は可**（ただし `.forEach()` など終端操作後はエラー）

---

### ④ 関数合成型（Function）

```java
Function<String, String> f1 = String::trim;
Function<String, String> f2 = f1.andThen(String::toUpperCase);
```

- 合成関数の結果を新しい変数に格納
- すべて不変の関数オブジェクトなので、**状態を持たず安全**

---

### ⑤ Consumer型チェーン（Builder + Consumer）

```java
Config config = Config.of(c -> {
    c.setSize(10);
    c.setName("Hiroaki");
});
```

- チェーンというより**DSL（ドメイン固有言語）風**
- `Consumer<T>` により「設定内容を注入する」スタイル
- 外側では `config` という **確定済みのインスタンスが1つ得られる**

---

## ✅ まとめ

| パターン | 変数の再代入 | チェーンで使い回せるか | 可変 or 不変 |
| --- | --- | --- | --- |
| 自己返却型 | 不要（同じインスタンス） | ○ | 可変 |
| 新インスタンス返却型 | 必要（再代入） | ○ | 不変 |
| インタフェース型 | 任意（ただし終端後NG） | △ | 基本不変（内部状態はある） |
| 関数合成型 | 必要（再代入） | ○ | 不変 |
| Consumer型 | 1つだけ生成 | ○（外から渡すだけ） | 可変だが閉じた構築 |

---

ご希望あれば、各パターンを「比較のために同じ目的の処理（例：文字列加工やオブジェクト構築）」で書き比べてみることもできます！

# Q,

returnにしろ戻り値にしろ、そのままのクラス型の場合にしろ、同じクラスの参照からアクセスできる場合は、メソッドチェーンが使用できる認識はあっていますか？

はい、Hiroakiさんの認識は**概ね正しい**です。

もう少し厳密にいうと：

---

## ✅ メソッドチェーンができる条件（本質）

> 「戻り値が同じクラス型（または同じインタフェース型）」である場合、
> 
> 
> **その戻り値に対して“続けてメソッド呼び出しができる”なら、メソッドチェーンが可能**です。
> 

---

## 🔸 条件を分解すると：

| 条件 | 説明 | 例 |
| --- | --- | --- |
| ① **戻り値が「同じ型」または「同じインタフェース型」** | `return this;` または `return new Hoge();` のように、戻り値がそのクラス自身または同系型である | `StringBuilder.append()`, `Stream.map()` |
| ② **その型が持つメソッドを“続けて呼べる”** | 戻り値に対して `.xxx()` とさらに書ける | `obj.methodA().methodB()` |
| ③ **副作用や破壊的操作を許容する設計である** | 可変なら `this`、不変なら新しいオブジェクト | `List`, `String`, `Stream` などそれぞれ設計に応じた扱いがある |

---

## 🔸 メソッドチェーンが成立する例（戻り値 = 同じクラス）

```java
public class MyClass {
    public MyClass methodA() {
        System.out.println("A");
        return this; // ★ 自分自身を返すことで次も呼べる
    }
    public MyClass methodB() {
        System.out.println("B");
        return this;
    }
}
```

使用側：

```java
new MyClass().methodA().methodB();
```

---

## 🔸 メソッドチェーンが成立する例（戻り値 = 同じインタフェース）

```java
Stream<String> stream = Stream.of("a", "b", "c")
    .map(String::toUpperCase)
    .filter(s -> s.startsWith("A"));
```

- `map()` も `filter()` も戻り値は `Stream<T>` → **同じインタフェース型を返している**
- 結果的に `forEach()` までチェーンできる

---

## 🔸 メソッドチェーンできない例

```java
public class Sample {
    public void doSomething() {
        System.out.println("処理のみ");
        // 戻り値なし → チェーン不可
    }
}
```

使用側：

```java
Sample s = new Sample();
s.doSomething().doAnother(); // ❌ コンパイルエラー（voidの後に呼び出し不可）
```

---

## ✅ 補足：戻り値の型と参照の関係

| 戻り値の型 | メソッドチェーンできる？ | 備考 |
| --- | --- | --- |
| 自クラス型 | ✅ できる | 最も典型的なケース |
| 同インタフェース型 | ✅ できる | Stream, Optional など |
| void | ❌ 不可 | チェーン不可（何も返さない） |
| 異なるクラス型 | ⭕ 条件付きで可能 | その型がさらにメソッド持っていれば可 |

---

## ✅ 結論（まとめ）

> ✅ 戻り値が「同じクラス型」か「同じインタフェース型」で、かつその戻り値が次のメソッドを持っていれば、メソッドチェーンは可能。
> 

なので、Hiroakiさんの以下の考え方は**正しい前提に立っています**：

> 「returnにしろ戻り値にしろ、そのままのクラス型の場合にしろ、同じクラスの参照からアクセスできる場合は、メソッドチェーンが使用できる」
> 

---

さらに掘り下げたい場合は、

- `return this` を活用した自己返却型パターン
- `Stream`, `Optional`, `Function` などのチェーン設計の違い
    
    などを具体コードと一緒に比較することもできます！