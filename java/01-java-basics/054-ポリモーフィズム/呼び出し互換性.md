# 呼び出し互換性

# Q,

呼び出し互換性は、原則、変数の宣言型(親クラス型)に存在するメソッドしか呼び出せない。
変数の宣言型に当該メソッドが存在すれば、以下のルールでどのメソッドが呼び出されるかが決定する。

- **static/private/final** → コンパイル時に呼び出し先が**静的バインディング**で確定。
→つまり、宣言型のクラス内のメソッドが呼ばれる。
- **通常のインスタンスメソッド（オーバーライド可能）** → **動的バインディング**で実体型に応じて実行時に決定。
→つまり、実体型のメソッドが呼ばれる。

Hiroakiさん、はい、その認識は**非常に正確で本質を突いています。**

以下に、いただいた内容を少し補強しつつ整理します。

---

## ✅ 呼び出し互換性のルール（まとめ）

### ◾ 基本原則：

> 呼び出し互換性とは、「変数の宣言型（親クラス/インターフェース型）を使って、実体の振る舞いを呼び出すことができる」仕組み。
> 

---

### ◾ 呼び出せるメソッドの範囲：

> 呼び出せるのは「宣言型に定義されているメソッド」のみ。
> 
> 
> → 実体側（子クラス）にしか存在しないメソッドは、**直接は呼べない**。
> 

---

## ✅ 実行時にどのメソッドが呼ばれるか？

| メソッドの種類 | バインディング | 実行されるメソッド | 解説 |
| --- | --- | --- | --- |
| `static` メソッド | **静的バインディング（compile-time）** | **宣言型のクラスのメソッド** | オーバーライド不可・隠蔽（hiding）扱い |
| `private` メソッド | **静的バインディング** | **宣言型のクラスのメソッド** | 継承すらされないため完全に固定 |
| `final` メソッド | **静的バインディング（ただし呼び出しは動的）** | **基本的に親側の実装**（子が上書き不可） | コンパイル時に最適化されやすい |
| 通常の `public/protected` メソッド | **動的バインディング（runtime）** | **実体型のオーバーライドされたメソッド** | Java の多態性（ポリモーフィズム）の本質 |

```java
class Parent {
    void run() { System.out.println("Parent run"); }
    static void staticRun() { System.out.println("Parent staticRun"); }
    private void privateRun() { System.out.println("Parent privateRun"); }
    final void finalRun() { System.out.println("Parent finalRun"); }
}

class Child extends Parent {
    void run() { System.out.println("Child run"); } // オーバーライド
    static void staticRun() { System.out.println("Child staticRun"); } // 隠蔽
    // privateRun は継承すらされていない
    // finalRun はオーバーライド不可
}
```

```java
Parent p = new Child();

p.run();         // ✅ Child run（動的バインディング）
p.staticRun();   // ✅ Parent staticRun（静的バインディング）
p.finalRun();    // ✅ Parent finalRun（オーバーライド不可）
```

> Child 側にある staticRun() は 呼ばれない。p は Parent 型だから。
> 

---

## ✅ ポイント再掲（Hiroakiさんのまとめ＋補足）

| ルール | 正確な説明 |
| --- | --- |
| 変数の宣言型にないメソッドは呼べない | ✅ 正しい。宣言型に存在するものだけアクセス可能 |
| static/private/final → 静的バインディング | ✅ 正しい。コンパイル時に決定（特に static/private） |
| 通常のインスタンスメソッドは動的バインディング | ✅ 正しい。実体型に応じて実行時に解決される |

---

## ✅ 一言まとめ

> 呼び出し互換性 = 宣言型で「何が呼べるか」を決め、実体型で「何が呼ばれるか」を決める仕組み。
> 
> 
> → これが Java のポリモーフィズムの基本であり、**静的バインディングと動的バインディングの違い**が鍵です。
> 

---

さらに深く知りたければ、`invokevirtual`, `invokestatic` などの **JVM命令レベル**や、**バイトコード出力（`javap -c`）分析**も対応可能です！