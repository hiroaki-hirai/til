# デザインパターン

# Q,

ポリモーフィズムを取り入れているデザインパターンはありますか？

はい、Hiroakiさん。

おっしゃる通り、**Strategyパターン**や**Decoratorパターン**は典型的に**ポリモーフィズムを活用するデザインパターン**ですが、それ以外にも多くのGoFデザインパターンが**ポリモーフィズムを中核概念として活用しています。**

---

## ✅ ポリモーフィズムを活用している代表的なデザインパターン

| パターン名 | ポリモーフィズムの活用ポイント |
| --- | --- |
| **Strategy** | 実行時に動作（アルゴリズム）を切り替えられる。インターフェースを通じた実装の差し替え。 |
| **Decorator** | 同じインターフェースを実装しながら、機能を動的に拡張する（ラップ）構造。 |
| **Command** | コマンド（操作）をインターフェースで抽象化し、複数の命令を同じように扱う。 |
| **State** | 状態ごとに異なる振る舞いをクラス化し、切り替え可能にする（is-a状態の変化）。 |
| **Visitor** | 要素ごとに異なる処理をポリモーフィックに定義する。Visitorインターフェースとaccept構造で切り替え可能に。 |
| **Factory Method** | 抽象型を返す工場メソッドにより、具象クラスを隠蔽しつつ切り替え。戻り値のポリモーフィズム。 |
| **Template Method** | 基底クラスに処理の流れを固定し、一部のステップをサブクラスに委ねて動的に変更（オーバーライドによる多態性） |
| **Observer** | 監視対象と通知先が共通インターフェースで結ばれているため、リスナーの多様な実装を同じように扱える。 |

---

## 🔍 補足：ポリモーフィズムが「強く関与する」パターン分類

| 分類 | パターン例 | ポリモーフィズムの役割 |
| --- | --- | --- |
| **振る舞いに関与** | Strategy, State, Command, Visitor, Template Method | 処理の切り替えや動的分岐にポリモーフィズムを活用 |
| **構造に関与** | Decorator, Composite, Bridge | インターフェース共通化による柔軟な構造設計 |
| **生成に関与** | Factory Method, Abstract Factory | 戻り値の型としてポリモーフィズムを利用し、生成物の切り替えを可能に |

---

## ✅ 一言まとめ

> GoFの多くのパターン（特に振る舞い・構造系）は、ポリモーフィズムを前提とすることで、**「実装の差し替え」「処理のカスタマイズ」「柔軟な構造の構築」**を可能にしています。
> 

---

## ✅ Hiroakiさんの学習観点への補足

- *「共通インターフェース × 動的バインディング」**が使われているパターンは、ほぼ確実にポリモーフィズムを使っています。
- Strategy / Decorator を理解できていれば、他のパターン（Command や State など）も**共通構造が見えてくる**はずです。

---

ご希望があれば、これらのパターンごとに **共通構造図＋コードスニペット付きまとめ** を作ることもできます！

# Q,

これらのパターンごとに 共通構造図＋コードスニペット付きまとめ をお願いします

了解しました、Hiroakiさん。

以下に、**ポリモーフィズムを中核に活用している代表的なGoFデザインパターン**を、

それぞれ「共通構造図＋簡潔なコードスニペット」とともに整理してご紹介します。

---

## ✅ 1. Strategy パターン

### ◾ 共通構造図

```java
[Strategy] <─┐
             │
[ConcreteStrategyA] [ConcreteStrategyB]
             ↑
         [Context]
```

### ◾ コードスニペット

```java
interface Strategy {
    void execute();
}

class StrategyA implements Strategy {
    public void execute() { System.out.println("Strategy A"); }
}

class StrategyB implements Strategy {
    public void execute() { System.out.println("Strategy B"); }
}

class Context {
    private Strategy strategy;
    public Context(Strategy strategy) { this.strategy = strategy; }
    public void run() { strategy.execute(); }
}
```

---

## ✅ 2. Decorator パターン

### ◾ 共通構造図

```java
[Component] <─┐
             │
    [ConcreteComponent]
             │
     [Decorator]（has-a Component）
             │
  [ConcreteDecoratorA / B]
```

### ◾ コードスニペット

```java
interface Component {
    void operation();
}

class ConcreteComponent implements Component {
    public void operation() { System.out.println("Base"); }
}

abstract class Decorator implements Component {
    protected Component inner;
    public Decorator(Component inner) { this.inner = inner; }
}

class DecoratorA extends Decorator {
    public DecoratorA(Component inner) { super(inner); }
    public void operation() {
        inner.operation();
        System.out.println(" + Decorator A");
    }
}
```

---

## ✅ 3. Command パターン

### ◾ 共通構造図

```java
[Command] <─┐
            │
[ConcreteCommandA/B]
            ↑
          [Invoker]
            ↓
         [Receiver]
```

### ◾ コードスニペット

```java
interface Command {
    void execute();
}

class Light {
    void on() { System.out.println("Light ON"); }
}

class LightOnCommand implements Command {
    private Light light;
    public LightOnCommand(Light light) { this.light = light; }
    public void execute() { light.on(); }
}

class Invoker {
    private Command cmd;
    public Invoker(Command cmd) { this.cmd = cmd; }
    public void press() { cmd.execute(); }
}
```

---

## ✅ 4. State パターン

### ◾ 共通構造図

```java
[State] <─┐
          │
[ConcreteStateA/B]
          ↑
       [Context]（has-a State）
```

### ◾ コードスニペット

```java
interface State {
    void handle();
}

class StateA implements State {
    public void handle() { System.out.println("State A"); }
}

class Context {
    private State state;
    public void setState(State state) { this.state = state; }
    public void request() { state.handle(); }
}
```

---

## ✅ 5. Visitor パターン

### ◾ 共通構造図

```java
[Visitor] <──┐         [Element] <──┐
             │                     │
[ConcreteVisitor]     [ConcreteElement]
             ↑                     ↑
       element.accept(visitor) → visitor.visit(this)
```

### ◾ コードスニペット

```java
interface Visitor {
    void visit(ConcreteElement e);
}

interface Element {
    void accept(Visitor v);
}

class ConcreteElement implements Element {
    public void accept(Visitor v) { v.visit(this); }
}

class ConcreteVisitor implements Visitor {
    public void visit(ConcreteElement e) {
        System.out.println("Visited Element");
    }
}
```

---

## ✅ 6. Factory Method パターン

### ◾ 共通構造図

```java
[Product] <──┐
             │
    [ConcreteProductA/B]
             ↑
      [Creator]（abstract）
             ↑
 [ConcreteCreatorA/B]
```

### ◾ コードスニペット

```java
interface Product {
    void use();
}

class ConcreteProduct implements Product {
    public void use() { System.out.println("Using Product"); }
}

abstract class Creator {
    abstract Product create();
}

class ConcreteCreator extends Creator {
    public Product create() { return new ConcreteProduct(); }
}
```

---

## ✅ 7. Template Method パターン

### ◾ 共通構造図

```java
[AbstractClass]
     ↑
[ConcreteClass]
```

### ◾ コードスニペット

```java
abstract class AbstractClass {
    final void template() {
        step1();
        step2();
    }

    abstract void step1();
    abstract void step2();
}

class ConcreteClass extends AbstractClass {
    void step1() { System.out.println("Step 1"); }
    void step2() { System.out.println("Step 2"); }
}
```

---

## ✅ 総まとめ

| パターン名 | ポリモーフィズムの使い方例 |
| --- | --- |
| Strategy | 動的にアルゴリズムを切り替え（インターフェース） |
| Decorator | 動的に機能拡張しながら同じインターフェースで利用 |
| Command | 処理（命令）を抽象化し、統一インターフェースで実行 |
| State | 状態ごとに異なる振る舞いをクラスで表現 |
| Visitor | 要素ごとに異なる操作を、Visitor側のポリモーフィズムで実現 |
| Factory Method | 戻り値の型にポリモーフィズムを活用（実装の隠蔽） |
| Template Method | 手続きの骨組みを抽象クラスで固定し、処理をオーバーライドで切り替え |

---

ご希望があれば、これらを **演習形式（パターン適用設計 → 実装）** に落とし込んだ学習プランもご提案できます！