# 検査例外

# Q,

検査例外の場合に必要な措置をまとめてください。

はい 👍

Java における **検査例外（Checked Exception）** は、コンパイル時に「この例外に備えること」を強制される例外です。

→ したがって、**必ず何らかの措置を取らないとコンパイルエラー**になります。

---

# 🔹 検査例外に必要な措置

| 措置 | 記述例 | 説明 |
| --- | --- | --- |
| **try-catchで処理する** | `java\ntry {\n    FileReader fr = new FileReader(\"test.txt\");\n} catch (IOException e) {\n    e.printStackTrace();\n}\n` | その場で捕捉して処理（ログ、リカバリ、再スローなど） |
| **throwsで宣言する** | `java\npublic void readFile() throws IOException {\n    FileReader fr = new FileReader(\"test.txt\");\n}\n` | メソッドの呼び出し元に処理を委ねる。呼び出し側も対応必須。 |
| **catchして別の例外へラップしてスロー** | `java\ntry {\n    FileReader fr = new FileReader(\"test.txt\");\n} catch (IOException e) {\n    throw new RuntimeException(e); // 非検査例外へ変換\n}\n` | 呼び出し元に検査例外を強制したくない場合に行うパターン（ラップ例外） |
| **try-with-resourcesを利用** | `java\ntry (FileReader fr = new FileReader(\"test.txt\")) {\n    // 自動でclose\n} catch (IOException e) {\n    e.printStackTrace();\n}\n` | リソース管理と例外処理を一体化できる。 |

---

# 🔹 検査例外の特徴

- `Exception` のサブクラスのうち **`RuntimeException` を継承しない例外**が対象。
    
    例：`IOException`, `SQLException`, `ParseException` など。
    
- メソッドが検査例外をスローする可能性があるとき、**呼び出し側で必ず対応（try-catch or throws）**が必要。
- `throws` で宣言すれば呼び出し元に伝搬していく。
- 最終的に `main` メソッドまで伝搬させると、実行時に未処理例外としてスローされプログラムが終了する。

---

# 🔹 実務的な注意点

- **業務ロジックに回復可能性がある場合 → try-catchで処理**
- **インフラ層（I/OやDB操作など）→ throwsで上位層に委譲**
- **呼び出し元に強制したくない場合 → RuntimeException にラップ**（ただし乱用は設計を悪化させるので注意）

---

✅ まとめ

検査例外は、**「必ず備えよ」**というコンパイラからの強制。

→ **try-catch** で処理するか、**throws** で呼び出し元へ委譲するか、どちらかの措置が必須です。

---

Hiroakiさん、これを「検査例外 vs 非検査例外」で「必要な措置の違い」を比較表にまとめた方が試験対策的に役立ちそうですが、作成しますか？

# Q,

throws と try-catch と２つで処理しているものを見かけますが、どちらか１つで対応すればよいのでしょうか？

とても良いところに着目されています 👍

結論から言うと：

- *原則は「どちらか1つでOK」**です。
- ただし実務では **「try-catch で部分的に処理して、残りは throws で呼び出し元へ委譲」** という **併用パターン**もよく使われます。

---

## 🔹 どちらか1つで対応できる例

### ① try-catch で完結させる

```java
public void readFile() {
    try {
        FileReader fr = new FileReader("test.txt");
    } catch (IOException e) {
        System.out.println("ファイルがありません");
    }
}
```

👉 例外をその場で処理してしまうので、`throws` は不要。

---

### ② throws で完全に呼び出し元に委譲する

```java
public void readFile() throws IOException {
    FileReader fr = new FileReader("test.txt");
}
```

👉 呼び出し元が try-catch を書く必要がある。

---

## 🔹 両方を使うケース（併用）

1. **部分的に処理して、再スローする**
    - ログを残したり、別の型の例外にラップして投げ直すケース。

```java
public void readFile() throws CustomAppException {
    try {
        FileReader fr = new FileReader("test.txt");
    } catch (IOException e) {
        // ログ出力
        System.err.println("I/Oエラー: " + e.getMessage());
        // 呼び出し元に別の例外を投げ直す
        throw new CustomAppException("ファイル読み込み失敗", e);
    }
}
```

1. **複数の検査例外を整理して throws する**
- 例外をまとめて、呼び出し元にとって分かりやすい例外に変換して渡す。

```java
public void connectDB() throws DataAccessException {
    try {
        // JDBC 操作
    } catch (SQLException e) {
        throw new DataAccessException("DBエラー", e);
    }
}
```

---

## 🔹 まとめ

- **どちらか1つで十分**（完結させるなら try-catch、上位に任せるなら throws）。
- ただし **実務では併用が多い**：
    - その場でログや変換を行い
    - 最終的には呼び出し元に `throws` で渡す。

---

✅ 試験対策的には：

- *「必ずどちらかで対応しなければならない」**が基本。
- **「try-catch で処理した上で throw し直す」パターンもある**ことを理解しておくと安心です。

---

Hiroakiさん、これを「throws／try-catch／併用」の **設計指針フローチャート（図解）** にして整理しましょうか？

# Q,

throws で呼び出し元へ委譲するとありますが、これは検査例外の場合は、呼び出し元でtry-catch文などでthrowsで指定した例外クラスの場合の処理を記載する必要があるということでしょうか？

はい、その理解で正しいです 👍

ただし整理するともっとスッキリ見えます。

---

## 🔹 `throws` で呼び出し元に委譲するとは？

- **検査例外 (Checked Exception)** の場合：
    - メソッドが `throws` で宣言すると、呼び出し元は必ず **「何らかの対応（try-catch するか、さらに throws で上に投げる）」** をしないとコンパイルエラーになります。

```java
// 検査例外をスローするメソッド
public void readFile() throws IOException {
    FileReader fr = new FileReader("test.txt");
}
```

このメソッドを呼び出す側は、次のいずれかが必須です：

### ① try-catch で処理

```java
try {
    readFile();
} catch (IOException e) {
    System.out.println("ファイルがありません");
}
```

### ② さらに throws で委譲

```java
public void execute() throws IOException {
    readFile();  // 呼び出し元へ転送
}
```

👉 このように **検査例外は「対応必須」** です。

---

## 🔹 非検査例外 (Unchecked Exception) の場合

- `RuntimeException` のサブクラス（例: `NullPointerException`, `IllegalArgumentException`）。
- `throws` 宣言してもしなくても自由。呼び出し元も try-catch で捕まえる義務はない。

```java
public void calc(int x) throws ArithmeticException {
    int y = 10 / x; // x=0ならArithmeticException
}
```

呼び出し元で何も書かなくてもコンパイルは通ります。

---

## 🔹 まとめ表

| 例外の種類 | `throws` 宣言 | 呼び出し元の対応 |
| --- | --- | --- |
| **検査例外** (`IOException`, `SQLException` など) | 必須（宣言しないとコンパイルエラー） | 呼び出し元も **try-catch** するか、さらに **throws** で委譲 |
| **非検査例外** (`RuntimeException` 系) | 任意 | 呼び出し元に対応義務なし（try-catchは任意） |

---

✅ 結論

Hiroakiさんの言うとおり、

**「検査例外を throws で委譲した場合は、呼び出し元で必ず try-catch か再throws する必要がある」**

という認識で正しいです。

---

Hiroakiさん、これを「検査例外が main まで届いた場合にどうなるか（最終的に未処理例外としてアプリが終了）」という実行フロー図にまとめましょうか？