# 整合性と衝突時のバグ例

`equals` / `hashCode` / `compareTo` の**整合性**は、Javaでのデータ構造操作（Set、Map、TreeSet など）やコレクションの動作にとって**極めて重要**です。

ここでは、**整合性ルール → 崩れたときのバグ例 → なぜ起こるか** を段階的に解説します。

---

## ✅ 1. 各メソッドの目的と使われ方

| メソッド | 使われる場面 | 目的 |
| --- | --- | --- |
| `equals()` | Set、Map、List の重複チェック | 「同一の意味を持つか？」を判断（等価性） |
| `hashCode()` | HashSet、HashMap のバケット分配 | `equals()` が true なら同じ hashCode に |
| `compareTo()` | TreeSet、TreeMap、Collections.sort | 「順序関係」の判定（順序性） |

---

## ✅ 2. 基本ルール：整合性の原則

### ☑️ 原則1：equals と hashCode は **整合** すべし

```java
if (a.equals(b)) then a.hashCode() == b.hashCode()
```

→ これを破ると `HashSet` で同一要素が重複登録されるなどの**重大バグ**になります。

---

### ☑️ 原則2：equals と compareTo は **一貫性を持つべき**

```java
if (a.compareTo(b) == 0) then a.equals(b) == true
```

→ これを破ると `TreeSet` や `TreeMap` で「見た目には同じデータ」が**重複して格納される**ようなバグが起きます。

---

## ❗ 整合性が崩れたときのバグ例

---

### 🔻 例1：equals は true なのに compareTo は 0 でない

```java
class Person implements Comparable<Person> {
    String name;
    int age;

    Person(String name, int age) { this.name = name; this.age = age; }

    @Override
    public boolean equals(Object o) {
        if (o instanceof Person p) {
            return this.name.equals(p.name); // ← nameだけで等価判定
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }

    @Override
    public int compareTo(Person o) {
        return Integer.compare(this.age, o.age); // ← ageで比較
    }
}
```

### ❌ 問題点

- `equals()` → 同じ名前なら同一と判定
- `compareTo()` → 年齢で順序を判定

```java
TreeSet<Person> set = new TreeSet<>();
set.add(new Person("Alice", 20));
set.add(new Person("Alice", 25));
System.out.println(set.size()); // 2 ← 名前は同じなのに重複が許される
```

### 🔴 結果：

`TreeSet` は `compareTo` を使って重複判断 → 20 ≠ 25 → **両方入る**

---

### 🔻 例2：compareTo == 0 なのに equals が false

```java
class IdOnly implements Comparable<IdOnly> {
    int id;

    IdOnly(int id) { this.id = id; }

    public int compareTo(IdOnly o) {
        return Integer.compare(this.id, o.id); // 比較は ID
    }

    public boolean equals(Object o) {
        return false; // 常に false ← 整合性なし
    }
}
```

### ❌ 結果：

```java
TreeSet<IdOnly> set = new TreeSet<>();
set.add(new IdOnly(1));
set.add(new IdOnly(1));
System.out.println(set.size()); // 1 → TreeSetでは片方しか残らない
System.out.println(set.contains(new IdOnly(1))); // false ← equals が false だから見つけられない
```

→ **contains() が期待通り動作しないバグ**に繋がります。

---

## ✅ 正しい整合の定義例

```java
class User implements Comparable<User> {
    String name;

    public boolean equals(Object o) {
        if (o instanceof User u) {
            return this.name.equals(u.name);
        }
        return false;
    }

    public int hashCode() {
        return Objects.hash(name);
    }

    public int compareTo(User o) {
        return this.name.compareTo(o.name); // 等価条件と同じ項目で比較
    }
}
```

---

## ✅ まとめ

| 整合性の組み合わせ | 必須度 | 破ると起こること |
| --- | --- | --- |
| equals と hashCode | 必須 | HashSet で重複管理が壊れる |
| compareTo と equals | 推奨 | TreeSet で「等しいはずの値」が重複する |
| compareTo の一貫性 | 必須 | Collections.sort で順序が壊れる可能性あり |

---

## ご希望に応じて：

- `compareTo` の「反対称性」「推移性」違反の例
- `SortedMap` や `SortedSet` 実装における equals と compareTo の実務的判断

なども整理できます。