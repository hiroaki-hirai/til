# 範囲指定 まとめ

# ✅ 「length()」 vs 「length()-1」 使い分け完全まとめ

| シチュエーション | 正しく使うべきもの | 理由・補足 |
| --- | --- | --- |
| 配列や文字列の「要素数」「総文字数」を取得したいとき | `length()` | 要素や文字数そのものを返す（インデックスではない） |
| 文字列の末尾の「最後のインデックス」を指定したいとき | `length() - 1` | インデックスは0始まりなので、最大値は length()-1 |
| for文で文字列をループ処理したいとき（全要素） | `i < length()` | 0～length()-1までループする（未満条件） |
| charAt()などで1文字を取り出したいとき | 末尾なら `length()-1` | インデックスを渡すので、最大は length()-1 |
| substring(begin, end) で範囲指定したいとき | endは `length()` | substringは [begin, end)（endは含まない）だから |
| 配列の範囲外チェックをしたいとき | インデックス < `length()` | 配列もStringも最大インデックスは length()-1 |

---

# 🔵 図解：イメージで押さえる

```java
String s = "Hello"; // length() = 5
```

| インデックス（charAt用） | 0 | 1 | 2 | 3 | 4 |
| --- | --- | --- | --- | --- | --- |
| 文字 | H | e | l | l | o |

✅ 最後のインデックスは **4 = length()-1**

---

# 🔴 よくある混同ポイント（ミスしやすい）

| 典型的な間違い | 正しくは… |
| --- | --- |
| `charAt(length())` を書く → 実行時例外 | `charAt(length() - 1)` が正しい |
| for文の終了条件を `i <= length()` にする | `i < length()` が正しい |
| substring(0, length()-1) として最後を含めたい | substring(0, length()) が正しい（endは含まない） |

---

# ✍️ まとめイメージ

| 項目 | length() | length()-1 |
| --- | --- | --- |
| 数や量を知りたいとき | ✅ |  |
| インデックスを指定したいとき |  | ✅ |

---

✅ こう覚えると一発で整理できます！

👉 **「長さを知りたいなら length()」**

👉 **「インデックスを指定したいなら length()-1」**

以下に、**substring() / codePointCount() / Arrays.copyOfRange() / System.arraycopy()** など、

Java標準APIで使われる**範囲指定（begin, end）共通ルールまとめ表**をわかりやすく整理しました！

---

# ✅ Javaの範囲指定 共通ルールまとめ表

| メソッド/操作 | beginIndex（開始位置） | endIndex（終了位置） | endIndexは含む？ | 備考 |
| --- | --- | --- | --- | --- |
| `String.substring(begin, end)` | 含む | 含まない | ❌ | `[begin, end)` の範囲で部分文字列を作成 |
| `String.codePointCount(begin, end)` | 含む | 含まない | ❌ | `[begin, end)` の範囲でコードポイント数をカウント |
| `Arrays.copyOfRange(array, from, to)` | 含む | 含まない | ❌ | `[from, to)` の範囲で新しい配列を作成 |
| `System.arraycopy(src, srcPos, dest, destPos, length)` | srcPos含む | srcPos+length-1含む | ✅（長さ指定型） | 位置指定ではなく「長さ」でコピー |
| `List.subList(fromIndex, toIndex)` | 含む | 含まない | ❌ | `[fromIndex, toIndex)` の範囲で部分リストを作成 |

---

# 🔵 補足ポイント（重要まとめ）

| 共通ルール | 内容 |
| --- | --- |
| Java標準の範囲指定メソッドの基本 | ほぼすべて `[begin, end)` （endは含まない） |
| System.arraycopyのみ特殊 | 「長さ指定型」＝`length`個をコピーする形式 |
| beginは常に含まれる | ✅ |
| endは通常含まれない（copyOfRange, substring等） | ✅ |

---

# 🔥 図解イメージ

たとえば `"ABCDE"` という文字列の場合：

| インデックス | 0 | 1 | 2 | 3 | 4 |
| --- | --- | --- | --- | --- | --- |
| 文字 | A | B | C | D | E |

範囲 `[1, 4)` を指定すると → `"BCD"`

- 開始：インデックス1（B）から
- 終了：インデックス4（E）は**含まない**

---

# ✅ まとめ：範囲指定時の鉄則

| 判断ポイント | ルール |
| --- | --- |
| 開始位置（beginIndex）は？ | **含む** |
| 終了位置（endIndex）は？ | **含まない** |
| System.arraycopyだけ特別？ | **length個数コピーする指定方式** |

---

# 🔵 超シンプルに覚えるなら…

👉 **範囲指定はだいたい `[開始, 終了)` 方式！**

👉 **終了位置は「触らない」つもりで考える！**

👉 **System.arraycopyは長さで考える！**

---

範囲指定のパターンは３つある。
１つは、charAtメソッドや配列のようにindexを使用してデータを取得する場合。
２つ目は、for文の継続条件式でindexを指定する場合。
３つ目は、メソッドのendIndexとして範囲を指定する場合(endIndexは含まない)。
上記はどれもIndexの指定に係ることで共通。
文字数をカウントする場合とは目的が異なる。

# ✅ 整理：範囲指定パターンは大きく３つある

| パターン | 内容 | ポイント |
| --- | --- | --- |
| ① データ取得系（charAt, 配列アクセス） | **indexでピンポイント指定して要素を取得する** | `index` は直接「場所」を表す（0始まり） |
| ② for文の継続条件系 | **indexを使ってループさせる** | `i < length()` のように「範囲内か？」を継続判定する |
| ③ メソッドの範囲指定（endIndexあり） | **範囲 `[begin, end)` を指定し、部分対象を操作する** | `endIndex` は**含まない**。ここが最大の注意点！ |

---

# 🔵 さらに整理すると

| 比較項目 | インデックス操作 | カウント操作 |
| --- | --- | --- |
| 何を扱うか | **場所（位置）** | **個数（量）** |
| 代表例 | `charAt(i)`, `array[i]`, `substring(0, 3)` | `length()`, `codePointCount()` |
| 開始番号 | 0から | 1から数えるイメージ（人間感覚） |
| 注意点 | endIndexは含まない（[begin, end)) | 特に範囲外やサロゲートペア注意 |

---

# ✅ インデックス操作 vs カウント操作 比較まとめ表（図解版）

| 比較項目 | インデックス操作 | カウント操作 |
| --- | --- | --- |
| 主な目的 | **場所（位置）を指定/参照**する | **個数（量）を取得/カウント**する |
| 主な登場場面 | `charAt(i)`, `substring(0, end)`, 配列アクセス `arr[i]` | `length()`, `codePointCount()` |
| スタート地点 | **0始まり** | **1個目からカウント**する意識 |
| 範囲指定（begin-end）時の扱い | `[begin, end)`（endは**含まない**） | 範囲全体の個数で考える |
| エラーになりやすいポイント | `endIndexを含めてしまう`、`index超え` | サロゲートペアや範囲外カウント注意 |
| 例外の種類 | `StringIndexOutOfBoundsException`など | 例外よりも数え違いに注意 |
| イメージ | **場所を指差す感じ** | **ものを数える感じ** |