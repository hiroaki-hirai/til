# フィールド or ローカル変数

# Q,

```java
public class Sample {
    int num = 23; 

    public void Sample02 () {   
        int num = num; 
        System.out.println(num); 
    } 
}
```

上記のコードにて、メソッド内の int num の変数の宣言で、シャドーイングにより右辺のnumも左辺のローカル変数と扱うという認識はあっていますか？

はい、その認識は正しいです 👍

---

## コードをもう一度確認

```java
public class Sample {
    int num = 23; 

    public void Sample02 () {   
        int num = num; 
        System.out.println(num); 
    } 
}
```

---

## 名前解決のルール

- Java では **名前解決はスコープが最優先** されます。
- メソッド内で `int num = ...;` と書いた時点で、そのスコープ内の **`num` はローカル変数** として宣言されます。
- 右辺の `num` も同じスコープで名前解決されるため、**フィールドの `num` ではなく、未初期化のローカル変数 `num`** を参照しようとします。

---

## コンパイラの判定

- ローカル変数は **自動初期化されない**。
- `int num = num;` の右辺で「未初期化のローカル変数 `num`」を参照したことになる。
- そのため **コンパイルエラー** になります。

エラーメッセージ例：

```java
variable num might not have been initialized
```

---

## 正しくフィールドを参照するには

ローカル変数を宣言してもフィールドを使いたい場合は、`this.num` を明示する必要があります。

```java
public void Sample02 () {   
    int num = this.num; // フィールド num を参照
    System.out.println(num); // 23
}
```

---

## まとめ

- `int num = num;` の右辺の `num` も **ローカル変数扱い**（シャドーイング）
- しかしローカルは未初期化なので「未初期化の変数参照」としてコンパイルエラー
- フィールドを参照したいなら `this.num` を明示

---

👉 Hiroakiさん、ここで一歩進めて質問ですが、

この「シャドーイング」に関して、**「ローカル vs フィールド」だけで整理**しますか？

それとも **「ローカル vs フィールド vs 親クラスのフィールド」** まで広げて「隠蔽の階層」を表にまとめますか？

# Q,

この「シャドーイング」に関して、「ローカル vs フィールド」だけで整理してください。

了解しました 👍

では「ローカル変数 vs フィールド（インスタンス変数）」に絞って **シャドーイング** の整理をします。

---

# 📌 ローカル変数 vs フィールドのシャドーイング整理

| 項目 | フィールド | ローカル変数 |
| --- | --- | --- |
| 宣言位置 | クラス本体 | メソッドやブロック内 |
| 初期化 | 自動初期化される（int=0, boolean=false, 参照型=null） | 自動初期化なし → **必ず明示的に初期化が必要** |
| 名前解決優先度 | **低い**（ローカルが優先される） | **高い**（同名があればローカルが選ばれる） |
| 暗黙の this | インスタンスメソッド内では `this.field` として解決される | `this` とは無関係。スコープ内の変数そのもの |
| シャドーイング時の挙動 | ローカル変数に隠される（参照されない） | 同名のフィールドを隠してしまう |
| フィールドを参照する方法 | `this.field` を明示する必要あり | ― |

---

# 📌 コード例

## ① ローカルが無い場合（フィールドが使われる）

```java
class Sample {
    int num = 23;

    void m() {
        System.out.println(num);   // this.num と同じ → 23
    }
}
```

## **② ローカルが同名で宣言されている場合（シャドーイング）**

```java
class Sample {
    int num = 23;

    void m() {
        int num = 5;              // ローカルが宣言される
        System.out.println(num);   // ローカルが優先 → 5
        System.out.println(this.num); // フィールドを明示 → 23
    }
}
```

## ③ ローカルを未初期化のまま参照しようとした場合

```java
class Sample {
    int num = 23;

    void m() {
        int num;                 // ローカル宣言（初期化なし）
        System.out.println(num); // ✖ コンパイルエラー（might not have been initialized）
    }
}
```

---

# 📌 まとめ

- **ローカル変数 > フィールド** の優先度で名前解決される
- フィールドを使いたいときは `this.field` を明示する
- フィールドは自動初期化されるが、ローカルはされない → 未初期化参照はコンパイルエラー

---

👉 Hiroakiさん、このあとさらに進めて

「**シャドーイングを避ける実務的な書き方（命名規則やthis活用）**」まで整理しますか？