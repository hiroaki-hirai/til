# シャドーイング

# Q,

```java
    int num;
    private void test() {
        num++;
        System.out.println(num);
    }
```

num++; は、データ型の記載がないので、前で宣言されているフィールドと言う認識です。
では、System.out.println(num); のnumも同じようなルールによってローカル変数かフィールドかが決まるのでしょうか？

はい、Hiroakiさんの認識は **完全に正しい** です。

`num++` と `System.out.println(num);` の `num` は、**どちらもクラスのフィールド（インスタンス変数）**を指しています。

---

### 🔍 なぜそうなるのか（ルールの確認）

Javaでは、**ローカル変数が定義されていない限り、同名のフィールドが参照されます。**

```java
int num; // ← フィールド

private void test() {
    num++;                  // フィールド num をインクリメント
    System.out.println(num); // フィールド num を出力
}
```

このように、`test()` メソッド内で `num` という **ローカル変数を宣言していない** ため、`num` はフィールドとして解決されます。

---

### ✅ ローカル変数がある場合はどうなるか

```java
int num = 100; // フィールド

private void test() {
    int num = 5; // ← ローカル変数（フィールドと同名）
    num++;                  // ローカル変数 num を操作（5 → 6）
    System.out.println(num); // ローカル num を出力 → 6
}
```

この場合は、**ローカル変数が優先されて参照**されるため、フィールドの num は無視されます。

どうしてもフィールドにアクセスしたい場合は this.num を使います：

```java
System.out.println(this.num); // フィールドの num を出力
```

---

### 🔁 優先順位のまとめ

| 参照される名前 | 解決される先 | 備考 |
| --- | --- | --- |
| `num`（ローカルに存在） | ローカル変数 | メソッド内にあれば優先される |
| `num`（ローカルにない） | フィールド | インスタンス変数として解決 |
| `this.num` | フィールド | ローカル変数と区別したいときに明示 |

---

何か似たケースや実験してみたいパターンがあれば、ぜひ教えてくださいね！

# Q,

上記の解説は、メソッド内にローカル変数の記載がある場合ですが、引数として (データ型 変数) とあればそれもローカル変数と同等の影響がある認識は合っっていますか？

はい、Hiroakiさんの認識は **完全に正しい** です。

**メソッドの引数**も、**ローカル変数と同じ扱い**になります。

つまり、**同名のフィールドよりも優先して参照されます**。

---

### 🔍 例で確認

```java
public class Main {
    int num = 100; // フィールド

    private void test(int num) { // ← 引数 num はローカル変数と同じ扱い
        num++; // 引数の num（100 ではなく引数値）をインクリメント
        System.out.println(num); // 引数 num の値を出力
    }

    public static void main(String[] args) {
        new Main().test(5); // 出力は 6
    }
}
```

出力：

```java
6
```

---

### ✅ フィールドの `num` にアクセスしたい場合

引数と同名のフィールドにアクセスしたいときは `this.num` を使います：

```java
private void test(int num) {
    System.out.println(this.num); // フィールド num（100）
    System.out.println(num);      // 引数 num（引数値）
}
```

---

### 🔁 まとめ

| 名前の種類 | スコープ | 優先度 | アクセス方法 |
| --- | --- | --- | --- |
| 引数（例: `int num`） | メソッドの内部だけ有効 | 高い（フィールドより優先） | `num` |
| ローカル変数（例: `int num = 5;`） | 宣言されたブロック内 | 高い（フィールドより優先） | `num` |
| フィールド（例: `int num = 100;`） | クラス全体 | 引数・ローカル変数と名前がかぶると隠れる | `this.num` |

---

もし、引数とフィールドをあえて同じ名前にする設計を見かけたら、それには意図（主に this を使うため）があることが多いです。

何か実際のコードや例で気になる点があれば、ぜひ見せてください！

# Q,

ローカル変数が優先されるのはシャドーイングというものだったと記憶していますが、合っていますか？

はい、Hiroakiさんの記憶は **正確です**！

ローカル変数（あるいは引数）が**同名のフィールドや変数を隠してしまう現象**は、Javaではまさに **「シャドーイング（shadowing）」** と呼ばれます。

---

### 🔍 シャドーイングとは？

> シャドーイング（shadowing）
> 
> 
> 上位スコープにある変数やフィールドと同じ名前の変数を、下位スコープで定義することで、上位の変数を**一時的に見えなくする（隠す）**こと。
> 

---

### ✅ 例：フィールドを引数でシャドーイング

```java
public class Main {
    int num = 100; // フィールド

    void test(int num) { // ← この num がフィールドをシャドーイングしている
        System.out.println(num);     // 引数の num → 出力: 5
        System.out.println(this.num); // フィールドの num → 出力: 100
    }

    public static void main(String[] args) {
        new Main().test(5);
    }
}
```

---

### ✅ 例：ローカル変数によるシャドーイング

```java
public class Main {
    int num = 100;

    void test() {
        int num = 3; // フィールドをシャドーイング
        System.out.println(num);     // 出力: 3（ローカル変数）
        System.out.println(this.num); // 出力: 100（フィールド）
    }
}
```

---

### 💡 よくある実用パターン（フィールドに値をセット）

```java
public class User {
    private String name;

    public void setName(String name) {
        this.name = name; // this.name ← フィールド, name ← 引数（シャドーイング）
    }
}
```

こういったコードもシャドーイングの一種です。

この場合、明示的に `this.name` を書くことで、**フィールドへの代入**が明確になります。

---

### 📌 補足：シャドーイング vs 隠蔽（hiding）

- **シャドーイング**：ローカル変数や引数がフィールドを隠す（インスタンス単位）
- **隠蔽（hiding）**：サブクラスのフィールドがスーパークラスの同名フィールドを隠す（継承関係）

たとえばこういうのが「隠蔽」です：

```java
class Super {
    int value = 10;
}

class Sub extends Super {
    int value = 20; // スーパークラスの value を隠している（hiding）
}
```

---

何か紛らわしいケースや、より深く理解したい点があれば気軽に聞いてください！

# Q,

ジャドーイングのパターンは、メソッド内にローカル変数がある場合、メソッドに仮引数が設定されている場合、前の2つが無い場合(フィールド) の3パターンで全てでしょうか？

とても良い質問です！

Hiroakiさんの整理は **本質を突いていて、実用上はほぼ完璧**です。

結論から言うと：

---

### ✅ シャドーイングが起こる「3つの変数スコープ」：

1. **フィールド（インスタンス変数／クラス変数）**
2. **仮引数（メソッド・コンストラクタの引数）**
3. **ローカル変数（メソッドやブロック内で定義された変数）**

この3つのうち、**同名の変数が下位スコープで定義されたときに上位スコープの変数が「シャドーイングされる（隠される）」**というルールが基本です。

---

### 💡 つまり、シャドーイングのパターンは実質以下の3つに分類できます：

| パターン | 例 | シャドーイングされる対象 |
| --- | --- | --- |
| フィールド ← 仮引数 | `void setName(String name)` | フィールドの `name` |
| フィールド ← ローカル変数 | `int num = 100; int num = 5;` | フィールドの `num` |
| 仮引数 ← ローカル変数 | `void method(int x) { int x = 3; }` | ❌ **コンパイルエラー**（同一スコープで定義不可） |

---

### ❗補足：仮引数とローカル変数は**同じスコープ**とみなされるため、次のようなコードは**エラーになります**：

```java
void method(int x) {
    int x = 5; // エラー：変数 x はすでに定義されています
}
```

これはシャドーイングではなく、「**再定義エラー**」です。

---

### ✅ 他に考えられるケース（ほぼ応用）

### 1. コンストラクタでも仮引数のシャドーイングが起こる

```java
public class Person {
    private String name;

    public Person(String name) {
        this.name = name; // 仮引数がフィールドをシャドーイング
    }
}
```

### 2. ネストしたスコープでもローカル変数のシャドーイングが起こる

```java
void test() {
    int num = 1;
    {
        int num = 2; // これはOK（別スコープ） → 内側のnumが外側のnumをシャドーイング
        System.out.println(num); // 2
    }
    System.out.println(num); // 1
}
```

---

### ✅ 結論：Hiroakiさんの分類は正確で十分！

> メソッド内にローカル変数があるメソッドに仮引数がある上記2つがなければフィールドが使われる
> 

この理解で、Javaのスコープ解決に関しては **ほぼ100％対応可能です**。

あとは「`this.` を明示する場面」や「スコープの衝突によるエラー」が関わってくるくらいです。

---

もっとややこしい例や、気になる仕様があれば深掘りもできますよ！