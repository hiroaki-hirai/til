# シャドーイング、隠蔽

[シャドーイング](%E3%82%B7%E3%83%A3%E3%83%89%E3%83%BC%E3%82%A4%E3%83%B3%E3%82%B0%E3%80%81%E9%9A%A0%E8%94%BD%2023362cef7350801ca0f7dc15d2dd8acf/%E3%82%B7%E3%83%A3%E3%83%89%E3%83%BC%E3%82%A4%E3%83%B3%E3%82%B0%2023362cef7350809fa317f80c3c4703eb.md)

[フィールド or ローカル変数](%E3%82%B7%E3%83%A3%E3%83%89%E3%83%BC%E3%82%A4%E3%83%B3%E3%82%B0%E3%80%81%E9%9A%A0%E8%94%BD%2023362cef7350801ca0f7dc15d2dd8acf/%E3%83%95%E3%82%A3%E3%83%BC%E3%83%AB%E3%83%89%20or%20%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E5%A4%89%E6%95%B0%2025a62cef73508074aae6cd75973cabec.md)

[ラムダ式の場合](%E3%82%B7%E3%83%A3%E3%83%89%E3%83%BC%E3%82%A4%E3%83%B3%E3%82%B0%E3%80%81%E9%9A%A0%E8%94%BD%2023362cef7350801ca0f7dc15d2dd8acf/%E3%83%A9%E3%83%A0%E3%83%80%E5%BC%8F%E3%81%AE%E5%A0%B4%E5%90%88%2022262cef73508013809cf1c72df78107.md)

[隠蔽](%E3%82%B7%E3%83%A3%E3%83%89%E3%83%BC%E3%82%A4%E3%83%B3%E3%82%B0%E3%80%81%E9%9A%A0%E8%94%BD%2023362cef7350801ca0f7dc15d2dd8acf/%E9%9A%A0%E8%94%BD%2023362cef735080608b78ca04a7ee23d1.md)

# Q,

シャドーイングや隠蔽は、動作としてこうなるということは理解できたのですが、これらはJavaの安全のための措置ということでしょうか？
また、この事象を利用する設計はありますか？

とても深い視点ですね、Hiroakiさん！

結論から先にお伝えすると：

---

### ✅ 回答まとめ

- **シャドーイングや隠蔽は、安全のための措置というよりも、言語仕様に伴う**「名前解決のルール（曖昧さの排除）」です。
- 意図的に使うケースもありますが、**設計上はなるべく避ける**のが一般的です。
- ただし、**明示的に `this` を使った設計**や、**フィールドを初期化するパターン**など、一部で「意図的なシャドーイング」が見られます。

---

## 🔍 なぜ存在する？（シャドーイング・隠蔽の意味）

### ◾ シャドーイング

シャドーイングは「変数スコープの衝突」を自然に処理するためにあります。

```java
class User {
    private String name;

    public void setName(String name) {
        this.name = name; // ← よく見るやつ
    }
}
```

- これは「引数の `name`」がフィールドの `name` を**シャドーイング**している。
- `this.name = name` とすることで、「**フィールドと引数の明確な区別**」ができる。
- 安全というよりは、「**意図的な明示**」のための手段。

---

### ◾ 隠蔽（hiding）

隠蔽は、**静的なメンバやフィールドに「オーバーライド」ができない**という Java の設計ルールに基づくものです。

```java
class Parent {
    static void show() {
        System.out.println("Parent");
    }
}

class Child extends Parent {
    static void show() {
        System.out.println("Child");
    }
}
```

- `Child.show()` は `Parent.show()` を**オーバーライドしているわけではない**。
- 「**参照型に依存して動作が変わる**」＝隠蔽の特徴。
- Javaが意図的に多態性を防ぎ、**静的なメンバは静的に扱う**という方針を貫いている。

つまり：

> 「安全性」よりも「予測可能性」と「一貫性」のために設けられている仕様です。
> 

---

## 🔧 設計で利用されるか？

### ✅ シャドーイング：よくある使い方

- コンストラクタやセッターの引数とフィールドを同名にすることで `this` を明示的に書く
- 開発者に「フィールドを操作している」と**明示させる設計上のメリット**

```java
class Config {
    private int timeout;

    public Config(int timeout) {
        this.timeout = timeout; // this を書くことで可読性・意図の明示
    }
}
```

➡️ **これは意図的にシャドーイングを利用している例**。

---

### ⚠️ 隠蔽は設計では「なるべく避ける」

- 隠蔽されたフィールドや static メソッドは、多くの場合バグの温床になります。
- ポリモーフィズムが効かないので、**動作が直感に反してしまうことがある**。

```java
Parent p = new Child();
p.show(); // Parent と表示される（Child を期待するとバグ）
```

➡️ **staticメソッドの隠蔽は基本的に避けるべき設計**です。

---

## ✅ 結論

| 分類 | 役割 | 設計での扱い |
| --- | --- | --- |
| シャドーイング | スコープの衝突解決（明示のための仕組み） | よく使われる（セッター、コンストラクタなど） |
| 隠蔽（hiding） | 静的メンバの多態性を禁止する設計方針 | 意図的に使うことは稀。**避ける方がよい** |

---

もし「どうしても同名にせざるを得ない設計」や、「隠蔽を避けたきれいな設計構造」についても考えたい場合、お手伝いできます！必要なら具体的なリファクタリング例も出せます。