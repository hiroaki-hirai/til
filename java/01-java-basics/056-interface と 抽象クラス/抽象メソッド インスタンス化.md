# 抽象メソッド インスタンス化

# Q,

抽象クラスは、単独ではインスタンス化不可ですが、その子クラスをインスタンス化した場合は、抽象クラス側の通常メソッドやフィールドにアクセスできる(アクセス修飾子は考慮しないものとする)という認識はあっていますか？

はい、Hiroakiさんのその認識は **完全に正しいです**。

---

## ✅ 結論

> 抽象クラスは単独でインスタンス化できませんが、
> 
> 
> その**具象サブクラス（子クラス）をインスタンス化**すれば、
> 
> **抽象クラスに定義された「通常のメソッド」や「フィールド」にはアクセスできます**。
> 
> ※アクセス修飾子の制限を除外した前提で
> 

---

## 🔸 なぜか？

- **抽象クラスは継承されるための土台**
- 抽象でないメンバー（メソッド・フィールド）は、**通常の継承と同じように子クラスへ引き継がれる**
- 子クラスのインスタンスは、**抽象クラスの構造も内部に含んでいる**ため、呼び出し可能

---

## 🔍 確認コード例

```java
abstract class AbstractAnimal {
    String name = "Unnamed";

    void speak() {
        System.out.println("AbstractAnimal speaking: " + name);
    }

    abstract void makeSound(); // ← 抽象メソッド
}

class Dog extends AbstractAnimal {
    @Override
    void makeSound() {
        System.out.println("Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();       // ✅ Dogは具象クラスなのでインスタンス化可能
        d.name = "Pochi";        // ✅ 抽象クラスのフィールドにアクセス
        d.speak();               // ✅ 抽象クラスの通常メソッドを呼び出し
        d.makeSound();           // ✅ 子クラスで実装されたメソッド
    }
}
```

### **✅ 実行結果**

```java
AbstractAnimal speaking: Pochi
Woof!
```

- 抽象クラス `AbstractAnimal` の `speak()`（通常メソッド）が呼び出されていることが確認できます。
- `name` フィールドへのアクセスも可能。

---

## ✅ ポイント整理

| 要素 | 抽象クラスで定義 | 子クラスからのアクセス | 備考 |
| --- | --- | --- | --- |
| フィールド | ✅ 可（非static/非finalも含む） | ✅ 可 | 継承される |
| 通常メソッド | ✅ 可 | ✅ 可 | オーバーライドも可 |
| 抽象メソッド | ✅ 必須 | ❌ 直接は不可／子クラスで必ず実装する必要あり |  |
| staticメンバー | ✅ 可 | ✅ 可 | 継承される（インスタンスに紐づかない） |

### **❗補足：抽象クラスそのもののインスタンス化は不可**

```java
AbstractAnimal a = new AbstractAnimal(); // ❌ コンパイルエラー：abstractは直接インスタンス化不可
```

---

## ✅ 結論（再掲）

> 抽象クラスはインスタンス化できませんが、
> 
> 
> その子クラスを通してインスタンス化すれば、
> 
> 抽象クラスに定義された**通常メソッドやフィールドには問題なくアクセスできます。**
> 

ご希望であれば、これをテンプレートメソッドパターンなどデザインパターンに応用した例もご紹介できます。