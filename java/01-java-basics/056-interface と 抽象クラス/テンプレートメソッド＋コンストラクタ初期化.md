# テンプレートメソッド＋コンストラクタ初期化

ご要望の「**抽象クラスにおけるテンプレートメソッドパターン＋コンストラクタによる初期化**」の設計について、以下の流れで丁寧に解説します。

---

## ✅ 1. 全体像：何を組み合わせるか？

| 構成要素 | 内容 |
| --- | --- |
| ✅ **テンプレートメソッド** | 抽象クラスで処理の**共通フローを定義**し、一部だけサブクラスに委ねる |
| ✅ **コンストラクタ初期化** | 共通で必要な**状態（フィールド）を安全に初期化** |

---

## ✅ 2. 実例：ファイル処理クラスの設計

### 🔸 抽象クラス：テンプレートメソッド + コンストラクタ

```java
public abstract class AbstractFileProcessor {

    protected final String filePath;

    // ★ コンストラクタによる状態初期化（不変条件）
    public AbstractFileProcessor(String filePath) {
        if (filePath == null || filePath.isBlank()) {
            throw new IllegalArgumentException("filePath must not be null or blank");
        }
        this.filePath = filePath;
    }

    // ★ テンプレートメソッド：処理の流れは固定
    public final void processFile() {
        openFile();
        readData();
        transformData();     // ← サブクラスで定義（抽象）
        writeData();
        closeFile();
    }

    protected void openFile() {
        System.out.println("Opening file: " + filePath);
    }

    protected void readData() {
        System.out.println("Reading data from: " + filePath);
    }

    // ★ 差し替えポイント：実装クラスが独自に定義する処理
    protected abstract void transformData();

    protected void writeData() {
        System.out.println("Writing data...");
    }

    protected void closeFile() {
        System.out.println("Closing file.");
    }
}
```

---

### 🔸 実装クラス：処理の差分を埋める

```java
public class CsvFileProcessor extends AbstractFileProcessor {

    public CsvFileProcessor(String filePath) {
        super(filePath);  // ★ 親コンストラクタで状態を初期化
    }

    @Override
    protected void transformData() {
        System.out.println("Transforming CSV data...");
    }
}
```

---

### 🔸 実行コード

```java
public class Main {
    public static void main(String[] args) {
        AbstractFileProcessor processor = new CsvFileProcessor("data.csv");
        processor.processFile();
    }
}
```

---

## ✅ 実行結果

```java
Opening file: data.csv
Reading data from: data.csv
Transforming CSV data...
Writing data...
Closing file.
```

---

## ✅ 設計上のポイント

| 要素 | 意味と効果 |
| --- | --- |
| `processFile()` | ★ テンプレートメソッド（処理の流れを固定） |
| `transformData()` | サブクラスに実装を任せて「差分だけを切り出す」 |
| `filePath`（final） | コンストラクタで初期化し、「不変条件」を確保 |
| `super(filePath)` | サブクラスで必ず初期化を強制できる |
| `abstract class` + `final`メソッド | 全体構造の誤変更を防ぎつつ、一部だけ差し替え可能にする設計 |

---

## ✅ この設計のメリット

| 観点 | 効果 |
| --- | --- |
| 再利用性 | 共通処理（open, read, write, close）は親クラスに集約 |
| 拡張性 | transformData だけ実装すればOK（他はテンプレートで共通化） |
| 安全性（初期化） | 必須の `filePath` は必ず `super()` 経由で初期化され、不正を防止 |
| 単一責任原則 | 親は「流れの定義」、子は「処理の差分」のみを担当 |

---

## ✅ まとめ：この設計パターンの本質

> 「正しい初期化」と「正しい使い方の流れ」を両方
> 
> 
> → **抽象クラスで“強制かつ柔軟”にコントロールできる設計**です。
> 

---

ご希望であれば、この構造を「Strategyパターン＋DI」と組み合わせた設計や、テストしやすさの観点からMock適用方法などもご紹介できます！