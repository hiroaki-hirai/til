# 抽象メソッド オーバーライド

# Q,

抽象クラス側で定義された抽象メソッドをオーバーライドした子クラスがある場合、抽象メソッド型を宣言型として、子クラスをインスタンス化し、抽象クラスに定義された通常メソッドを呼び出す。その通常メソッド内に、オーバーライドされたメソッドを呼び出している場合、オーバーライドされた子クラス側のメソッドが呼び出されますが、これは、動的バインディングの影響でしょうか？それとも、抽象メソッドは呼び出せないので具象メソッドが選択されたのでしょうか？

Hiroakiさんのご質問は非常に本質的で、**Java の動的バインディングと抽象メソッドの実行モデルの理解**に直結する重要なポイントです。

---

## ✅ 結論

> 抽象クラスの通常メソッドから抽象メソッド（＝子クラスでオーバーライドされたメソッド）を呼び出した際に、子クラスのオーバーライドされた実装が呼ばれるのは、まさに「動的バインディングの効果」です。
> 

---

## 🔍 ポイント整理

### ▶ 抽象メソッドに関するよくある誤解：

- 「抽象メソッドは呼び出せない」は**半分正しくて半分誤解**です。
- 正しくは：
    - **抽象メソッドそのものには「実装がない」ため、単体では呼び出せない**
    - しかし、
        - **抽象クラスの参照型であっても、実体が子クラス（具象クラス）のオブジェクトであれば**
        - **子クラスの実装が呼ばれる（＝動的バインディング）**

---

## ✅ 具体例で確認

```java
abstract class Animal {
    abstract void makeSound(); // ← 抽象メソッド

    void speak() {
        System.out.println("Speaking...");
        makeSound(); // ← 抽象メソッドを呼び出し
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();   // ← 抽象型で宣言、具象型でインスタンス化
        a.speak();              // → "Speaking..." → "Woof!" と出力される
    }
}
```

### **🔸 実行結果**

### 🔸 説明

- `speak()` は **抽象クラス `Animal` に定義された通常メソッド**
- `makeSound()` は **抽象メソッドだが、子クラス `Dog` でオーバーライドされている**
- `a.speak()` の呼び出し時、`makeSound()` の部分は **動的バインディングにより、`Dog.makeSound()` が呼ばれる**

---

## ✅ ではなぜ動的バインディングになるのか？

Java のメソッド呼び出しは以下のように分類されます：

| メソッドの種類 | バインディング方法 | 解決タイミング |
| --- | --- | --- |
| インスタンスメソッド（通常） | 動的バインディング | 実行時 |
| static メソッド | 静的バインディング | コンパイル時 |
| private メソッド | 静的バインディング | コンパイル時 |
| final メソッド | 静的バインディング（JVM最適化あり） | コンパイル時 |

➡ **抽象メソッドも「インスタンスメソッドの一種」**なので、

Java の動的ディスパッチの仕組みにより、**実行時のオブジェクト型に応じて適切な実装が選ばれる**のです。

---

## ✅ まとめ：Hiroakiさんの選択肢への回答

| 選択肢 | 判定 | 説明 |
| --- | --- | --- |
| 🔹 **「動的バインディングの影響でしょうか？」** | ✅ 正しい | 実行時に実体である子クラスのオーバーライド実装が選ばれる |
| 🔸 **「抽象メソッドは呼び出せないので具象メソッドが選択された？」** | ❌ 誤り | 抽象メソッドでも、オーバーライドされていれば実行可能です。選択というより、**動的なディスパッチ結果として呼ばれる** |

---

## ✅ 補足：抽象メソッドは「呼び出せる」か？

- 呼び出し「できる」か「できない」かで言えば：
    - **抽象クラス自身には実装がないので呼び出せない**
    - **だが、子クラスでオーバーライドされていれば、参照型が抽象型でも呼び出せる**

---

## ✅ 結論（再掲）

> 抽象クラスの通常メソッド内で抽象メソッドを呼び出したときに、
> 
> 
> 子クラスのオーバーライド実装が呼ばれるのは、**動的バインディングの効果によるものであり、抽象メソッドかどうかは関係ありません。**
> 

---

ご希望であれば、この仕組みが使われる代表的なデザインパターン（テンプレートメソッドパターン）もご紹介可能です。