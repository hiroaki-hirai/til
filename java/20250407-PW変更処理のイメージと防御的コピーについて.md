#  ■ PW変更処理のイメージ
PW変更処理のイメージは以下の通りで、ロジッククラスにてPW変更に現在のPWとの一致を条件に update...メソッド (set...でもよいが、フレームワークから意図せず呼び出されてしまったり、テストで新人さんが呼び出してしまう可能性を排除する目的らしい) からフィールド値を変更するようです。
```java
public class User {
    private String hashedPassword;

    public boolean checkPassword(String rawPassword, PasswordEncoder encoder) {
        return encoder.matches(rawPassword, hashedPassword);
    }

    void updatePassword(String newHashedPassword) {
        this.hashedPassword = newHashedPassword;
    }
}
```
```java
public class UserService {
    public void changePassword(User user, String currentPw, String newPw, PasswordEncoder encoder) {
        if (!user.checkPassword(currentPw, encoder)) {
            throw new SecurityException("現在のパスワードが正しくありません");
        }
        user.updatePassword(encoder.encode(newPw));
    }
}
```
#  ■ 防御的コピーの使いどころ
また、PWのような機密情報ではなく、柔軟性が必要だけど安全性も欲しいデータを扱う場面にて
防御的コピーを使用するようです。

| シーン | フィールド | セッターの目的 | なぜ防御が必要か |
| --- | --- | --- | --- |
検索条件の設定 | List<String> filters | UIから条件を受け取る | 外部から渡されたListが後で変更されると危険 |
| 設定値の登録 | Map<String, String> config | 外部ファイルから設定を読み込む | 設定後に上書きされるとアプリ全体に影響 |
| ロールや権限 | Set<String> roles | 管理画面から付与/編集 | セキュリティに関わるため信頼できる形にしたい |
| 商品画像リスト | List<Image> images | フォームで複数画像アップロード | UIが再送信したり順番を変えたりする可能性がある |

#  ■ オブジェクト代入後の連動と不連動
防御的コピーで参照先一致の場合と = new で参照先を変えた場合で混乱したのでまとめます。
## 連動する場合
```java
List<String> list1 = new ArrayList<>();
list1.add("Apple");

List<String> list2 = list1; // 同じリストを参照

list2.add("Banana");

System.out.println(list1); // → [Apple, Banana]
```
## 連動しない場合
```java
List<String> list1 = new ArrayList<>();
list1.add("Apple");

List<String> list2 = list1;

list1 = new ArrayList<>();  // list1 は新しいリストを参照
list1.add("Orange");

System.out.println(list2); // → [Apple]
System.out.println(list1); // → [Orange]
```

|操作内容 | 結果 | 連動する？|
| --- | --- | --- |
|sb2 = sb1 | 同じオブジェクトを参照 | ✅|
|sb1.append(...) | オブジェクトの中身を変更 | ✅|
|sb1 = new StringBuilder(...) | 別のオブジェクトを参照 | ❌（切り離される)|

**※ = new で別のオブジェクトを生成して、メモリ上のアドレスが別になる。**
