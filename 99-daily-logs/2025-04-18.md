## ✅ 今日やったこと
- Strategyパターン + 委譲 + Facadeパターン(ラッパー) の確認
- 上記の理解のため、コンストラクタやオブジェクト化の見直し
- オブジェクト化とフィールドの初期化の違いの確認
- 上記の理解のため、オブジェクト生成の流れ (インスタンスの初期化順) の確認
- Java Memory Model (JMM) の概要確認
- Strategyパターンの役割を確認
- Strategyパターンがインターフェースを挟む理由について確認
- Spring とデザインパターンの関係

<br>

## 📌 TIL
- コンストラクタの初期化は、実引数を渡すことなのでその値を確保するメモリ上の場所が必要
→ よってコンストラクタを呼び出す際には必ずオブジェクト化する必要あり。
→ クラスは静的なものでありオブジェクト化することで値を保持しメソッドを動作させることができる
→ 値を保持しようとしたらオブジェクト化は必須
→ 上記のことから、コンストラクタの呼び出し = オブジェクト化 
- では、フィールドの初期化はオブジェクト化していないがなぜか？
→ コンパイラが内部で自動的にインスタンス生成時に実行するコードに変換している
- Javaにおけるオブジェクト生成の流れ（インスタンスの初期化順）
  1. クラスが初めて使われるときにクラスロード（バイトコード読み込み）
  2. staticフィールドの初期化（クラスに属する）
  3. new によってヒープ領域にメモリ確保（インスタンスのため）
  4. インスタンスフィールドの初期化（例：int number = 10;）
  5. コンストラクタの実行<br>
→ 3. new でメソッドをよんだときに初めて 4.のフィールドの初期化が実行される。
→ よって、フィールドの初期化だけが new なしでメモリに保持されることはない
- JMM は、Javaプログラムが どのように変数を読み書きし、スレッド間で共有するかのルールを定めた仕様
→ 単なる「ヒープ」や「スタック」のような物理的な構造ではなく、以下などの振る舞いのルールを含む概念
  - メモリ間の見え方
  - 同期やキャッシュの取り扱い
  - スレッドセーフな設計に必要な保証
- Strategyパターンとは、アルゴリズム (戦略) を「いつ、誰に、どれを適用するか(どれを追加しどれを削除するか)」を柔軟に設定するための構造を事前に整えておくこと
→ そのためインターフェースを継承する実装クラスを隠蔽し他のクラスとの直接のアクセスができないようにしている
- Strategyパターンがインターフェースを利用する理由
  1. ポリモーフィズムの性質より実装クラスが複数であっても、使う側は１つの共通型で扱える
  2. 参照渡しをしてもインターフェースは状態を持たないので、意図しない変更の心配がない <br>
  ※通常はコンストラクタに参照を渡した後にセッターなどで変更すると元のフィールドが書き換わってしまう。
  → この場合は、状態を持つクラスのフィールドへ final private を修飾することで意図しない変更を防げる。
- 参照渡しの際に状態を持つクラスにfinalを使用しない場合
  1. 防御的コピー（Defensive Copy）→ 新たにオブジェクトを生成しそれをフィールドへ代入することで参照を別の参照へ変更しておく
  2. immutable（不変）オブジェクトとして設計する
  3. clone() メソッドや copy() メソッドを使う → 参照元で宣言したcloneメソッドやcopyメソッドを呼び出す
  4. setterの排除と「意図的な再代入の管理」 → setterの代わりにupdate...を用いる → 代入箇所を コンストラクタとupdate...メソッドに限定する
- Springとは、Javaコードを構成・注入・実行の流れを制御するフレームワーク
- Springは、デザインパターン的な構造を書けば、それを正しく認識し、DI（Dependency Injection）やAOP（Aspect-Oriented Programming）などを通じて使いやすくしてくれる
- DIとは、クラスの中で new しなくても、必要な依存オブジェクトを Spring が用意してくれる仕組み
- AOPとは、全体のコードに共通して現れる処理（＝横断的関心事）をまとめて制御する

<br>

## 🤔 疑問・今後調べること・今後の課題
- JMMとスレッドとの関係 → 書籍「Java Concurrency in Practice」にて確認予定
- 他のデザインパターンの実装例を確認しながら実務で使用されるパターンを刷り込む
- copy,clone 関連の整理
- Spring の理解
<br>

## 🛠️ 実行したコード or コマンド
### Strategyパターン + 委譲 + Facadeパターン(ラッパー) モデル
- 会員へのポイント付与事例
- GeneralCustomer クラスが DelegatedCustomer クラスを隠蔽し、さらに DelegatedCustomer クラスが PointStrategy インターフェースを隠蔽し、実際の処理は、その PointStrategy インターフェースを継承している GeneralPointStrategy クラスと GoldPointStrategy クラスが担っている。

```pgsql
[Client] 
   ↓
[GeneralCustomer]  ← Facade / Wrapper
   ↓（委譲）
[DelegatedCustomer] ← Context（Strategyを使う役）
   ↓（依存）
[PointStrategy（interface）]
   ├─ GeneralPointStrategy
   └─ GoldPointStrategy
```

#### 1：共通インターフェース
```java
public interface PointStrategy {
    void addPoint(int totalPrice);
}
```
#### 2：共通の委譲クラス
```java
public class DelegatedCustomer {
    private PointStrategy pointStrategy;

    public DelegatedCustomer(PointStrategy pointStrategy) {
        this.pointStrategy = pointStrategy;
    }

    public void addPoint(int totalPrice) {
        pointStrategy.addPoint(totalPrice);
    }
}
```
#### 3：実装 (実際の処理を担う) クラス
```java
public class GeneralPointStrategy implements PointStrategy {
    public void addPoint(int totalPrice) {
        // 5%
    }
}

public class GoldPointStrategy implements PointStrategy {
    public void addPoint(int totalPrice) {
        // 10%
    }
}
```
#### 4：窓口クラス
```java
public class GeneralCustomer {
    private DelegatedCustomer delegated;

    public GeneralCustomer() {
        this.delegated = new DelegatedCustomer(new GeneralPointStrategy());
    }

    public void addPoint(int totalPrice) {
        delegated.addPoint(totalPrice);
    }
}
```

<br>

##  🧩学習方針・ロードマップ
以下の項目、スケジュールで学習していきます。

### **第1フェーズ：Java言語の基礎と実行環境の理解**

| 項目 | 内容 |
| --- | --- |
| JDK / JRE / JVM | Javaアプリがどのように動いているかを理解 |
| Java文法復習（Silverレベル） | 基本構文・制御構文・オブジェクト指向・例外処理 |
| Java API | String, List, Map, Stream などの標準ライブラリの使い方 |
| コレクションAPI・ラムダ式・Stream API | データ処理の基本として重要（実務で頻出） |

### **第2フェーズ：設計力の基礎とコードの質の向上**

| 項目 | 内容 |
| --- | --- |
| SOLID原則 | 拡張しやすく壊れにくい設計の5原則 |
| デザインパターン | Strategy, Factory, Decorator, Compositeなど代表パターン |
| リファクタリング | コードの可読性・保守性向上。メソッド抽出、分割、置換など |
| JLS / JPMS | Java仕様の深掘り、モジュール化構造の理解（余裕があれば） |

### **第3フェーズ：テストと品質保証の実践**

| 項目 | 内容 |
| --- | --- |
| JUnit（4 or 5） | 単体テストの書き方、アサーション、セットアップ、例外テスト |
| Mockito | モックによる依存の切り離し |
| TDD（テスト駆動開発） | テスト→実装→リファクタの循環型開発 |
| テスト設計技法 | 等価クラス、境界値、状態遷移など（基本だけでOK） |

### **第4フェーズ：実務開発の準備（フレームワーク／構成管理）**

| 項目 | 内容 |
| --- | --- |
| フレームワーク基礎 | Spring Framework（DI / AOP / MVC / Boot） |
| ビルドツール | Maven or Gradle（依存管理、ビルド、JAR作成） |
| ログ設計 | Logback / SLF4J（ログレベル、ロガーの設計） |
| 例外処理設計 | ハンドリング方針、ログ連携、ユーザーフィードバック方法 |
| レイヤー設計 | Controller / Service / Repository などの役割分離 |

### 学習期間目安

| フェーズ | 学習期間の目安 | 目的 |
| --- | --- | --- |
| 第1フェーズ | 1～2ヶ月 | Javaの基本力を身につける |
| 第2フェーズ | 1ヶ月前後 | 設計と品質への意識を高める |
| 第3フェーズ | 1ヶ月 | 品質保証・テスト技術を実装と共に理解 |
| 第4フェーズ | 2ヶ月～ | 実務で使える構造・運用・フレームワーク技術を習得 |