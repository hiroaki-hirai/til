## ✅ 今日やったこと
- 正規表現 (Udemy)
- Javaでの正規表現
- Pattern、Matcher
- Javaの参照と参照値 (C言語との比較から)
- Javaのセキュリティ問題概要
- C言語のセキュリティ問題概要


<br>

## 📌 TIL
- Javaでは、一般的な正規表現(Perl互換パターン) と以下の2点を確認する必要あり
  1. Javaの「文字列エスケープ」ルールがある
    - Javaのコード上では "\d" は不正 → "\\\\d" にする必要がある
    - これは Javaの文字列リテラルの仕様で、正規表現自体とは関係なし

  2. Javaの Pattern クラスが一部の構文を未対応 or 独自拡張している
    - 一部の構文（例：(?R) 再帰パターンなど）は Java では未対応
    - 逆に Java では (?<name>...) のような名前付きキャプチャも使える（Java 7以降）

パターン |	説明 |	Java用正規表現（String）
--- | --- | ---
📱 電話番号（例：090-1234-5678） |	ハイフン付きの日本国内の携帯番号形式 |	"^0\\d{1,4}-\\d{1,4}-\\d{4}$"
📩 メールアドレス |	一般的な形式（簡易版） |	"^[\\w.-]+@[\\w.-]+\\.[a-zA-Z]{2,6}$"
🔑 パスワード（英数8文字以上） |	大文字・小文字・数字を含む8文字以上 |	"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{8,}$"
📅 日付（YYYY-MM-DD） |	年-月-日の形式（基本的な範囲） |	"^\\d{4}-\\d{2}-\\d{2}$"
🆔 ユーザーID（英数字5～12文字） |	アルファベットと数字のみ |	"^[a-zA-Z0-9]{5,12}$"
🌐 URL |	http/https で始まるURL（簡易） |	"^https?://[\\w./%-]+$"
🧾 郵便番号（例：123-4567） |	日本の形式に準拠 |	"^\\d{3}-\\d{4}$"

- C言語では、ポインタによるメモリの物理的なアドレスの指定より、アドレスが固定されることで起こるセキュリティ上の問題があるが、Javaではメモリ上の固定アドレスはあるものの、それを参照値として別のラベルを付与することで物理的なメモリ上のアドレスから、仮想のアドレスとすることで、上記のC言語のセキュリティ上の問題を回避する仕組みになっている
→ 以上のことからJavaでいう参照値は、メモリの物理的なアドレスを直接さすものではない<br>
→ 「参照渡し」という表現があるが正確には「参照値渡し」

表現 |	C言語 |	Java
--- | --- | ---
「参照」 |	*ptr → ポインタを使ってアクセスされる対象の値（実体）	| obj → オブジェクトへの手がかり（参照）を保持する変数
「参照値」 |	ptr → アドレスそのもの	| obj → JVM内で管理されている「アドレスに相当する情報」
「ポインタ」 |	int* ptr などの明示的なアドレス型 |	存在しない（Javaはポインタ操作不可）

→ Javaではそもそもポインタ操作やアドレス参照が禁止されていることから、脆弱性の多くを自動回避できている
- ただし、以下の項目はJavaのセキュリティを崩す代表的な手段

手段 |	主な用途 |	セキュリティ的リスク
--- | --- | ---
JNI（Java Native Interface） |	Java から C/C++ などのネイティブコードを呼び出す |	メモリ安全性・型安全性が失われる
リフレクション（Reflection API） |	実行時にクラス・メソッド・フィールドにアクセス |	カプセル化の破壊、privateアクセス可能に
シリアライズ/デシリアライズ |	オブジェクトの保存と復元 |	悪意あるオブジェクトの注入（Gadget攻撃）
クラスローダの悪用 |	動的にクラスをロード |	偽装クラスを差し込むことで本来の制御を回避
- 上記の回避手段概要
  - JNI → 使用を極力避ける or sandbox化

  - リフレクション → 使う範囲を制限・Module機構の利用

  - デシリアライズ → 信頼できないソースからの読み取りを避ける

  - クラスローダ → SecurityManager（※将来的に非推奨）やカスタムローダ管理

- JNI が出てきたのでC言語におけるセキュリティ問題を以下にまとめます

|セキュリティ問題 | 説明 | 主な原因 | 代表的な解決手段|
|--- | --- | --- | ---|
|バッファオーバーフロー | 配列などの境界を超えてメモリを書き換える | 境界チェックなし (gets, strcpy, etc.) | ● Stack Canary <br> ● strncpy, fgets など安全な関数の使用<br> ● ASLR<br> ● コンパイラの警告 (-Wall, -Wextra)|
|ヒープオーバーフロー | ヒープ領域でのバッファ超過で他領域を破壊 | malloc された領域の誤使用 | ● valgrind や ASAN で検知 <br> ● 安全なヒープAPI（calloc）<br> ● ガーベジデータの初期化|
|Use After Free | 解放済みメモリを使い続ける | free() 後にポインタを保持 |  ● ポインタを NULL にリセット <br> ● valgrind / AddressSanitizer で検出|
|ダングリングポインタ | 実体が消えた後に残るポインタ | スコープ外変数のポインタ保持 |   ● ポインタ無効化<br> ●スコープ設計の見直し|
|メモリリーク | 解放されないメモリの蓄積 | malloc → free 忘れ |   ● valgrind などで検出<br> ● 明示的なメモリ管理|
|フォーマット文字列攻撃 | printf(user_input) による任意読み書き | ユーザ入力を直接フォーマットに使用 |  ● printf("%s", user_input) のように明示指定|
|整数オーバーフロー / アンダーフロー | 数値が範囲を超えて巻き戻る | 型のサイズ無視・検査不足 |  ● 境界チェックの明示化<br> ● __builtin_add_overflow() など（GCC）|
|NULLポインタ参照 | 初期化されていないポインタの使用 | ポインタの不適切な初期化 |  ● 明示的に NULL 初期化<br> ● ポインタ使用前のチェック|
|コードインジェクション（RCE） | 攻撃者のデータがコードとして実行される | バッファオーバーフロー、関数ポインタ改ざんなど |  ● NX（非実行メモリ）<br> ● ASLR<br> ● Stack Canary|
|未定義動作（UB） | 規格で定められていない動作 → 不正動作に繋がる | 配列外参照・未初期化変数など |  ● 静的解析ツール（clang-analyzer）<br> ● サニタイザ使用|

<br>

## 🤔 疑問・今後調べること・今後の課題
- C言語との比較
- セキュリティ問題への理解を深める

<br>

## 🛠️ 実行したコード or コマンド
### 正規表現
```regex
\[\d+\d+\]
\[[0-9]{1,}\+[0-9]{1,}\]
\[\d+[*+\-]\d+\]

// 最短一致
野球の.+?\d+位

// 並列結合
私は(\d{2}:\d{2}|\d{2}時\d{2}分)に(起床|就寝)

// 直列結合
年齢は1[0-9]才.+17[0-9]cm

// グループ化
\d(-\d){0,}:

// 行頭行末
^英語\(\d*\)
数学\(\d*\).+$

// 前後参照
彼女(?=おじさん)
彼女(?!おじさん)
(?<=オバケ)彼氏
(?<!オバケ)彼氏
[A-Z]{2}\d{2}(?=便)
[A-Z]{2}\d{2}(?!\)から)
(?<=駅)[A-Z]{2}\d{2}
(?<!コード)[A-Z]{2}\d{2}

// Grep該当抽出
// Grep反転抽出

// Java パスワード例 \をプラス
String passwordRegex = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{8,}$";

// 置換
3年([A-Z])組の(\d{1,2})番
3-$1($2)
【$&】

^.+(3年[A-Z]).+(\d{2}).+$
$1,$2

// 行消去
^.+(3年[A-Z]).+(\d{2}).+$\r\n
空欄

// 行増幅
^.+(3年[A-Z]).+(\d{2}).+$\r\n
$&$&

// 表計算アプリへコピー前の整形 (dirコマンドの出力を元に)
^ .*$\r\n
空白
^.+<DIR>.+$\r\n
空白
^$\r\n
空白

^(.{10})  (.{5}) +(\d+) ((.+?)_(.+)_(.{6})\.dat)$
'$7\t\5\t$6\t$4\t$3\t$1 $2

// キャプチャの間に数字をいれる場合 直前のキャプチャ番号を{}で囲む
3${1}0$2

// キャプチャに含めないようにする場合 ?:
(?:兄弟|姉妹)は3年(.)組

// 大文字、小文字の変換
([A-Za-z]+) ([A-Za-z]+)、出身は([A-Za-z]+)
\U$1 \L$2(\E$3)

\U 大文字へ
\L 小文字へ
\E 変換なしへ
\u 一文字のみ大文字へ
\l 一文字のみ小文字へ

// 基本小文字に変換しつつ、最初の文字のみ大文字へ
\L\u$1 \u$2(\E$3)


```
### Pattern,Matcher
```java
import java.nio.file.*;
import java.util.regex.*;

public class RegexFileSearch {
    public static void main(String[] args) throws Exception {
        // ① ファイルから中身を読み込む
        String content = Files.readString(Path.of("example.txt"));

        // ② 正規表現のパターンを定義
        Pattern pattern = Pattern.compile("3年([A-Z])組の(\\d{1,2})番");

        // ③ 読み込んだ文字列に正規表現を適用
        Matcher matcher = pattern.matcher(content);

        // ④ マッチした箇所を置換（例）
        String result = matcher.replaceAll("3-$1($2)");

        // ⑤ 結果を出力
        System.out.println(result);
    }
}
```
### 行の消去
```java
String content = Files.readString(Path.of("example.txt"));

// 行末を \r\n で統一（Windows）
String normalized = content.replaceAll("\r?\n", "\r\n");

// 該当行を削除
String removed = normalized.replaceAll("^.+(3年[A-Z]).+(\\d{2}).+\\r\\n", "");

System.out.println(removed);
```
### 行の複製
```java
String content = Files.readString(Path.of("example.txt"));
String normalized = content.replaceAll("\r?\n", "\r\n");

String duplicated = normalized.replaceAll("^.+(3年[A-Z]).+(\\d{2}).+\\r\\n", "$&$&");

System.out.println(duplicated);
```
コード部分 | メソッド or クラス名 | 所属パッケージ | 説明
--- | --- | --- | ---
Files.readString(...) | Files クラス & readString() メソッド | java.nio.file | ファイルを String として読み込む
Path.of(...) | Path クラス & of() メソッド | java.nio.file | ファイルのパスをオブジェクトとして表現
Pattern.compile(...) | Pattern クラス & compile() メソッド | java.util.regex | 正規表現のパターン（設計図）を生成
pattern.matcher(...) | Pattern のインスタンスメソッド | matcher()	java.util.regex | 与えられた文字列に対してマッチャーを生成
matcher.replaceAll(...) | Matcher クラス & replaceAll() メソッド | java.util.regex | マッチした箇所をすべて置換

<br>

##  🧩学習方針・ロードマップ
以下の項目、スケジュールで学習していきます。

### **第1フェーズ：Java言語の基礎と実行環境の理解**

| 項目 | 内容 |
| --- | --- |
| JDK / JRE / JVM | Javaアプリがどのように動いているかを理解 |
| Java文法復習（Silverレベル） | 基本構文・制御構文・オブジェクト指向・例外処理 |
| Java API | String, List, Map, Stream などの標準ライブラリの使い方 |
| コレクションAPI・ラムダ式・Stream API | データ処理の基本として重要（実務で頻出） |

### **第2フェーズ：設計力の基礎とコードの質の向上**

| 項目 | 内容 |
| --- | --- |
| SOLID原則 | 拡張しやすく壊れにくい設計の5原則 |
| デザインパターン | Strategy, Factory, Decorator, Compositeなど代表パターン |
| リファクタリング | コードの可読性・保守性向上。メソッド抽出、分割、置換など |
| JLS / JPMS | Java仕様の深掘り、モジュール化構造の理解（余裕があれば） |

### **第3フェーズ：テストと品質保証の実践**

| 項目 | 内容 |
| --- | --- |
| JUnit（4 or 5） | 単体テストの書き方、アサーション、セットアップ、例外テスト |
| Mockito | モックによる依存の切り離し |
| TDD（テスト駆動開発） | テスト→実装→リファクタの循環型開発 |
| テスト設計技法 | 等価クラス、境界値、状態遷移など（基本だけでOK） |

### **第4フェーズ：実務開発の準備（フレームワーク／構成管理）**

| 項目 | 内容 |
| --- | --- |
| フレームワーク基礎 | Spring Framework（DI / AOP / MVC / Boot） |
| ビルドツール | Maven or Gradle（依存管理、ビルド、JAR作成） |
| ログ設計 | Logback / SLF4J（ログレベル、ロガーの設計） |
| 例外処理設計 | ハンドリング方針、ログ連携、ユーザーフィードバック方法 |
| レイヤー設計 | Controller / Service / Repository などの役割分離 |

### 学習期間目安

| フェーズ | 学習期間の目安 | 目的 |
| --- | --- | --- |
| 第1フェーズ | 1～2ヶ月 | Javaの基本力を身につける |
| 第2フェーズ | 1ヶ月前後 | 設計と品質への意識を高める |
| 第3フェーズ | 1ヶ月 | 品質保証・テスト技術を実装と共に理解 |
| 第4フェーズ | 2ヶ月～ | 実務で使える構造・運用・フレームワーク技術を習得 |