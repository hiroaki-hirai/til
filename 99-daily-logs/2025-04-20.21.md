## ✅ 今日やったこと
- 正規表現 (Udemy)
- Javaの参照と参照値


<br>

## 📌 TIL
- C言語では、ポインタによるメモリの物理的なアドレスの指定より、アドレスが固定されることで起こるセキュリティ上の問題があるが、Javaではメモリ上の固定アドレスはあるものの、それを参照値として別のラベルを付与することで物理的なメモリ上のアドレスから、仮想のアドレスとすることで、上記のC言語のセキュリティ上の問題を回避する仕組みになっている
→ 以上のことからJavaでいう参照値は、メモリの物理的なアドレスを直接さすものではない

表現 |	C言語 |	Java
--- | --- | ---
「参照」 |	*ptr → ポインタを使ってアクセスされる対象の値（実体）	| obj → オブジェクトへの手がかり（参照）を保持する変数
「参照値」 |	ptr → アドレスそのもの	| obj → JVM内で管理されている「アドレスに相当する情報」
「ポインタ」 |	int* ptr などの明示的なアドレス型 |	存在しない（Javaはポインタ操作不可）

→ Javaではそもそもポインタ操作やアドレス参照が禁止されていることから、脆弱性の奥を自動回避できている
- ただし、以下の項目はJavaのセキュリティを崩す代表的な手段

手段 |	主な用途 |	セキュリティ的リスク
--- | --- | ---
JNI（Java Native Interface） |	Java から C/C++ などのネイティブコードを呼び出す |	メモリ安全性・型安全性が失われる
リフレクション（Reflection API） |	実行時にクラス・メソッド・フィールドにアクセス |	カプセル化の破壊、privateアクセス可能に
シリアライズ/デシリアライズ |	オブジェクトの保存と復元 |	悪意あるオブジェクトの注入（Gadget攻撃）
クラスローダの悪用 |	動的にクラスをロード |	偽装クラスを差し込むことで本来の制御を回避

- JNI が出てきたのでC言語における

|セキュリティ問題 | 説明 | 主な原因 | 代表的な解決手段|
|--- | --- | --- | ---|
|バッファオーバーフロー | 配列などの境界を超えてメモリを書き換える | 境界チェックなし (gets, strcpy, etc.) | Stack Canary <br> strncpy, fgets など安全な関数の使用<br> ASLR<br> コンパイラの警告 (-Wall, -Wextra)|
|ヒープオーバーフロー | ヒープ領域でのバッファ超過で他領域を破壊 | malloc された領域の誤使用 | valgrind や ASAN で検知
<br> 安全なヒープAPI（calloc）
<br> ガーベジデータの初期化|
|Use After Free | 解放済みメモリを使い続ける | free() 後にポインタを保持 | ポインタを NULL にリセット
<br> valgrind / AddressSanitizer で検出|
|ダングリングポインタ | 実体が消えた後に残るポインタ | スコープ外変数のポインタ保持 |  ポインタ無効化
 スコープ設計の見直し|
|メモリリーク | 解放されないメモリの蓄積 | malloc → free 忘れ |  valgrind などで検出
 明示的なメモリ管理|
|フォーマット文字列攻撃 | printf(user_input) による任意読み書き | ユーザ入力を直接フォーマットに使用 | printf("%s", user_input) のように明示指定|
|整数オーバーフロー / アンダーフロー | 数値が範囲を超えて巻き戻る | 型のサイズ無視・検査不足 | 境界チェックの明示化
<br> __builtin_add_overflow() など（GCC）|
|NULLポインタ参照 | 初期化されていないポインタの使用 | ポインタの不適切な初期化 | 明示的に NULL 初期化
<br> ポインタ使用前のチェック|
|コードインジェクション（RCE） | 攻撃者のデータがコードとして実行される | バッファオーバーフロー、関数ポインタ改ざんなど | - NX（非実行メモリ）
<br> ASLR
<br> Stack Canary|
|未定義動作（UB） | 規格で定められていない動作 → 不正動作に繋がる | 配列外参照・未初期化変数など | 静的解析ツール（clang-analyzer）
<br> サニタイザ使用|

<br>

## 🤔 疑問・今後調べること・今後の課題
- 列挙型と定数ラップパターンとの比較の詳細確認
- JVMの動作を念頭に置いた学習
- 正規表現の応用確認 → 「詳説 正規表現」 で確認予定

<br>

## 🛠️ 実行したコード or コマンド
### enumとenumを使用しない場合
- 会員へのポイント付与事例
- enum を使用しない場合でも、以下のように定数やint型をラップしてクラス化する方法もある
  1. 定数ラッパーとしてクラス化する場合
  2. int型をラップして制限付きの方として扱う場合

#### 1：enum
```java
public enum CustomerType {
    GENERAL,
    CORPORATE,
    PREMIUM;
}
```
```java
public void register(CustomerType type) {
    if (type == CustomerType.PREMIUM) {
        // プレミアム処理
    }
}
```
#### 2：定数ラッパーとしてクラス化する場合
```java
public class CustomerType {
    public static final CustomerType GENERAL = new CustomerType(0, "GENERAL");
    public static final CustomerType CORPORATE = new CustomerType(1, "CORPORATE");
    public static final CustomerType PREMIUM = new CustomerType(2, "PREMIUM");

    private final int code;
    private final String name;

    private CustomerType(int code, String name) {
        this.code = code;
        this.name = name;
    }

    public int getCode() { return code; }
    public String getName() { return name; }

    @Override
    public String toString() {
        return name;
    }
}
```
```java
CustomerType type = CustomerType.PREMIUM;
System.out.println(type.getCode()); // → 2
```
#### 3：int型をラップして制限付きの方として扱う場合
```java
public final class CustomerType {
    private final int value;

    private CustomerType(int value) {
        if (value < 0 || value > 2) {
            throw new IllegalArgumentException("Invalid customer type");
        }
        this.value = value;
    }

    public static CustomerType of(int value) {
        return new CustomerType(value);
    }

    public int getValue() {
        return value;
    }

    @Override
    public boolean equals(Object obj) {
        return (obj instanceof CustomerType) && ((CustomerType) obj).value == this.value;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(value);
    }
}
```
```java
CustomerType type = CustomerType.of(2);
```

<br>

##  🧩学習方針・ロードマップ
以下の項目、スケジュールで学習していきます。

### **第1フェーズ：Java言語の基礎と実行環境の理解**

| 項目 | 内容 |
| --- | --- |
| JDK / JRE / JVM | Javaアプリがどのように動いているかを理解 |
| Java文法復習（Silverレベル） | 基本構文・制御構文・オブジェクト指向・例外処理 |
| Java API | String, List, Map, Stream などの標準ライブラリの使い方 |
| コレクションAPI・ラムダ式・Stream API | データ処理の基本として重要（実務で頻出） |

### **第2フェーズ：設計力の基礎とコードの質の向上**

| 項目 | 内容 |
| --- | --- |
| SOLID原則 | 拡張しやすく壊れにくい設計の5原則 |
| デザインパターン | Strategy, Factory, Decorator, Compositeなど代表パターン |
| リファクタリング | コードの可読性・保守性向上。メソッド抽出、分割、置換など |
| JLS / JPMS | Java仕様の深掘り、モジュール化構造の理解（余裕があれば） |

### **第3フェーズ：テストと品質保証の実践**

| 項目 | 内容 |
| --- | --- |
| JUnit（4 or 5） | 単体テストの書き方、アサーション、セットアップ、例外テスト |
| Mockito | モックによる依存の切り離し |
| TDD（テスト駆動開発） | テスト→実装→リファクタの循環型開発 |
| テスト設計技法 | 等価クラス、境界値、状態遷移など（基本だけでOK） |

### **第4フェーズ：実務開発の準備（フレームワーク／構成管理）**

| 項目 | 内容 |
| --- | --- |
| フレームワーク基礎 | Spring Framework（DI / AOP / MVC / Boot） |
| ビルドツール | Maven or Gradle（依存管理、ビルド、JAR作成） |
| ログ設計 | Logback / SLF4J（ログレベル、ロガーの設計） |
| 例外処理設計 | ハンドリング方針、ログ連携、ユーザーフィードバック方法 |
| レイヤー設計 | Controller / Service / Repository などの役割分離 |

### 学習期間目安

| フェーズ | 学習期間の目安 | 目的 |
| --- | --- | --- |
| 第1フェーズ | 1～2ヶ月 | Javaの基本力を身につける |
| 第2フェーズ | 1ヶ月前後 | 設計と品質への意識を高める |
| 第3フェーズ | 1ヶ月 | 品質保証・テスト技術を実装と共に理解 |
| 第4フェーズ | 2ヶ月～ | 実務で使える構造・運用・フレームワーク技術を習得 |