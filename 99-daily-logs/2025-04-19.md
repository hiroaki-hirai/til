## ✅ 今日やったこと
- 定数の問題点と列挙型の確認
- ポリモーフィズム : JVMの動き (動的バインディング) の確認
- JVMのプログラム実行時の処理順について確認
- Stringクラスのイミュータブルの構造の確認
- 上記の理解のため、StringLatin1 や StringUTF16 の内部クラスの実装 の確認
- Patternクラス + Matcherクラスの確認
- 正規表現 (Udemy)

<br>

## 📌 TIL
- enum を使用しない場合でも、以下のように定数やint型をラップしてクラス化する方法もある
  1. 定数ラッパーとしてクラス化する場合
  2. int型をラップして制限付きの方として扱う場合
- 以下の sayHello() は、Greeting インターフェースに定義されたメソッドだが、JVMは g の実体が JapaneseGreeting であることを知っているので、JapaneseGreeting のオーバーライドされたメソッドを呼び出す。
```java
Greeting g = new JapaneseGreeting();
g.sayHello();
```
→ インターフェースを実装したクラスは、内部的に「仮想テーブル（vtable）」のような仕組みを持っている
```text
Greetingインターフェース
 └─ sayHello()

JapaneseGreeting implements Greeting
 └─ sayHello() オーバーライド済み
```
→ Greeting は sayHello() の「呼び出し口」だけを持つ
→ JapaneseGreeting は「具体的な実装」を持ち、JVMは 実行時にこの実装を呼ぶようにvtableで管理する。
- JVMの処理手順
→ 動的バインディングが行われるのは、以下の[5]の段階
```css
[1] クラスロード
  - JVMが最初に .class ファイル（バイトコード）をロード
  - クラスローダ（ClassLoader）により、必要なクラスをメモリに読み込む
[2] バイトコード検証
  - 不正なバイトコードが含まれていないか検査
    セキュリティ上の理由（例：配列の範囲外アクセス、スタックの整合性など）
[3] クラス初期化
  - static 初期化ブロックや static 変数がこのタイミングで実行される
[4] main メソッドの呼び出し
[5] 実行中：メソッド呼び出し／スレッド管理／GCなど
  - スタックフレームでメソッド呼び出し・戻りを管理
  - ヒープ領域にオブジェクトを生成
  - 不要になったオブジェクトは**ガベージコレクション（GC）**が回収
  - 複数スレッドが存在する場合はスレッドスケジューラが実行順を調整
[6] プログラム終了／終了処理
  - main() メソッドが終了するか、System.exit() が呼ばれるとJVM終了
  - shutdown hook が登録されていれば、それを最後に実行
```
- Stringクラスのイミュータブル設計について
  1. Stringクラス型に格納される値そのものは、final(再代入不可) + private(外部アクセス不可) で保護
  2. その値を他のメソッド (substringなど) で利用する場合は、メソッド実施後に return new で防御的コピーで保護

<br>

## 🤔 疑問・今後調べること・今後の課題
- 列挙型と定数ラップパターンとの比較の詳細確認
- JVMの動作を念頭に置いた学習
- 正規表現の応用確認 → 「詳説 正規表現」 で確認予定

<br>

## 🛠️ 実行したコード or コマンド
### enumとenumを使用しない場合
- 会員へのポイント付与事例
- enum を使用しない場合でも、以下のように定数やint型をラップしてクラス化する方法もある
  1. 定数ラッパーとしてクラス化する場合
  2. int型をラップして制限付きの方として扱う場合

#### 1：enum
```java
public enum CustomerType {
    GENERAL,
    CORPORATE,
    PREMIUM;
}
```
```java
public void register(CustomerType type) {
    if (type == CustomerType.PREMIUM) {
        // プレミアム処理
    }
}
```
#### 2：定数ラッパーとしてクラス化する場合
```java
public class CustomerType {
    public static final CustomerType GENERAL = new CustomerType(0, "GENERAL");
    public static final CustomerType CORPORATE = new CustomerType(1, "CORPORATE");
    public static final CustomerType PREMIUM = new CustomerType(2, "PREMIUM");

    private final int code;
    private final String name;

    private CustomerType(int code, String name) {
        this.code = code;
        this.name = name;
    }

    public int getCode() { return code; }
    public String getName() { return name; }

    @Override
    public String toString() {
        return name;
    }
}
```
```java
CustomerType type = CustomerType.PREMIUM;
System.out.println(type.getCode()); // → 2
```
#### 3：int型をラップして制限付きの方として扱う場合
```java
public final class CustomerType {
    private final int value;

    private CustomerType(int value) {
        if (value < 0 || value > 2) {
            throw new IllegalArgumentException("Invalid customer type");
        }
        this.value = value;
    }

    public static CustomerType of(int value) {
        return new CustomerType(value);
    }

    public int getValue() {
        return value;
    }

    @Override
    public boolean equals(Object obj) {
        return (obj instanceof CustomerType) && ((CustomerType) obj).value == this.value;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(value);
    }
}
```
```java
CustomerType type = CustomerType.of(2);
```

<br>

##  🧩学習方針・ロードマップ
以下の項目、スケジュールで学習していきます。

### **第1フェーズ：Java言語の基礎と実行環境の理解**

| 項目 | 内容 |
| --- | --- |
| JDK / JRE / JVM | Javaアプリがどのように動いているかを理解 |
| Java文法復習（Silverレベル） | 基本構文・制御構文・オブジェクト指向・例外処理 |
| Java API | String, List, Map, Stream などの標準ライブラリの使い方 |
| コレクションAPI・ラムダ式・Stream API | データ処理の基本として重要（実務で頻出） |

### **第2フェーズ：設計力の基礎とコードの質の向上**

| 項目 | 内容 |
| --- | --- |
| SOLID原則 | 拡張しやすく壊れにくい設計の5原則 |
| デザインパターン | Strategy, Factory, Decorator, Compositeなど代表パターン |
| リファクタリング | コードの可読性・保守性向上。メソッド抽出、分割、置換など |
| JLS / JPMS | Java仕様の深掘り、モジュール化構造の理解（余裕があれば） |

### **第3フェーズ：テストと品質保証の実践**

| 項目 | 内容 |
| --- | --- |
| JUnit（4 or 5） | 単体テストの書き方、アサーション、セットアップ、例外テスト |
| Mockito | モックによる依存の切り離し |
| TDD（テスト駆動開発） | テスト→実装→リファクタの循環型開発 |
| テスト設計技法 | 等価クラス、境界値、状態遷移など（基本だけでOK） |

### **第4フェーズ：実務開発の準備（フレームワーク／構成管理）**

| 項目 | 内容 |
| --- | --- |
| フレームワーク基礎 | Spring Framework（DI / AOP / MVC / Boot） |
| ビルドツール | Maven or Gradle（依存管理、ビルド、JAR作成） |
| ログ設計 | Logback / SLF4J（ログレベル、ロガーの設計） |
| 例外処理設計 | ハンドリング方針、ログ連携、ユーザーフィードバック方法 |
| レイヤー設計 | Controller / Service / Repository などの役割分離 |

### 学習期間目安

| フェーズ | 学習期間の目安 | 目的 |
| --- | --- | --- |
| 第1フェーズ | 1～2ヶ月 | Javaの基本力を身につける |
| 第2フェーズ | 1ヶ月前後 | 設計と品質への意識を高める |
| 第3フェーズ | 1ヶ月 | 品質保証・テスト技術を実装と共に理解 |
| 第4フェーズ | 2ヶ月～ | 実務で使える構造・運用・フレームワーク技術を習得 |