## ✅ 今日やったこと
- StringBuilderクラスまとめ
- Java Silver 出題傾向分析
- 配列のコピー (シャローコピー、ディープコピー)

<br>

## 📌 TIL

### ▢ Stringクラスまとめ (notionへ)　
- append()
- insert()

### ▢ Java Silver 出題傾向分析
第２章<br>

０１問、基本データ型　名前が異なる<br>
０２問、整数リテラル　進数表現ルール<br>
０３問、整数リテラル　「_」アンダースコアのルール<br>
０４問、変数名 (識別子)　識別子の命名規則<br>
０５問、変数の型と初期化する値<br>
０６問、var型　変数宣言<br>
０７問、var型　var型のルール<br>
０８問、var型　コンパイル後の確定<br>
０９問、Stringオブジェクトの作成<br>
１０問、Stringクラス　イミュータブル　メソッドのパラーメータ仮引数の命名<br>
１１問、String.charAt()　例外 java.lang.StringIndexOutOfBoundsException<br>
１２問、String.indexOf()　-1<br>
１３問、String.substring()　通常出力<br>
１４問、String.replace()　通常出力<br>
１５問、String.charAt(String.length())　例外 java.lang.StringIndexOutOfBoundsException<br>
１６問、String.substring().startsWith()　メソッドチェーン　通常出力<br>
１７問、String.concat()　通常出力<br>
１８問、StringBuilder.capacity()　通常出力<br>
１９問、StringBuilder.append().reverse().replace()　通常出力<br>
２０問、StringBuilder.indexOf()　通常出力<br>
２１問、テキストブロック　できること<br>
２２問、テキストブロック　文法<br>
２３問、テキストブロック　インデント<br>
２４問、String　コンスタントプール、==と.equals()<br>
２５問、String　newと文字列リテラル、==と.equals()<br>
２６問、String.intern()　通常出力<br>
２７問、配列の変数に格納されるもの<br>
２８問、多次元配列の宣言<br>
２９問、配列の要素数の指定方法<br>
３０問、配列の要素数の指定方法<br>
３１問、クラス型の配列の変数　デフォルトでnull　null変数にアクセス→ 例外 NullPointException<br>
３２問、String型配列の要素にnullを代入　通常出力<br>
３３問、配列インスタンスの生成と初期化　配列型変数の宣言と参照の代入<br>
３４問、多次元配列　例外 NullPointException<br>
３５問、配列と継承<br>

### ▢ 配列のコピー (シャローコピー、ディープコピー)
#### 1元配列の場合
```java
int[] scores = {1,2,3};
int[] clonedScores = scores.clone();
```
scoresとclonedScoresは、別の参照を持つ → 変更で影響なし

#### 2次元配列の場合
- shallow copy
```java
int[][] arrayA = {{1,2},{1,2},{1,2,3}};
int[][] arrayB = arrayA.clone();
```
外側の配列(1階層目)は、別の参照を持つが、中の小配列(2階層目)は、同じ参照のまま。 → 変更がそのまま反映<br>
以下のように2階層目も順にコピーする
- deep copy
```java
int[][] arrayA = {{1,2},{1,2},{1,2,3}};

// 外側をcloneして新しい配列を作る
int[][] arrayB = arrayA.clone();

// さらに内側（小配列）も個別にcloneする
for (int i = 0; i < arrayA.length; i++) {
    arrayB[i] = arrayA[i].clone();
}
```
#### 3次元配列の場合
```java
int[][][] arrayA = {
    {
        {1,2,3},
        {4,5,6}
    },
    {
        {7,8},
        {9,10}
    }
};

// 外側だけclone
int[][][] arrayB = arrayA.clone();

// 中間層（2次元配列）をclone
for (int i = 0; i < arrayA.length; i++) {
    arrayB[i] = arrayA[i].clone();
    
    // 最内層（1次元配列）もclone
    for (int j = 0; j < arrayA[i].length; j++) {
        arrayB[i][j] = arrayA[i][j].clone();
    }
}
```
#### Listの場合
- shallow copy
```java
ArrayList<String> listA = new ArrayList<>();
listA.add("A");
listA.add("B");

ArrayList<String> listB = (ArrayList<String>) listA.clone();
```
- deep copy
```java
ArrayList<ArrayList<Integer>> listA = new ArrayList<>();
listA.add(new ArrayList<>(List.of(1, 2)));
listA.add(new ArrayList<>(List.of(3, 4)));

ArrayList<ArrayList<Integer>> listB = new ArrayList<>();
for (ArrayList<Integer> innerList : listA) {
    listB.add(new ArrayList<>(innerList)); // 内側のリストも新しく作り直す！
}
```
#### 再帰＋リフレクションで動的にディープコピー
```java
Object[] array = {
    new Object[] {
        new int[] {1, 2},
        new int[] {3, 4}
    },
    new Object[] {
        new int[] {5, 6}
    }
};
```
```java
import java.lang.reflect.Array;

public class DeepCopyUtil {

    public static Object deepCopy(Object array) {
        if (array == null) {
            return null;
        }

        if (!array.getClass().isArray()) {
            return array; // 配列でなければそのまま返す（イミュータブルオブジェクト想定）
        }

        int length = Array.getLength(array);
        Object copiedArray = Array.newInstance(array.getClass().getComponentType(), length);

        for (int i = 0; i < length; i++) {
            Object element = Array.get(array, i);
            Object copiedElement = deepCopy(element); // 再帰呼び出し！
            Array.set(copiedArray, i, copiedElement);
        }

        return copiedArray;
    }
}

```
<br>

## 🤔 疑問・今後調べること・今後の課題
- メソッド洗い出し
- Java Silver 問題傾向分析 続き
- 再帰＋リフレクションによるDeepCopyの理解

<br>

## 🛠️ 実行したコード or コマンド
### 
<br>

##  🧩学習方針・ロードマップ
以下の項目、スケジュールで学習していきます。

### **第1フェーズ：Java言語の基礎と実行環境の理解**

| 項目 | 内容 |
| --- | --- |
| JDK / JRE / JVM | Javaアプリがどのように動いているかを理解 |
| Java文法復習（Silverレベル） | 基本構文・制御構文・オブジェクト指向・例外処理 |
| Java API | String, List, Map, Stream などの標準ライブラリの使い方 |
| コレクションAPI・ラムダ式・Stream API | データ処理の基本として重要（実務で頻出） |

### **第2フェーズ：設計力の基礎とコードの質の向上**

| 項目 | 内容 |
| --- | --- |
| SOLID原則 | 拡張しやすく壊れにくい設計の5原則 |
| デザインパターン | Strategy, Factory, Decorator, Compositeなど代表パターン |
| リファクタリング | コードの可読性・保守性向上。メソッド抽出、分割、置換など |
| JLS / JPMS | Java仕様の深掘り、モジュール化構造の理解（余裕があれば） |

### **第3フェーズ：テストと品質保証の実践**

| 項目 | 内容 |
| --- | --- |
| JUnit（4 or 5） | 単体テストの書き方、アサーション、セットアップ、例外テスト |
| Mockito | モックによる依存の切り離し |
| TDD（テスト駆動開発） | テスト→実装→リファクタの循環型開発 |
| テスト設計技法 | 等価クラス、境界値、状態遷移など（基本だけでOK） |

### **第4フェーズ：実務開発の準備（フレームワーク／構成管理）**

| 項目 | 内容 |
| --- | --- |
| フレームワーク基礎 | Spring Framework（DI / AOP / MVC / Boot） |
| ビルドツール | Maven or Gradle（依存管理、ビルド、JAR作成） |
| ログ設計 | Logback / SLF4J（ログレベル、ロガーの設計） |
| 例外処理設計 | ハンドリング方針、ログ連携、ユーザーフィードバック方法 |
| レイヤー設計 | Controller / Service / Repository などの役割分離 |

### 学習期間目安

| フェーズ | 学習期間の目安 | 目的 |
| --- | --- | --- |
| 第1フェーズ | 1～2ヶ月 | Javaの基本力を身につける |
| 第2フェーズ | 1ヶ月前後 | 設計と品質への意識を高める |
| 第3フェーズ | 1ヶ月 | 品質保証・テスト技術を実装と共に理解 |
| 第4フェーズ | 2ヶ月～ | 実務で使える構造・運用・フレームワーク技術を習得 |