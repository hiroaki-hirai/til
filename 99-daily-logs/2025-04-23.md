## ✅ 今日やったこと
- Collectionまとめ
- 例外まとめ
- コンパイルエラーまとめ

<br>

## 📌 TIL
### ✏️ Collectionまとめ
#### List : 順序あり・重複可

- 実装：
    - ArrayList
    - LinkedList
- 作成方法：
    - new ArrayList<>()
    - Arrays.asList()
    - List.of()（変更不可）
- 特徴：
    - 性能差の補足
        - ランダムアクセス性能は `ArrayList` ＞ `LinkedList`
        - 挿入/削除は `LinkedList` が優位（ただし、イテレータ利用時に限る）
    - subList(), contains(), indexOf() など
- 変換：
    - Set/Map との相互変換

#### Set : 順序なし・重複不可

- 実装：
    - HashSet
    - TreeSet（ソート）
    - LinkedHashSet（順序保持）
- 特徴：
    - equals/hashCode に依存
    - nullの扱い
        - `HashSet` → `null` 追加可能
        - `TreeSet` → `null` 非許容（Comparatorが必要）
- 作成方法：
    - new HashSet<>(),
    - Set.of()
- 変換：
    - List/Map との相互変換

#### Map : key/valueのペア

- 実装：
    - HashMap
    - TreeMap（ソート）
    - LinkedHashMap（順序保持）
    - 
- 特徴：
    - keySet(), values(), entrySet()
    - nullの扱い
        - `HashMap` → `null`キー/値 OK
        - `TreeMap` → `null`キー NG（Comparator未設定の場合）
- 作成方法：
    - new HashMap<>(),
    - Map.of()
- 注意点：
    - Iterable 非実装（entrySetでfor可）

#### Queue / Deque / Stack

- Queue：LinkedList, PriorityQueue
- Deque：ArrayDeque（双方向）
- Stack（古い）：java.util.Stack

### ✏️ 例外まとめ
→ 現在把握している例外まとめ
- java.lang.ArithmethicException
- java.lang.ArrayIndexOutOfBoundsException
- java.lang.NullPointerException
- java.lang.ClassCastException
- java.lang.CloneNotSupportedException
- java.lang.NumberFormatException
- java.util.ConcurrentModificationException
- java.text.ParseException
- java.time.format.DateTimeParseException

### ✏️ コンパイルエラーまとめ
→ 現在把握している例外まとめ
#### ⑩ ローカル変数を初期化せずに当該変数を参照する場合

⇒ 「初期化未遂」で、コンパイルエラーとなる

---

#### ⑪ 文字列リテラルの中でそのまま改行をする場合

⇒ 「””で正しく閉じられていない」で、コンパイルエラーとなる

---

#### ⑫ 数値型の縮小変換でキャストを使用しない場合

⇒ キャストを使用しない場合、コンパイルエラーとなる

⇒ ”桁あふれ (オーバーフロー)” にも気をつける 

//オーバーフロー自体はコンパイルエラーは発生しない + キャストした場合でも発生する

⇒ ”情報落ち” にも気をつける (double から int への場合)

//情報落ち自体もコンパイルエラーは発生しない + キャストした場合でも発生する

---

#### ⑬ 型サフィックスを使用しない場合

```java
long x = 3_000_000_000; // 30億はint型の範囲外 ⇒ コンパイルエラー
```

⇒ 整数リテラルは int 型、浮動小数点リテラルは double 型がそれぞれデフォルト

⇒ long 型には ‘L’ を、float 型には ’F’ をつける

---

#### ⑭ ローカル変数の型推論の制約を守らない場合

```java
var x; //  コンパイルエラー
var x = 10, y = 20; //  コンパイルエラー
```

⇒ 制約

- 宣言と初期値の代入は、同時に行う必要あり
- １つの命令文内で、複数の変数を宣言することは不可

⇒ 型推論は、フィールド変数には使用不可

---

#### ⑮ 演算子とキャストの関係

```java
int x = 100;
int y = (int) x * 0.1; // コンパイルエラー
int y = (int) (x * 0.1); // () で囲ってやる必要あり
```

---

#### ※ String型変数の値の等価性を判断する場合

```java
if (str == "foo") // コンパイルエラーにならないが。。。
if (str.equals("foo")) // このように記述する必要あり
```

---

#### ⑮ 複数の case 句で同一のラベルをして指定する場合

---

#### ⑯ 拡張 for 文に指定された変数のデータ型と配列やコレクションに格納された要素のデータ型が不一致の場合

※拡張 for 文が利用できるのは、配列＋ java.lang.Iterable インターフェースを実装したクラスのみ

---

#### ⑰ 存在しないフィールドを指定する場合

---

#### ※ static で修飾されたメソッドをオブジェクト名で呼び出してもエラーにはならないが、IDEによっては警告が出る場合あり
⇒ 基本 クラス名でアクセスする

---

#### ⑱ メソッド内の宣言にて指定された戻り値型とreturnで指定された戻り値のデータ型が異なる場合

#### また、別クラスから戻り値のあるメソッドを呼び出す場合、呼び出し先メソッドが返した値と、呼び出し元で受け取った変数の間で型の不一致がる場合

---

#### ⑲ return文よりも後ろで、命令文を記述した場合

---

#### ⑳ オブジェクト生成時 (new) に実引数とコンストラクタ側に仮引数に方の不一致がある場合

---

#### ㉑ １つのクラスの中にシグネチャが同じメソッドを複数宣言する場合

⇒ オーバーロード時の確認事項

---

#### ㉒ this キーワードによるコンストラクタの呼び出しをコンストラクタ内の先頭に記述しない場合

---

#### ㉓ 存在しないstaticメソッドにアクセスする場合

---

#### ㉔ final 修飾子をフィールドに設定したのに、コンストラクタを用意しない場合

⇒ この場合、コンストラクタは必須。final修飾子を付与したフィールド全てに必要

---

#### ㉕ final 修飾子を複数のフィールドに設定し、一部のフィールドを仮引数としてオーバーロードした場合

---

#### ㉖ final 修飾子をローカル変数に設定し、再代入する場合

---

#### ㉗ クラスの中で１行目に一度だけ宣言するルールに違反する場合

---

#### ㉘ アクセス修飾子に版下呼び出しをする場合

---

#### ㉙ superキーワードによる親クラスのコンストラクタ呼び出しを、子クラスのコンストラクタ内の先頭に記述しない場合

---

#### ㉚ 抽象クラスにて抽象メソッドが定義されている場合、子クラス側でその抽象メソッドをオーバーライドしない場合

---

#### ㉛ インターフェースを複数継承した場合に、複数のメソッド間でシグネチャ＋戻り値が異なる場合はオーバーライドすると「シグネチャが同じメソッドは複数宣言できない」ルールに抵触しコンパイルエラー

---

#### ㉜ コレクションのリストからget()で要素を取り出すとき、そのリストの型と異なる変数へ代入するとコンパイルエラー

<br>

## 🤔 疑問・今後調べること・今後の課題
- 列挙型と定数ラップパターンとの比較の詳細確認
- JVMの動作を念頭に置いた学習
- 正規表現の応用確認 → 「詳説 正規表現」 で確認予定

<br>

## 🛠️ 実行したコード or コマンド
### 
#### 1：matches(),lookingAt(),group()
```java
String str = "FooCompany is the best Company"; //【1】
Pattern pattern = Pattern.compile("^FooCompany.*"); //【2】
Matcher matcher = pattern.matcher(str); //【3】
boolean matches = matcher.matches(); //【4】true　全範囲
boolean lookingAt = matcher.lookingAt(); //【5】true　先頭から
String group = matcher.group(); //【6】"FooCompany"　マッチした文字列の取り出し

boolean matches = Pattern.matches("^FooCompany.*"); // 簡潔記述可能
boolean matches = str.matches("^FooCompany.*"); // Stringクラス型でも可能
// ※正規表現を使い回す場合は上の記述で
```
#### 2：find()
```java
String str = "FooCompany is better than BarCompany"; //【1】
Pattern pattern = Pattern.compile("([A-Z].*?)Company"); //【2】
Matcher matcher = pattern.matcher(str); //【3】
boolean find1 = matcher.find(); //【4】true　先頭から検索
String group1 = matcher.group(); //【5】"FooCompany"
boolean find2 = matcher.find(); //【6】true　マッチした文字列の次の文字列から検索
String group2 = matcher.group(); //【7】"BarCompany"
boolean find3 = matcher.find(); //【8】false
```
#### 3：形式チェック (電話番号を例に)
```java
private static boolean checkPhoneNumber(String phoneNumber) {
        return Pattern.matches("\\d{2,4}-\\d{2,4}-\\d{4}", phoneNumber);
    }
```
#### 4：replaceAll()
```java
String before = "FooCompany";
Pattern pattern = Pattern.compile("[a-z]");
Matcher matcher = pattern.matcher(before);
String after = matcher.replaceAll("x"); //【1】FxxCxxxxx
// replaceFirst() の場合は最初の文字のみ置換 FxoCompany
```
#### 5：String クラスの replace()
```java
String before = "FooCompany";
String after = before.replaceAll("[a-z]", "x");
// ※繰り返し正規表現を使用する場合は Pattern,Matcher を使用
```
### BigDecimalクラス
```java
// 外部から文字列として渡される場合 (ユーザーの入力など)
BigDecimal val = new BigDecimal("123.4567");
// 値とスケールを別々に管理するケース
BigDecimal val = BigDecimal.valueOf(1234567, 4);
// 通常使用 Double型のtoStringメソッドより文字列として生成
BigDecimal val = BigDecimal.valueOf(123.4567);
// コンストラクタにdouble型の値を渡した時点で誤差発生より使用は控える
BigDecimal val = new BigDecimal(123.4567);
```
```java
// 加算
BigDecimal val1 = BigDecimal.valueOf(123.4567);
BigDecimal val2 = BigDecimal.valueOf(90000.000009);
BigDecimal result = val1.add(val2); // 90123.456709
```
```java
// 除算 丸めも込で
BigDecimal val1 = BigDecimal.valueOf(123.4567);
BigDecimal val2 = BigDecimal.valueOf(3.0);
BigDecimal result = val1.divide(val2, 5, RoundingMode.HALF_UP); // 41.15223
// ※ 第３引数として丸めモードを指定しない場合は ArithmeticException例外発生

/* java.math.RoundingMode列挙型
CEILING
FLOOR
UP
DOWN
HALF_UP
HALF_DOWN
HALF_EVEN
*/
```
- BigDecimal.equals() → オブジェクトなので
- BigDecimal.compareTo() → オブジェクトなので
<br>

##  🧩学習方針・ロードマップ
以下の項目、スケジュールで学習していきます。

### **第1フェーズ：Java言語の基礎と実行環境の理解**

| 項目 | 内容 |
| --- | --- |
| JDK / JRE / JVM | Javaアプリがどのように動いているかを理解 |
| Java文法復習（Silverレベル） | 基本構文・制御構文・オブジェクト指向・例外処理 |
| Java API | String, List, Map, Stream などの標準ライブラリの使い方 |
| コレクションAPI・ラムダ式・Stream API | データ処理の基本として重要（実務で頻出） |

### **第2フェーズ：設計力の基礎とコードの質の向上**

| 項目 | 内容 |
| --- | --- |
| SOLID原則 | 拡張しやすく壊れにくい設計の5原則 |
| デザインパターン | Strategy, Factory, Decorator, Compositeなど代表パターン |
| リファクタリング | コードの可読性・保守性向上。メソッド抽出、分割、置換など |
| JLS / JPMS | Java仕様の深掘り、モジュール化構造の理解（余裕があれば） |

### **第3フェーズ：テストと品質保証の実践**

| 項目 | 内容 |
| --- | --- |
| JUnit（4 or 5） | 単体テストの書き方、アサーション、セットアップ、例外テスト |
| Mockito | モックによる依存の切り離し |
| TDD（テスト駆動開発） | テスト→実装→リファクタの循環型開発 |
| テスト設計技法 | 等価クラス、境界値、状態遷移など（基本だけでOK） |

### **第4フェーズ：実務開発の準備（フレームワーク／構成管理）**

| 項目 | 内容 |
| --- | --- |
| フレームワーク基礎 | Spring Framework（DI / AOP / MVC / Boot） |
| ビルドツール | Maven or Gradle（依存管理、ビルド、JAR作成） |
| ログ設計 | Logback / SLF4J（ログレベル、ロガーの設計） |
| 例外処理設計 | ハンドリング方針、ログ連携、ユーザーフィードバック方法 |
| レイヤー設計 | Controller / Service / Repository などの役割分離 |

### 学習期間目安

| フェーズ | 学習期間の目安 | 目的 |
| --- | --- | --- |
| 第1フェーズ | 1～2ヶ月 | Javaの基本力を身につける |
| 第2フェーズ | 1ヶ月前後 | 設計と品質への意識を高める |
| 第3フェーズ | 1ヶ月 | 品質保証・テスト技術を実装と共に理解 |
| 第4フェーズ | 2ヶ月～ | 実務で使える構造・運用・フレームワーク技術を習得 |